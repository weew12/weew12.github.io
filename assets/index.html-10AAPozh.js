import{_ as i,c as a,a as h,o as l}from"./app-BO2U5m27.js";const t={};function n(e,s){return l(),a("div",null,[...s[0]||(s[0]=[h(`<h2 id="_1-排序数据" tabindex="-1"><a class="header-anchor" href="#_1-排序数据"><span>1. 排序数据</span></a></h2><h3 id="_1-1-排序规则" tabindex="-1"><a class="header-anchor" href="#_1-1-排序规则"><span>1.1 排序规则</span></a></h3><ul><li>使用 <code>ORDER BY</code> 子句排序 <ul><li><strong>ASC</strong>（ascend）: 升序(默认)</li><li><strong>DESC</strong>（descend）:降序</li></ul></li><li><code>ORDER BY</code><strong>子句在SELECT语句的结尾。</strong></li></ul><h3 id="_1-2-单列排序" tabindex="-1"><a class="header-anchor" href="#_1-2-单列排序"><span>1.2 单列排序</span></a></h3><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> last_name, job_id, department_id, hire_date</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> employees</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> hire_date ;</span></span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2025/png/2447732/1756714516561-079d36e5-941f-44db-a471-5e03cf2a8c87.png" alt=""></p><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> last_name, job_id, department_id, hire_date</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> employees</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> hire_date </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">DESC</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> ;</span></span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2025/png/2447732/1756714516788-2ab466a0-5f2a-44d1-9f60-2e2a374493f1.png" alt=""></p><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> employee_id, last_name, salary</span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 12</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> annsal</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> employees</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> annsal;</span></span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2025/png/2447732/1756714518172-f4b0a24b-eafb-48e6-acbc-695e042d7f19.png" alt=""></p><h3 id="_1-3-多列排序" tabindex="-1"><a class="header-anchor" href="#_1-3-多列排序"><span>1.3 多列排序</span></a></h3><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> last_name, department_id, salary</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> employees</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> department_id, salary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">DESC</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">;</span></span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2025/png/2447732/1756714518380-fdf045d6-0178-46b8-b602-1adeb57e970e.png" alt=""></p><ul><li>可以使用不在SELECT列表中的列排序</li><li><strong>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序</strong></li></ul><p>补充：</p><p>你可以把多列排序想象成<strong>先分组，再组内排序</strong>的过程：</p><ol><li><strong>首要排序</strong>：数据库首先严格按照 <code>ORDER BY</code> 子句中<strong>第一列</strong>指定的顺序（升序或降序）对所有数据进行排序。</li><li><strong>判断是否需要次要排序</strong>：只有当第一列的值出现<strong>重复</strong>（相同）时，数据库才会在这些“重复值的组”里，根据 <code>ORDER BY</code> 子句中<strong>第二列</strong>指定的规则进行排序。</li><li><strong>后续列的处理</strong>：如果指定了更多列，此逻辑会继续下去。即在前一列值相同的组内，再按下一列排序，依此类推。<br> 因此，<strong>如果第一列的所有值都是唯一的，就意味着没有需要“组内再排序”的记录，数据库自然会跳过所有后续列的排序</strong>。</li></ol><h2 id="_2-分页" tabindex="-1"><a class="header-anchor" href="#_2-分页"><span>2. 分页</span></a></h2><h3 id="_2-1-背景" tabindex="-1"><a class="header-anchor" href="#_2-1-背景"><span>2.1 背景</span></a></h3><p>背景 1 ：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？</p><p>背景 2 ：表里有 4 条数据，我们只想要显示第 2 、 3 条数据怎么办呢？</p><h3 id="_2-2-实现规则" tabindex="-1"><a class="header-anchor" href="#_2-2-实现规则"><span>2.2 实现规则</span></a></h3><ul><li>分页原理 <ul><li>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件</li></ul></li><li><strong>MySQL中使用 <strong><code>LIMIT</code></strong> 实现分页</strong></li><li>格式： <ul><li><code>LIMIT [位置偏移量, 行数]</code></li><li>第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0 ，第二条记录的位置偏移量是1 ，以此类推）；第二个参数“行数”指示返回的记录条数。</li></ul></li><li>举例</li></ul><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#464B5D;--shiki-dark-font-style:italic;">--前 10 条记录：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> 表名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">LIMIT</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#464B5D;--shiki-dark-font-style:italic;">-- 或者</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> 表名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">LIMIT</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> ;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#464B5D;--shiki-dark-font-style:italic;">--第 11 至 20 条记录：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> 表名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">LIMIT</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> ;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#464B5D;--shiki-dark-font-style:italic;">--第 21 至 30 条记录：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> 表名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">LIMIT</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> ;</span></span></code></pre></div><blockquote><p>MySQL 8.0中可以使用“<code>LIMIT 3 OFFSET 4</code>”，意思是获取从第 5 条记录开始后面的 3 条记录，和“<code>LIMIT 4,3;</code>”返回的结果相同。</p></blockquote><ul><li>分页显式公式 ：<strong>（当前页数- 1 ）</strong><code>*</code><strong>每页条数，每页条数</strong></li></ul><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> FROM</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> table</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">LIMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">(PageNo </span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> )</span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">PageSize,PageSize;</span></span></code></pre></div><ul><li>注意：<strong>LIMIT 子句必须放在整个SELECT语句的最后</strong></li><li>使用 LIMIT 的好处<br> 约束返回结果的数量可以<strong>减少数据表的网络传输量</strong>，也可以<strong>提升查询效率</strong>。如果我们知道返回结果只有1 条，就可以使用LIMIT 1，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</li></ul><h3 id="_2-3-拓展" tabindex="-1"><a class="header-anchor" href="#_2-3-拓展"><span>2.3 拓展</span></a></h3><p>在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。</p><ul><li>如果是 SQL Server 和 Access，需要使用 TOP 关键字，比如：</li></ul><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> TOP</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">, hp_max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> heros </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> hp_max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">DESC</span></span></code></pre></div><ul><li>如果是 DB2，使用<strong>FETCH FIRST 5 ROWS ONLY</strong>这样的关键字</li></ul><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">, hp_max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> heros </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> hp_max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">DESC</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> FETCH</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> FIRST</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> ROWS</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> ONLY</span></span></code></pre></div><ul><li>如果是 Oracle，你需要基于 <strong>ROWNUM</strong> 来统计行数：</li></ul><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> rownum,last_name,salary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> employees </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> rownum </span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> salary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">DESC</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">;</span></span></code></pre></div><p>需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。后面用子查询，可以使用:</p><div class="language-sql" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#24292e;--shiki-dark:#babed8;--shiki-light-bg:#fff;--shiki-dark-bg:#0F111A;"><pre class="shiki shiki-themes github-light material-theme-ocean vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> rownum, last_name,salary</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> (</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> last_name,salary</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> employees</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;"> ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> salary </span><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">DESC</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F78C6C;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> rownum </span><span style="--shiki-light:#D73A49;--shiki-dark:#89DDFF;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#F78C6C;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#BABED8;"> ;</span></span></code></pre></div><p>得到与上述方法一致的结果。</p>`,39)])])}const p=i(t,[["render",n]]),r=JSON.parse('{"path":"/mysql/wmtsc974/","title":"第05章_排序与分页","lang":"zh-CN","frontmatter":{"title":"第05章_排序与分页","createTime":"2025/09/01 16:16:33","permalink":"/mysql/wmtsc974/","description":"1. 排序数据 1.1 排序规则 使用 ORDER BY 子句排序 ASC（ascend）: 升序(默认) DESC（descend）:降序 ORDER BY子句在SELECT语句的结尾。 1.2 单列排序 1.3 多列排序 可以使用不在SELECT列表中的列排序 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第05章_排序与分页\\",\\"image\\":[\\"https://cdn.nlark.com/yuque/0/2025/png/2447732/1756714516561-079d36e5-941f-44db-a471-5e03cf2a8c87.png\\",\\"https://cdn.nlark.com/yuque/0/2025/png/2447732/1756714516788-2ab466a0-5f2a-44d1-9f60-2e2a374493f1.png\\",\\"https://cdn.nlark.com/yuque/0/2025/png/2447732/1756714518172-f4b0a24b-eafb-48e6-acbc-695e042d7f19.png\\",\\"https://cdn.nlark.com/yuque/0/2025/png/2447732/1756714518380-fdf045d6-0178-46b8-b602-1adeb57e970e.png\\"],\\"dateModified\\":\\"2025-09-01T08:17:17.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://weew12.github.io/mysql/wmtsc974/"}],["meta",{"property":"og:site_name","content":"WEEW12 BLOG"}],["meta",{"property":"og:title","content":"第05章_排序与分页"}],["meta",{"property":"og:description","content":"1. 排序数据 1.1 排序规则 使用 ORDER BY 子句排序 ASC（ascend）: 升序(默认) DESC（descend）:降序 ORDER BY子句在SELECT语句的结尾。 1.2 单列排序 1.3 多列排序 可以使用不在SELECT列表中的列排序 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.nlark.com/yuque/0/2025/png/2447732/1756714516561-079d36e5-941f-44db-a471-5e03cf2a8c87.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-01T08:17:17.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-01T08:17:17.000Z"}]]},"readingTime":{"minutes":3.79,"words":1136},"git":{"createdTime":1756714637000,"updatedTime":1756714637000,"contributors":[{"name":"weew12","username":"weew12","email":"2528566339@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/weew12?v=4","url":"https://github.com/weew12"}]},"autoDesc":true,"filePathRelative":"notes/database/mysql/第05章_排序与分页.md","headers":[]}');export{p as comp,r as data};
