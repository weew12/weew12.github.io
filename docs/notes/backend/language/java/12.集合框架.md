---
title: 集合框架
createTime: 2025/08/22 22:41:51
permalink: /language/java/fqqt45mw/
---
### 1. 集合框架概述

#### 生活中的容器

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733401951318-c69ca579-6174-4bcc-b626-aa2b6f616c40.png)

#### 数组的特点与弊端

- 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象进行操作，就要对对象进行存储
- 使用数组存储对象有一些弊端，`Java`集合就像一种容器，可以动态地把多个对象的引用放入其中
- **数组在内存存储方面的特点**
  - 数组初始化以后，长度就确定了
  - 数组中添加的元素是依次紧密排列的、有序的、可以重复的
  - 数组声明的类型决定了元素初始化时的类型，不符合此类型的变量不能添加
  - 数组可以存储基本数据类型的值，也可以存储引用数据类型的变量
- **数组在存储数据方面的弊端**
  - 数组初始化以后长度就不可变了，不便于扩展
  - 数组中提供的属性和方法少，不便于添加、删除、插入、获取元素个数等操作，且效率不高
  - 数组存储的数据特点单一，只能存储有序的、可重复的数据
- **<font style="color:#DF2A3F;">Java 集合框架中的类可以用于存储多个对象，还可用于保存具有映射关系的关联数组</font>**

#### Java集合框架体系

`Java`集合可分为`**Collection**`和`**Map**`\*\*\*\*两大体系

- `**Collection**`**接口**：用于存储一个一个的数据，**也称单列数据集合**
  - `**List**`子接口：用来存储**有序的、可以重复的数据**（**主要用来替换数组**），可以作为**"动态"数组**
    - 实现类：`ArrayList`(主要实现类) `LinkedList``Vector`
- `**Set**`**子接口**：用来存储**无序的、不可重复的数据**（类似于高中讲的"集合"）
  - 实现类：`HashSet`(主要实现类) `LinkedHashSet``TreeSet`
- `**Map**`**接口**：用于存储**具有映射关系**`**key-value**`**的集合**，**也称双列数据集合**
  - 实现类：`HashMap`(主要实现类) `LinkedHashMap``TreeMap``Hashtable``Properties`
- `<font style="color:#DF2A3F;">JDK</font>`<font style="color:#DF2A3F;">提供的集合</font>`<font style="color:#DF2A3F;">API</font>`<font style="color:#DF2A3F;">位于</font>`<font style="color:#DF2A3F;">java.util</font>`<font style="color:#DF2A3F;">包内</font>
- **集合框架全图\*\***<font style="color:rgb(31, 35, 40);"> </font>\*\*

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733401954804-276ba20e-238c-4977-9ac6-2ed4b51f6932.png)  

- `**Collection**`**接口继承树**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733401961231-420f9999-67c7-4d5c-8826-edce871556bf.png)

- `**Map**`**接口继承树**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733401965060-18beebdb-b75a-4de7-9aa3-bb1352044d7a.png)

#### 集合的使用场景

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733401969118-7dddeea9-237f-4245-ad03-f274afe7be91.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733401971902-2432ca78-4c21-4eca-b7ab-a8c73f8ae06d.png)

### 2. `Collection`接口及方法

- `JDK`不提供此接口的任何直接实现，而是提供更具体的子接口（`Set`和`List`等）去实现
- `Collection`接口是`List`和`Set`接口的父接口，该接口里定义的方法既可用于操作`Set`集合，也可用于操作`List`集合

#### 添加

- `add(E obj)`：**添加元素**对象到当前集合中
- `addAll(Collection other)`：**添加**`**other**`**集合**中的所有元素对象到当前集合中，即`this = this∪other`

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

public class CollectionAddTest {
    @Test
    public void addTest() {
        // ArrayList 是 Collection 的子接口List的实现类之一
        Collection coll = new ArrayList<>();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        System.out.println(coll);
    }

    @Test
    public void addAllTest() {
        Collection c1 = new ArrayList();
        c1.add(1);
        c1.add(2);
        System.out.println("c1集合元素的个数：" + c1.size());
        System.out.println("c1 = " + c1);

        Collection c2 = new ArrayList();
        c2.add(1);
        c2.add(2);
        System.out.println("c1集合元素的个数：" + c2.size());
        System.out.println("c1 = " + c2);

        Collection other = new ArrayList();
        other.add(1);
        other.add(2);
        other.add(3);
        System.out.println("other集合元素的个数：" + other.size());
        System.out.println("other = " + other);
        System.out.println();

        c1.addAll(other);
        System.out.println("c1集合元素的个数：" + c1.size());
        System.out.println("c1.addAll(other) = " + c1);

        c2.add(other);
        System.out.println("c2集合元素的个数：" + c2.size());
        System.out.println("c2.add(other) = " + c2);
    }
}
```

**<font style="color:#DF2A3F;">注意：</font>**`**<font style="color:#DF2A3F;">coll.addAll(other);</font>**`**<font style="color:#DF2A3F;">与</font>**`**<font style="color:#DF2A3F;">coll.add(other);</font>**`

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733041542544-460191a5-fa73-4148-a2e6-f89353f25ba6.png)

#### 判断

- `int size()`：获取当前集合中实际存储的**元素个数**
- `boolean isEmpty()`：判断当前集合**是否为空集合**
- `boolean contains(Object obj)`：**当前集合是否存在与**`**obj**`**对象**`**equals**`**返回**`**true**`**的元素**
- `boolean containsAll(Collection coll)`：`**coll**`**集合中的元素是否在当前集合中都存在**
- `boolean equals(Object obj)`：**判断当前集合与**`**obj**`**是否相等**

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

public class CollectionContainsTest {
    @Test
    public void test01() {
        Collection coll = new ArrayList();
        System.out.println("coll在添加元素之前，isEmpty = " + coll.isEmpty());
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll的元素个数" + coll.size());
        System.out.println("coll在添加元素之后，isEmpty = " + coll.isEmpty());
    }

    @Test
    public void test02() {
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);
        System.out.println("coll是否包含“小李广” = " + coll.contains("小李广"));
        System.out.println("coll是否包含“宋红康” = " + coll.contains("宋红康"));

        Collection other = new ArrayList();
        other.add("小李广");
        other.add("扫地僧");
        other.add("尚硅谷");
        System.out.println("other = " + other);
        System.out.println("coll.containsAll(other) = " + coll.containsAll(other));
    }

    @Test
    public void test03() {
        Collection c1 = new ArrayList();
        c1.add(1);
        c1.add(2);
        //2
        System.out.println("c1集合元素的个数：" + c1.size());
        System.out.println("c1 = " + c1);

        Collection c2 = new ArrayList();
        c2.add(1);
        c2.add(2);
        //2
        System.out.println("c2集合元素的个数：" + c2.size());
        System.out.println("c2 = " + c2);

        Collection other = new ArrayList();
        other.add(1);
        other.add(2);
        other.add(3);
        //3
        System.out.println("other集合元素的个数：" + other.size());
        System.out.println("other = " + other);
        System.out.println();

        c1.addAll(other);
        //5
        System.out.println("c1集合元素的个数：" + c1.size());
        System.out.println("c1.addAll(other) = " + c1);
        System.out.println("c1.contains(other) = " + c1.contains(other));
        System.out.println("c1.containsAll(other) = " + c1.containsAll(other));
        System.out.println();

        c2.add(other);
        System.out.println("c2集合元素的个数：" + c2.size());
        System.out.println("c2.add(other) = " + c2);
        System.out.println("c2.contains(other) = " + c2.contains(other));
        System.out.println("c2.containsAll(other) = " + c2.containsAll(other));
    }
}
```

#### 删除

- `void clear()`：**清空**集合元素
- `boolean remove(Object obj)`：**删除第一个找到的与**`**obj**`**对象**`**equals**`**返回**`**true**`**的元素**
- `boolean removeAll(Collection coll)`：从当前集合中**删除所有与**`**coll**`**集合中相同的元素**
- `boolean retainAll(Collection coll)`：**当前集合中仅保留两个集合的交集**

<font style="color:#DF2A3F;">注意几种删除方法的区别</font>

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

public class CollectionRemoveTest {
    @Test
    public void test01() {
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);

        coll.remove("小李广");
        System.out.println("删除元素\"小李广\"之后coll = " + coll);

        coll.clear();
        System.out.println("coll清空之后，coll = " + coll);
    }

    @Test
    public void test02() {
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);

        Collection other = new ArrayList();
        other.add("小李广");
        other.add("扫地僧");
        other.add("尚硅谷");
        System.out.println("other = " + other);

        coll.removeAll(other);
        System.out.println("coll.removeAll(other)之后，coll = " + coll);
        System.out.println("coll.removeAll(other)之后，other = " + other);
    }

    @Test
    public void test03() {
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);

        Collection other = new ArrayList();
        other.add("小李广");
        other.add("扫地僧");
        other.add("尚硅谷");
        System.out.println("other = " + other);

        coll.retainAll(other);
        System.out.println("coll.retainAll(other)之后，coll = " + coll);
        System.out.println("coll.retainAll(other)之后，other = " + other);
    }
}
```

#### 其它

- `Object[] toArray()`：**返回包含当前集合中所有元素的数组**
- `hashCode()`：**获取集合对象的哈希值**
- `iterator()`：**返回迭代器对象**，用于集合遍历

```java
public class TestCollectionContains {
    @Test
    public void test01() {
        Collection coll = new ArrayList();

        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        //集合转换为数组：集合的toArray()方法
        Object[] objects = coll.toArray();
        System.out.println("用数组返回coll中所有元素：" + Arrays.toString(objects));

        //对应的，数组转换为集合：调用Arrays的asList(Object ...objs)
        Object[] arr1 = new Object[]{123,"AA","CC"};
        Collection list = Arrays.asList(arr1);
        System.out.println(list);
    }
}

```

### 3. `Iterator`（迭代器）接口

#### `Iterator`接口

- 在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，`JDK`专门提供了一个接口`java.util.Iterator`。`Iterator`接口也是`Java`集合中的一员，但它与`Collection`、`Map`接口有所不同
  - `Collection`接口与`Map`接口主要用于存储元素
  - `Iterator`被称为**迭代器接口**，<font style="color:#DF2A3F;">并不提供存储对象的能力，主要用于遍历</font>`<font style="color:#DF2A3F;">Collection</font>`<font style="color:#DF2A3F;">的元素</font>
- `Collection`接口继承了`java.lang.Iterable`接口，该接口有一个`iterator()`方法，所有实现了`Collection`接口的集合类都有一个`iterator()`方法，用于返回一个实现了`Iterator`接口的对象。
  - `public Iterator iterator()`：**获取集合对应的迭代器**，用来遍历集合中的元素
  - **<font style="color:#DF2A3F;">集合对象每次调用</font>**`**<font style="color:#DF2A3F;">iterator()</font>**`**<font style="color:#DF2A3F;">方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前</font>**
- `Iterator`接口的常用方法
  - `public E next()`：返回迭代的下一个元素
  - `public boolean hasNext()`：如果仍有元素可以迭代，则返回`true`
- **注意**：<font style="color:#DF2A3F;">在调用</font>`<font style="color:#DF2A3F;">it.next()</font>`<font style="color:#DF2A3F;">方法之前必须要调用</font>`<font style="color:#DF2A3F;">it.hasNext()</font>`<font style="color:#DF2A3F;">进行检测。若不调用，且下一条记录无效，直接调用</font>`<font style="color:#DF2A3F;">it.next()</font>`<font style="color:#DF2A3F;">会抛出</font>`<font style="color:#DF2A3F;">NoSuchElementException</font>`<font style="color:#DF2A3F;">异常</font>

```java
package com.atguigu.iterator;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class TestIterator {
    @Test
    public void test01(){
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");

        Iterator iterator = coll.iterator();
        System.out.println(iterator.next());
        System.out.println(iterator.next());
        System.out.println(iterator.next());
        //报NoSuchElementException异常
        System.out.println(iterator.next());
    }

    @Test
    public void test02(){
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");

        //获取迭代器对象
        Iterator iterator = coll.iterator();
        //判断是否还有元素可迭代
        while(iterator.hasNext()) {
            //取出下一个元素
            System.out.println(iterator.next());
        }
    }
}
```

#### 迭代器的执行原理

`Iterator`迭代器对象在遍历集合时，<font style="color:#DF2A3F;">内部采用指针的方式来跟踪集合中的元素</font>，接下来通过一个图例来演示`Iterator`对象迭代元素的过程：

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733401981070-26e0db4d-1f26-437b-b287-1ca42c0b90ec.png)

**使用**`**Iterator**`**迭代器删除元素：**`**java.util.Iterator**`**迭代器中有一个方法**`**void remove();**`

```java
//回到起点
Iterator iter = coll.iterator();
while(iter.hasNext()){
    Object obj = iter.next();
    if(obj.equals("Tom")){
        iter.remove();
    }
}
```

**注意**：

- `Iterator`可以删除集合的元素，但是遍历过程中通过迭代器对象的`remove`方法，不是集合对象的`remove`方法
- 如果还未调用`next()`或在上一次调用 `next()`方法之后已经调用了`remove()`方法，再调用`remove()`都会报`IllegalStateException`
- `Collection`已经有`remove(xx)`方法了，为什么`Iterator`迭代器还要提供删除方法呢？
  - 因为迭代器的`remove()`可以按指定的条件进行删除

**<font style="color:#DF2A3F;">例如</font>**<font style="color:#DF2A3F;">：要删除以下集合元素中的偶数</font>

```java
package com.atguigu.iterator;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class TestIteratorRemove {
    @Test
    public void test01(){
        Collection coll = new ArrayList();
        coll.add(1);
        coll.add(2);
        coll.add(3);
        coll.add(4);
        coll.add(5);
        coll.add(6);

        Iterator iterator = coll.iterator();
        while(iterator.hasNext()){
            Integer element = (Integer) iterator.next();
            if(element % 2 == 0){
                iterator.remove();
            }
        }
        System.out.println(coll);
    }
}
```

**在**`**JDK8.0**`**时，**`**Collection**`**接口有了**`**removeIf**`**方法，可以根据条件删除**（第18章）

```java
package com.atguigu.collection;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Predicate;

public class TestCollectionRemoveIf {
    @Test
    public void test01(){
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        coll.add("佛地魔");
        System.out.println("coll = " + coll);

        coll.removeIf(new Predicate() {
            @Override
            public boolean test(Object o) {
                String str = (String) o;
                return str.contains("地");
            }
        });
        System.out.println("删除包含\"地\"字的元素之后coll = " + coll);
    }
}
```

#### `foreach`循环

- `foreach`循环（**增强**`**for**`**循环**）是`JDK5.0`定义的一个高级`for`循环，**<font style="color:#DF2A3F;">专门用来遍历数组和集合</font>**
- `foreach`循环的语法格式

```java
for(元素的数据类型 局部变量 : Collection集合或数组){
    //操作局部变量的输出操作
}
//这里局部变量就是一个临时变量，自己命名就可以
```

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

public class TestForeach {
    @Test
    public void test01(){
        Collection coll = new ArrayList();
        coll.add("小李广");
        coll.add("扫地僧");
        coll.add("石破天");
        //foreach循环其实就是使用Iterator迭代器来完成元素的遍历的。
        for (Object o : coll) {
            System.out.println(o);
        }
    }

    @Test
    public void test02(){
        int[] nums = {1,2,3,4,5};
        for (int num : nums) {
            System.out.println(num);
        }
        System.out.println("-----------------");
        String[] names = {"张三","李四","王五"};
        for (String name : names) {
            System.out.println(name);
        }
    }
}
```

- 对于集合的遍历，**<font style="color:#DF2A3F;">增强</font>**`**<font style="color:#DF2A3F;">for</font>**`**<font style="color:#DF2A3F;">的内部原理其实是个</font>**`**<font style="color:#DF2A3F;">Iterator</font>**`**<font style="color:#DF2A3F;">迭代器</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733041580676-76f3b6aa-d761-4aa1-b2ce-e1202f714da8.png)

- **<font style="color:#DF2A3F;">它用于遍历</font>**`**<font style="color:#DF2A3F;">Collection</font>**`**<font style="color:#DF2A3F;">和</font>**`**<font style="color:#DF2A3F;">数组</font>**`**<font style="color:#DF2A3F;">，通常只进行遍历，不要在遍历过程中对集合元素进行增删操作</font>**

```java
public class ForTest {
    public static void main(String[] args) {
        String[] str = new String[5];
        for (String myStr : str) {
            // 此处是临时变量 修改对于外部的str数组元素来说是无效的
            myStr = "atguigu";
            System.out.println(myStr);
        }
        for (int i = 0; i < str.length; i++) {
            System.out.println(str[i]);
        }
    }
}
```

### 4. `Collection`子接口`List`

#### `List`接口特点

- `Java`中数组用来存储数据有局限性，通常使用`java.util.List`来替代数组
- `List`集合类中元素有序、可重复，集合中的每个元素都有其对应的顺序索引
  - **举例**：`List`集合存储数据，就像银行门口的客服给每一个来办理业务的客户分配序号：第`1`个来的是张三，客服给他分配的是`0`；第`2`个来的是李四，客服给他分配的`1`；以此类推，最后一个序号应该是`总人数-1`

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733041585479-d74575e6-e148-485d-9093-01546f157e11.png)

- `JDK``API`中`List`接口的实现类常用的有：`**ArrayList**``**LinkedList**``**Vector**`

#### `List`接口方法

`<font style="color:#DF2A3F;">List</font>`<font style="color:#DF2A3F;">除了从</font>`<font style="color:#DF2A3F;">Collection</font>`<font style="color:#DF2A3F;">集合继承的方法外，</font>**<font style="color:#DF2A3F;">还添加了一些根据索引操作集合元素的方法</font>**

- **插入元素**
  - `void add(int index, Object ele)`：在`index`位置插入`ele`元素
  - `boolean addAll(int index, Collection eles)`：从`index`位置开始将`eles`中的所有元素添加进来
- **获取元素**
  - `Object get(int index)`：获取指定`index`位置的元素
  - `List subList(int fromIndex, int toIndex)`：返回从`**[**fromIndex`到`toIndex**)**`位置的子集合
- **获取元素索引**
  - `int indexOf(Object obj)`：返回`obj`在集合中**首次出现**的位置
  - `int lastIndexOf(Object obj)`：返回`obj`在当前集合中**末次出现**的位置
- **删除和替换元素**
  - `Object remove(int index)`：移除指定`index`位置的元素，并返回此元素
  - `Object set(int index, Object ele)`：设置指定`index`位置的元素为`ele`

```java
import java.util.ArrayList;
import java.util.List;

public class TestListMethod {
    public static void main(String[] args) {
        // 创建List集合对象
        List<String> list = new ArrayList<String>();

        // 往 尾部添加 指定元素
        list.add("图图");
        list.add("小美");
        list.add("不高兴");
        System.out.println(list);

        // add(int index,String s) 往指定位置添加
        list.add(1,"没头脑");
        System.out.println(list);

        // String remove(int index) 删除指定位置元素  返回被删除元素
        // 删除索引位置为2的元素
        System.out.println("删除索引位置为2的元素");
        System.out.println(list.remove(2));
        System.out.println(list);

        // String set(int index,String s)
        // 在指定位置 进行 元素替代（改）
        // 修改指定位置元素
        list.set(0, "三毛");
        System.out.println(list);

        // String get(int index)  获取指定位置元素
        // 跟size() 方法一起用  来 遍历的
        for(int i = 0;i<list.size();i++){
            System.out.println(list.get(i));
        }

        //还可以使用增强for
        for (String string : list) {
            System.out.println(string);
        }
    }
}
```

**注意：\*\***<font style="color:#DF2A3F;">在</font>**`**<font style="color:#DF2A3F;">JavaSE</font>**`**<font style="color:#DF2A3F;">中</font>**`**<font style="color:#DF2A3F;">List</font>**`**<font style="color:#DF2A3F;">名称的类型有 2 个，一个是</font>**`**<font style="color:#DF2A3F;">java.util.List</font>**`**<font style="color:#DF2A3F;">集合接口，一个是</font>**`**<font style="color:#DF2A3F;">java.awt.List</font>**`**<font style="color:#DF2A3F;">图形界面的组件，别导错包了。</font>\*\*

#### `List`的实现类`ArrayList`

- `ArrayList`是`List`接口的主要实现类
- 本质上`ArrayList`是对象引用的一个“变长”数组
- `Arrays.asList(…)`方法返回的`List`集合，既不是`ArrayList`实例，也不是`Vector`实例，是一个固定长度的`List`集合（**<font style="color:#DF2A3F;">它的返回值是一个</font>**`**<font style="color:#DF2A3F;">List</font>**`**<font style="color:#DF2A3F;">接口的实现，但这个实现并不是</font>**`**<font style="color:#DF2A3F;">java.util.ArrayList</font>**`**<font style="color:#DF2A3F;">，而是</font>**`**<font style="color:#DF2A3F;">java.util.Arrays</font>**`**<font style="color:#DF2A3F;">类中的一个内部类</font>**`**<font style="color:#DF2A3F;">ArrayList</font>**`）

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733057884638-47d8ae99-9373-41e8-9708-ca6054ae6bbf.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733041595932-df744554-ae64-43c6-8052-ce8e2d2b869d.png)

#### `List`的实现类`LinkedList`

- <font style="color:#DF2A3F;">对于频繁的插入或删除元素的操作，建议使用</font>`<font style="color:#DF2A3F;">LinkedList</font>`<font style="color:#DF2A3F;">类，效率较高</font>，这是由底层采用链表（双向链表）结构存储数据决定的
- **特有方法**
  - `void addFirst(Object obj)`
  - `void addLast(Object obj)`
  - `Object getFirst()`
  - `Object getLast()`
  - `Object removeFirst()`
  - `Object removeLast()`

#### `List`的实现类`Vector`

- `Vector`是一个古老的集合，`JDK1.0`就有了。**<font style="color:#DF2A3F;">大多数操作与</font>**`**<font style="color:#DF2A3F;">ArrayList</font>**`**<font style="color:#DF2A3F;">相同，区别之处在于</font>**`**<font style="color:#DF2A3F;">Vector</font>**`**<font style="color:#DF2A3F;">是线程安全的</font>**
- 在各种`List`中，最好把`ArrayList`作为默认选择；当插入、删除频繁时，用`LinkedList`；`<font style="color:#DF2A3F;">Vector</font>`<font style="color:#DF2A3F;">总是比</font>`<font style="color:#DF2A3F;">ArrayList</font>`<font style="color:#DF2A3F;">慢，所以尽量避免使用</font>
- **特有方法**
  - `void addElement(Object obj)`
  - `void insertElementAt(Object obj, int index)`
  - `void setElementAt(Object obj, int index)`
  - `void removeElement(Object obj)`
  - `void removeAllElements()`

#### 练习

面试题：

```java
@Test
public void testListRemove() {
    List list = new ArrayList();
    list.add(1);
    list.add(2);
    list.add(3);
    updateList(list);
    //[1,2]
    System.out.println(list);
}

private static void updateList(List list) {
    list.remove(2);
}
```

### 5. `Collection`子接口`Set`

#### `Set`接口概述

- `Set`接口是`Collection`的子接口，`**<font style="color:#DF2A3F;">Set</font>**`**<font style="color:#DF2A3F;">接口相较于</font>**`**<font style="color:#DF2A3F;">Collection</font>**`**<font style="color:#DF2A3F;">接口没有提供额外的方法</font>**
- `Set`集合**不允许包含相同元素**，如果试把两个相同的元素加入同一个`Set`集合中，则添加操作失败
- `Set`集合支持的遍历方式和`Collection`集合一样：`foreach`和`Iterator`
- `Set`的常用实现类有：`HashSet`、`TreeSet`、`LinkedHashSet`

#### `Set`实现类`HashSet`

##### `HashSet`概述

- `HashSet`是`Set`接口的**主要实现类**，大多数时候使用`Set`集合时都使用这个实现类
- `HashSet`按`Hash`算法来存储集合中的元素，**<font style="color:#DF2A3F;">因此具有很好的存储、查找、删除性能</font>**
- `**HashSet**`**具有以下特点**
  - **<font style="color:#DF2A3F;">不能保证元素的排列顺序</font>**
  - `**<font style="color:#DF2A3F;">HashSet</font>**`**<font style="color:#DF2A3F;">不是线程安全的</font>**
  - **<font style="color:#DF2A3F;">集合元素可以是</font>**`**<font style="color:#DF2A3F;">null</font>**`
- `**<font style="color:#DF2A3F;">HashSet</font>**`**<font style="color:#DF2A3F;">集合判断两个元素相等的标准</font>**
  - <font style="color:#DF2A3F;">两个对象通过</font>`<font style="color:#DF2A3F;">hashCode()</font>`<font style="color:#DF2A3F;">方法得到的哈希值相等，并且两个对象的</font>`<font style="color:#DF2A3F;">equals()</font>`<font style="color:#DF2A3F;">方法返回值为</font>`<font style="color:#DF2A3F;">true</font>`
- **<font style="color:#DF2A3F;">对于存放在</font>**`**<font style="color:#DF2A3F;">Set</font>**`**<font style="color:#DF2A3F;">容器中的对象，对应的类一定要重写</font>**`**<font style="color:#DF2A3F;">hashCode()</font>**`**<font style="color:#DF2A3F;">和</font>**`**<font style="color:#DF2A3F;">equals(Object obj)</font>**`**<font style="color:#DF2A3F;">方法，以实现对象相等规则，相等的对象必须具有相等的散列码</font>**
- `**HashSet**`**集合中元素的无序性，不等同于随机，这里的无序性与元素的添加位置有关**
  - **<font style="color:#DF2A3F;">具体来说</font>**：<font style="color:#DF2A3F;">在添加每一个元素到数组中时，具体的存储位置是由元素的</font>`<font style="color:#DF2A3F;">hashCode()</font>`<font style="color:#DF2A3F;">调用后返回的</font>`<font style="color:#DF2A3F;">hash</font>`<font style="color:#DF2A3F;">值决定的，导致在数组中每个元素不是依次紧密存放的，表现出一定的无序性</font>

##### `HashSet`中添加元素的过程

- **第**`**1**`**步**：当向`HashSet`集合中存入一个元素时，`HashSet`会调用该对象的`hashCode()`方法得到该对象的`hashCode`值，然后根据`hashCode`值，通过`某个散列函数`决定该对象在`HashSet`底层数组中的存储位置
- **第**`**2**`**步**：如果要在数组中存储的位置上没有元素，则直接添加成功
- **第**`**3**`**步**：如果要在数组中存储的位置上有元素，则继续比较：
  - 如果两个元素的`hashCode()`值不相等，则添加成功
  - 如果两个元素的`hashCode()`值相等，则会继续调用`equals()`方法：
    - 如果`equals()`方法结果为`false`，则添加成功
    - 如果`equals()`方法结果为`true`，则添加失败
- **<font style="color:#DF2A3F;">如果第</font>**`**<font style="color:#DF2A3F;">2</font>**`**<font style="color:#DF2A3F;">步添加成功，元素会保存在底层数组中</font>**
- **<font style="color:#DF2A3F;">如果第</font>**`**<font style="color:#DF2A3F;">3</font>**`**<font style="color:#DF2A3F;">步添加成功，由于该底层数组的位置已经有元素了，则会通过链表的方式继续链接存储</font>**

举例：

```java
import java.util.Objects;

public class MyDate {
    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    // equals重写
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyDate myDate = (MyDate) o;
        return year == myDate.year &&
                month == myDate.month &&
                day == myDate.day;
    }

    // hashCode重写
    @Override
    public int hashCode() {
        return Objects.hash(year, month, day);
    }

    @Override
    public String toString() {
        return "MyDate{" +
                "year=" + year +
                ", month=" + month +
                ", day=" + day +
                '}';
    }
}
```

```java
import org.junit.Test;
import java.util.HashSet;

public class TestHashSet {

    @Test
    public void test01(){
        HashSet set = new HashSet();
        set.add("张三");
        set.add("张三");
        set.add("李四");
        set.add("王五");
        set.add("王五");
        set.add("赵六");

        //不允许重复，无序
        System.out.println("set = " + set);
    }

    @Test
    public void test02(){
        HashSet set = new HashSet();
        set.add(new MyDate(2021,1,1));
        set.add(new MyDate(2021,1,1));
        set.add(new MyDate(2022,2,4));
        set.add(new MyDate(2022,2,4));

        //不允许重复，无序
        System.out.println("set = " + set);
    }
}
```

##### <font style="color:#DF2A3F;">重写</font>`<font style="color:#DF2A3F;">hashCode()</font>`<font style="color:#DF2A3F;">方法的基本原则</font>

- 在程序运行时，同一个对象多次调用`hashCode()`方法应该返回相同的值
- 两个对象`equals()`方法比较返回`true`时，这两个对象的`hashCode()`方法的返回值也应相等
- 对象中用作`equals()`方法比较的`Field`，都应该用来计算`hashCode`值

**注意**：**<font style="color:#DF2A3F;">如果两个元素的</font>**`**<font style="color:#DF2A3F;">equals()</font>**`**<font style="color:#DF2A3F;">方法返回</font>**`**<font style="color:#DF2A3F;">true</font>**`**<font style="color:#DF2A3F;">，但它们的</font>**`**<font style="color:#DF2A3F;">hashCode()</font>**`**<font style="color:#DF2A3F;">返回值不相等，</font>**`**<font style="color:#DF2A3F;">hashSet</font>**`**<font style="color:#DF2A3F;"> 将会把它们存储在不同的位置，但依然可以添加成功</font>**

##### <font style="color:#DF2A3F;">重写</font>`<font style="color:#DF2A3F;">equals()</font>`<font style="color:#DF2A3F;">方法的基本原则</font>

- 重写`equals`方法的时候一般需要同时复写`hashCode`方法，通常参与计算`hashCode`的对象的属性也应该参与到`equals()`中进行计算
- **推荐**：开发中直接调用`Eclipse/IDEA`里的快捷键自动重写`equals()`和`hashCode()`方法即可

**<font style="color:#DF2A3F;">为什么用</font>**`**<font style="color:#DF2A3F;">Eclipse/IDEA</font>**`**<font style="color:#DF2A3F;">复写</font>**`**<font style="color:#DF2A3F;">hashCode</font>**`**<font style="color:#DF2A3F;">方法，有</font>**`**<font style="color:#DF2A3F;">31</font>**`**<font style="color:#DF2A3F;">这个数字？</font>**

> **首先**，选择系数的时候要选择尽量大的系数。因为如果计算出来的`hash`地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）
>
> **其次**，`31`只占用`5bits`,相乘造成数据溢出的概率较小。
>
> **再次**，`31`可以 由`i*31== (i<<5)-1`来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）
>
> **最后**，`31`是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有`1`来整除！(减少冲突)

##### 练习

- 练习`1`：在`List`内去除重复数字值，要求尽量简单

```java
public static List duplicateList(List list) {
      HashSet set = new HashSet();
      set.addAll(list);
      return new ArrayList(set);
}

public static void main(String[] args) {
      List list = new ArrayList();
      list.add(new Integer(1));
      list.add(new Integer(2));
      list.add(new Integer(2));
      list.add(new Integer(4));
      list.add(new Integer(4));
      List list2 = duplicateList(list);
      for (Object integer : list2) {
          System.out.println(integer);
      }
}
```

- 练习`2`：获取随机数
  - 编写程序，获取`10`个`1`至`20`的随机数，要求随机数不重复，并把最终的随机数输出到控制台

```java
public class RandomValueTest {
    public static void main(String[] args) {
        // 创建集合对象
        HashSet hs = new HashSet();

        Random r = new Random();
        while (hs.size() < 10) {
            // 生成1到20的随机数
            int num = r.nextInt(20) + 1;
            hs.add(num);
        }

        // 遍历集合
        for (Integer integer : hs) {
            // 打印每一个元素
            System.out.println(integer);
        }
    }
}
```

- 练习`3`：去重
  - 用`Scanner`从键盘读取一行输入，去掉重复字符，打印不同的字符。比如：`aaaabbbcccddd`

```java
public class DistinctTest {
    public static void main(String[] args) {
        // 创建键盘录入对象
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一行字符串:");

        // 将键盘录入的字符串存储在line中
        String line = sc.nextLine();
        // 将字符串转换成字符数组
        char[] arr = line.toCharArray();

        // 创建HashSet集合对象
        HashSet hs = new HashSet();

        // 遍历字符数组
        for (Object c : arr) {
            // 将字符数组中的字符添加到集合中
            hs.add(c);
        }

        // 遍历集合
        for (Object ch : hs) {
            System.out.print(ch);
        }
    }
}
```

**<font style="color:#DF2A3F;">练习</font>**`**<font style="color:#DF2A3F;">4</font>**`**<font style="color:#DF2A3F;">：面试题</font>**

```java
HashSet set = new HashSet();

Person p1 = new Person(1001,"AA");
Person p2 = new Person(1002,"BB");

set.add(p1);
set.add(p2);

p1.name = "CC";
set.remove(p1);
System.out.println(set);

set.add(new Person(1001,"CC"));
System.out.println(set);

set.add(new Person(1001,"AA"));
System.out.println(set);

//其中Person类中重写了hashCode()和equal()方法
```

#### `Set`实现类`LinkedHashSet`

- `LinkedHashSet`是`HashSet`的子类，不允许集合元素重复
- `LinkedHashSet`根据元素的`hashCode`值来决定元素的存储位置，但它同时**使用双向链表维护元素的次序，这使得元素看起来是以添加顺序保存的**
- `LinkedHashSet`插入性能略低于`HashSet`，但**在迭代访问**`**Set**`**里的全部元素时有很好的性能**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733041634463-a8e1fb1c-dfc3-4a31-bae6-d2baccd93fb6.png)

举例：

```java
import org.junit.Test;
import java.util.LinkedHashSet;

public class TestLinkedHashSet {
    @Test
    public void test01(){
        LinkedHashSet set = new LinkedHashSet();
        set.add("张三");
        set.add("张三");
        set.add("李四");
        set.add("王五");
        set.add("王五");
        set.add("赵六");

        //不允许重复，体现添加顺序
        System.out.println("set = " + set);
    }
}
```

#### `Set`实现类`TreeSet`

##### `TreeSet`概述

- `TreeSet`是`SortedSet`接口的实现类，`**TreeSet**`**可以按照添加元素的指定属性的大小顺序遍历**
- `**<font style="color:#DF2A3F;">TreeSet</font>**`**<font style="color:#DF2A3F;">底层使用红黑树结构存储数据</font>**
- **新增的方法如下**
  - `Comparator comparator()`
  - `Object first()`
  - `Object last()`
  - `Object lower(Object e)`
  - `Object higher(Object e)`
  - `SortedSet subSet(fromElement, toElement)`
  - `SortedSet headSet(toElement)`
  - `SortedSet tailSet(fromElement)`
- `TreeSet`**特点**：<font style="color:#DF2A3F;">不允许重复、实现排序（自然排序或定制排序）</font>
- `TreeSet`**两种排序方法**：**自然排序**、**定制排序**，<font style="color:#DF2A3F;">默认情况下</font>`<font style="color:#DF2A3F;">TreeSet</font>`<font style="color:#DF2A3F;">采用自然排序</font>
  - **<font style="color:#DF2A3F;">自然排序</font>**：`<font style="color:#DF2A3F;">TreeSet</font>`<font style="color:#DF2A3F;">会调用集合元素的</font>`<font style="color:#DF2A3F;">compareTo(Object obj)</font>`<font style="color:#DF2A3F;">方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列</font>
    - **如果试图把一个对象添加到**`**TreeSet**`**时，该对象的类必须实现**`**Comparable**`**接口**
    - 实现`Comparable`的类必须实现`compareTo(Object obj)`方法，两个对象通过`compareTo(Object obj)`方法的返回值来比较大小
  - **<font style="color:#DF2A3F;">定制排序</font>**：如果元素所属的类没有实现`Comparable`接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。**<font style="color:#DF2A3F;">定制排序通过</font>**`**<font style="color:#DF2A3F;">Comparator</font>**`**<font style="color:#DF2A3F;">接口来实现，需要重写</font>**`**<font style="color:#DF2A3F;">compare(T o1,T o2)</font>**`**<font style="color:#DF2A3F;">方法</font>**
    - 利用`int compare(T o1,T o2)`方法，比较`o1`和`o2`的大小：如果方法返回`正整数`，则表示`o1`大于`o2`；如果返回`0`，表示相等；返回`负整数`，表示`o1`小于`o2`
    - **要实现定制排序需要将实现**`**Comparator**`**接口的实例作为形参传递给**`**TreeSet**`**的构造器**
- 因为只有相同类的两个实例才会比较大小，所以<font style="color:#DF2A3F;">向</font>`<font style="color:#DF2A3F;">TreeSet</font>`<font style="color:#DF2A3F;">中添加的应该是同一个类的对象</font>
- 对于`TreeSet`集合而言，**它判断两个对象是否相等的唯一标准是**：**<font style="color:#DF2A3F;">两个对象通过</font>**`**<font style="color:#DF2A3F;">compareTo(Object obj)</font>**`**<font style="color:#DF2A3F;">或</font>**`**<font style="color:#DF2A3F;">compare(Object o1,Object o2)</font>**`**<font style="color:#DF2A3F;">方法比较返回值，返回值为</font>**`**<font style="color:#DF2A3F;">0</font>**`**<font style="color:#DF2A3F;">，则两个对象相等</font>**

##### 举例

举例`1`：**自然排序**

```java
import org.junit.Test;
import java.util.Iterator;
import java.util.TreeSet;

public class TreeSetTest {
    /*
    * 自然排序：针对String类的对象
    * */
    @Test
    public void test1(){
        TreeSet set = new TreeSet();

        set.add("MM");
        set.add("CC");
        set.add("AA");
        set.add("DD");
        set.add("ZZ");

        //set.add(123);  //报ClassCastException的异常

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }

    /*
    * 自然排序：针对User类的对象
    * */
    @Test
    public void test2(){
        TreeSet set = new TreeSet();

        set.add(new User("Tom",12));
        set.add(new User("Rose",23));
        set.add(new User("Jerry",2));
        set.add(new User("Eric",18));
        set.add(new User("Tommy",44));
        set.add(new User("Jim",23));
        set.add(new User("Maria",18));
        //set.add("Tom");

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }

        System.out.println(set.contains(new User("Jack", 23))); //true
    }
}
```

其中，`**User**`类定义如下：

```java
public class User implements Comparable{
    String name;
    int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    /*
    举例：按照age从小到大的顺序排列，如果age相同，则按照name从大到小的顺序排列
    * */
    public int compareTo(Object o) {
        if(this == o){
            return 0;
        }

        if(o instanceof User){
            User user = (User)o;
            int value = this.age - user.age;
            if(value != 0){
                return value;
            }
            return -this.name.compareTo(user.name);
        }
        throw new RuntimeException("输入的类型不匹配");
    }
}
```

举例`2`：**定制排序**

```java
/*
 * 定制排序
 * */
@Test
public void test3(){
    //按照User的姓名的从小到大的顺序排列
    Comparator comparator = new Comparator() {
        @Override
        public int compare(Object o1, Object o2) {
            if(o1 instanceof User && o2 instanceof User){
                User u1 = (User)o1;
                User u2 = (User)o2;

                return u1.name.compareTo(u2.name);
            }
            throw new RuntimeException("输入的类型不匹配");
        }
    };

    TreeSet set = new TreeSet(comparator);

    set.add(new User("Tom",12));
    set.add(new User("Rose",23));
    set.add(new User("Jerry",2));
    set.add(new User("Eric",18));
    set.add(new User("Tommy",44));
    set.add(new User("Jim",23));
    set.add(new User("Maria",18));
    //set.add(new User("Maria",28));

    Iterator iterator = set.iterator();
    while(iterator.hasNext()){
        System.out.println(iterator.next());
    }
}
```

##### 练习

练习`1`：在一个`List`集合中存储了多个无大小顺序并且有重复的字符串，定义一个方法，让其有序(从小到大排序)，并且不能去除重复元素。提示：考查`ArrayList`、`TreeSet`

```java
public class SortTest {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("ccc");
        list.add("ccc");
        list.add("aaa");
        list.add("aaa");
        list.add("bbb");
        list.add("ddd");
        list.add("ddd");
        sort(list);
        System.out.println(list);
    }

    /*
     * 对集合中的元素排序,并保留重复
     */
    public static void sort(List list) {
        TreeSet ts = new TreeSet(new Comparator() {
            // 重写compare方法
            @Override
            public int compare(Object o1, Object o2) {
                String s1 = (String)o1;
                String s2 = (String)o2;
                // 比较内容
                int num = s1.compareTo(s2);
                // 如果内容一样返回一个不为0的数字即可
                return num == 0 ? 1 : num;
            }
        });

        // 将list集合中的所有元素添加到ts中
        ts.addAll(list);
        // 清空list
        list.clear();
        // 将ts中排序并保留重复的结果在添加到list中
        list.addAll(ts);
    }
}
```

### 6. `Map`接口

现实生活与开发中，我们常会看到这样的一类集合：用户`ID`与账户信息、学生姓名与考试成绩、`IP`地址与主机名等，这种对应关系就称作**映射**。`Java`提供了专门的集合框架用来存储这种映射关系的对象，即`**java.util.Map**`接口。

##### `Map`接口概述

- `Map`与`Collection`并列存在，用于保存具有映射关系的数据：`key-value`
  - `Collection`集合称为**单列集合**，元素是孤立存在的
  - `Map`集合称为**双列集合**，元素是成对存在的
- `<font style="color:#DF2A3F;">Map</font>`<font style="color:#DF2A3F;">中的</font>`<font style="color:#DF2A3F;">key</font>`<font style="color:#DF2A3F;">和</font>`<font style="color:#DF2A3F;">value</font>`<font style="color:#DF2A3F;">都可以是任何引用类型的数据，但常用</font>`<font style="color:#DF2A3F;">String</font>`<font style="color:#DF2A3F;">类作为</font>`<font style="color:#DF2A3F;">Map</font>`<font style="color:#DF2A3F;">的</font>`<font style="color:#DF2A3F;">key</font>`
- `Map`接口的常用实现类：`HashMap``LinkedHashMap``TreeMap`和`Properties`。`HashMap`是使用频率最高的实现类

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733041653612-f5864558-2e1e-4cae-b2a2-3606eaa6eb77.png)

##### `Map`中`key-value`的特点

这里主要以`**HashMap**`为例说明

`HashMap`中存储的`key`、`value`的特点如下：

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733041661781-93f03e8a-2697-46f6-93b7-b1f3cf2ee65a.png)

- `Map`中的`key`用`Set`来存放，不允许重复，`**<font style="color:#DF2A3F;">Map</font>**`**<font style="color:#DF2A3F;">对象</font>**`**<font style="color:#DF2A3F;">key</font>**`**<font style="color:#DF2A3F;">所对应的类须重写</font>**`**<font style="color:#DF2A3F;">hashCode()</font>**`**<font style="color:#DF2A3F;">和 </font>**`**<font style="color:#DF2A3F;">equals()</font>**`**<font style="color:#DF2A3F;">方法</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733062167329-041f9e4f-49d5-4b5a-8c9a-dd71247864e6.png)

- `key`和`value`之间存在单向一对一关系，指定`key`总能找到唯一、确定的`value`，不同`key`对应的`value`可以重复，`**<font style="color:#DF2A3F;">value</font>**`**<font style="color:#DF2A3F;">所在的类要重写</font>**`**<font style="color:#DF2A3F;">equals()</font>**`**<font style="color:#DF2A3F;">方法</font>**
- `**<font style="color:#DF2A3F;">key</font>**`**<font style="color:#DF2A3F;">和</font>**`**<font style="color:#DF2A3F;">value</font>**`**<font style="color:#DF2A3F;">构成一个</font>**`**<font style="color:#DF2A3F;">entry</font>**`**<font style="color:#DF2A3F;">，所有的</font>**`**<font style="color:#DF2A3F;">entry</font>**`**<font style="color:#DF2A3F;">彼此之间是无序、不可重复的</font>**

##### `Map`接口的常用方法

- **添加、修改操作**
  - `Object put(Object key,Object value)`：将`key-value`添加到(或修改)当前`map`对象中
  - `void putAll(Map m)`：将`m`中的所有`key-value`对存放到当前`map`中
- **删除操作**
  - `Object remove(Object key)`：移除指定`key`的`key-value`对，并返回`value`
  - `void clear()`：清空当前`map`中的所有数据
- **元素查询操作**
  - `Object get(Object key)`：获取指定`key`对应的`value`
  - `boolean containsKey(Object key)`：是否包含指定的`key`
  - `boolean containsValue(Object value)`：是否包含指定的`value`
  - `int size()`：返回`map`中`key-value`对的个数
  - `boolean isEmpty()`：判断当前`map`是否为空
  - `boolean equals(Object obj)`：判断当前`map`和参数对象`obj`是否相等
- **元视图操作方法**
  - `Set keySet()`：返回所有`key`构成的`Set`集合
  - `Collection values()`：返回所有`value`构成的`Collection`集合
  - `Set entrySet()`：返回所有`key-value`对构成的`Set`集合

```java
import java.util.HashMap;

public class TestMapMethod {
    public static void main(String[] args) {

        //创建 map对象
        HashMap map = new HashMap();

        //添加元素到集合
        map.put("黄晓明", "杨颖");
        map.put("李晨", "李小璐");
        map.put("李晨", "范冰冰");
        map.put("邓超", "孙俪");
        System.out.println(map);

        //删除指定的key-value
        System.out.println(map.remove("黄晓明"));
        System.out.println(map);

        //查询指定key对应的value
        System.out.println(map.get("邓超"));
        System.out.println(map.get("黄晓明"));
    }
}
```

```java
public static void main(String[] args) {
    HashMap map = new HashMap();
    map.put("许仙", "白娘子");
    map.put("董永", "七仙女");
    map.put("牛郎", "织女");
    map.put("许仙", "小青");

    System.out.println("所有的key:");
    Set keySet = map.keySet();
    for (Object key : keySet) {
        System.out.println(key);
    }

    System.out.println("所有的value:");
    Collection values = map.values();
    for (Object value : values) {
        System.out.println(value);
    }

    System.out.println("所有的映射关系:");
    Set entrySet = map.entrySet();
    for (Object mapping : entrySet) {
        //System.out.println(entry);
        Map.Entry entry = (Map.Entry) mapping;
        System.out.println(entry.getKey() + "->" + entry.getValue());
    }
}
```

##### `Map`的实现类`HashMap`

`**HashMap**`**概述**

- `HashMap`是`Map`接口使用频率最高的实现类
- `<font style="color:#DF2A3F;">HashMap</font>`<font style="color:#DF2A3F;">是</font>**<font style="color:#DF2A3F;">线程不安全的</font>**<font style="color:#DF2A3F;">，</font>**<font style="color:#DF2A3F;">允许添加</font>**`**<font style="color:#DF2A3F;">null</font>**`**<font style="color:#DF2A3F;">键和</font>**`**<font style="color:#DF2A3F;">null</font>**`**<font style="color:#DF2A3F;">值</font>**
- 存储数据采用的哈希表结构，底层使用`一维数组+单向链表+红黑树`进行`key-value`数据的存储<font style="color:#DF2A3F;">与</font>`<font style="color:#DF2A3F;">HashSet</font>`<font style="color:#DF2A3F;">一样，元素的存取顺序不能保证一致</font>
- `**<font style="color:#DF2A3F;">HashMap</font>**`**<font style="color:#DF2A3F;">判断两个</font>**`**<font style="color:#DF2A3F;">key</font>**`**<font style="color:#DF2A3F;">相等的标准</font>**：两个`key`的`hashCode`值相等，通过`equals()`方法返回 `true`
- `**<font style="color:#DF2A3F;">HashMap</font>**`**<font style="color:#DF2A3F;">判断两个</font>**`**<font style="color:#DF2A3F;">value</font>**`**<font style="color:#DF2A3F;">相等的标准</font>**：两个`value`通过`equals()`方法返回`true`

**练习**

统计字符串中每个字符出现的次数`String str = "aaaabbbcccccccccc";`

```java
public class WordCountTest {
    public static void main(String[] args) {
        String str = "aaaabbbcccccccccc";
         // 将字符串转换成字符数组
        char[] arr = str.toCharArray();
        // 创建双列集合存储键和值
        HashMap map = new HashMap();

        // 遍历字符数组
        for (char c : arr) {
            // 如果不包含这个键
            if (!map.containsKey(c)) {
                // 就将键和值为1添加
                map.put(c, 1);
            } else {
                // 如果包含这个键
                // 就将键和值再加1添加进来
                map.put(c, (int)map.get(c) + 1);
            }
        }

        // 遍历双列集合
        for (Object key : map.keySet()) {
            System.out.println(key + "=" + map.get(key));
        }
    }
}
```

##### `Map`的实现类`LinkedHashMap`

- `LinkedHashMap`是`HashMap`的子类
- <font style="color:#DF2A3F;">存储数据采用的</font>`<font style="color:#DF2A3F;">哈希表结构+链表</font>`<font style="color:#DF2A3F;">结构，在</font>`<font style="color:#DF2A3F;">HashMap</font>`<font style="color:#DF2A3F;">存储结构的基础上，使用了一对</font>**<font style="color:#DF2A3F;">双向链表</font>**<font style="color:#DF2A3F;">来记录添加元素的先后顺序，可以保证遍历元素时，与添加的顺序一致</font>
- **<font style="color:#DF2A3F;">通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写</font>**`**<font style="color:#DF2A3F;">hashCode()</font>**``**<font style="color:#DF2A3F;">equals()</font>**`**<font style="color:#DF2A3F;">方法</font>**

```java
public class TestLinkedHashMap {
    public static void main(String[] args) {

        LinkedHashMap map = new LinkedHashMap();
        map.put("王五", 13000.0);
        map.put("张三", 10000.0);

        //key相同，新的value会覆盖原来的value
        //因为String重写了hashCode和equals方法
        map.put("张三", 12000.0);
        map.put("李四", 14000.0);

        //HashMap支持key和value为null值
        String name = null;
        Double salary = null;
        map.put(name, salary);

        Set entrySet = map.entrySet();
        for (Object obj : entrySet) {
            Map.Entry entry = (Map.Entry)obj;
            System.out.println(entry);
        }
    }
}
```

##### `Map`的实现类`TreeMap`

- `**<font style="color:#DF2A3F;">TreeMap</font>**`**<font style="color:#DF2A3F;">存储</font>**`**<font style="color:#DF2A3F;">key-value</font>**`**<font style="color:#DF2A3F;">对时，需要根据</font>**`**<font style="color:#DF2A3F;">key-value</font>**`**<font style="color:#DF2A3F;">对进行排序，</font>**`**<font style="color:#DF2A3F;">TreeMap</font>**`**<font style="color:#DF2A3F;">可以保证所有的 </font>**`**<font style="color:#DF2A3F;">key-value</font>**`**<font style="color:#DF2A3F;">对处于有序状态</font>**
- `TreeSet`底层使用**红黑树结构**存储数据
- `TreeMap`的`Key`排序
  - **自然排序**：`TreeMap`的所有`Key`必须实现`Comparable`接口，且所有的`Key`应该是同一个类的对象，否则将会抛出`ClasssCastException`
  - **定制排序**：创建`TreeMap`时，构造器传入一个`Comparator`对象，该对象负责对`TreeMap`的所有`key`进行排序，此时不需要`Map`的`Key`实现`Comparable`接口
- `**<font style="color:#DF2A3F;">TreeMap</font>**`**<font style="color:#DF2A3F;">判断两个</font>**`**<font style="color:#DF2A3F;">key</font>**`**<font style="color:#DF2A3F;">相等的标准</font>**：两个`key`通过`compareTo()`**或者**`compare()`返回`0`

```java
public class TestTreeMap {
    /*
    * 自然排序举例
    * */
    @Test
    public void test1(){
        TreeMap map = new TreeMap();
        map.put("CC",45);
        map.put("MM",78);
        map.put("DD",56);
        map.put("GG",89);
        map.put("JJ",99);

        Set entrySet = map.entrySet();
        for(Object entry : entrySet){
            System.out.println(entry);
        }
    }

    /*
    * 定制排序
    *
    * */
    @Test
    public void test2(){
        //按照User的姓名的从小到大的顺序排列

        TreeMap map = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof User && o2 instanceof User){
                    User u1 = (User)o1;
                    User u2 = (User)o2;

                    return u1.name.compareTo(u2.name);
                }
                throw new RuntimeException("输入的类型不匹配");
            }
        });
        map.put(new User("Tom",12),67);
        map.put(new User("Rose",23),"87");
        map.put(new User("Jerry",2),88);
        map.put(new User("Eric",18),45);
        map.put(new User("Tommy",44),77);
        map.put(new User("Jim",23),88);
        map.put(new User("Maria",18),34);

        Set entrySet = map.entrySet();
        for(Object entry : entrySet){
            System.out.println(entry);
        }
    }
}

class User implements Comparable{
    String name;
    int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public User() {
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    /*
    举例：按照age从小到大的顺序排列，如果age相同，则按照name从大到小的顺序排列
    * */
    @Override
    public int compareTo(Object o) {
        if(this == o){
            return 0;
        }

        if(o instanceof User) {
            User user = (User)o;
            int value = this.age - user.age;
            if(value != 0) {
                return value;
            }
            return -this.name.compareTo(user.name);
        }
        throw new RuntimeException("输入的类型不匹配");
    }
}
```

##### `Map`的实现类`Hashtable`

- `Hashtable`是`Map`接口的古老实现类，`JDK1.0`就提供了。不同于`HashMap`，`**<font style="color:#DF2A3F;">Hashtable</font>**`**<font style="color:#DF2A3F;">是线程安全的</font>**
- `Hashtable`实现原理和`HashMap`相同，功能相同。底层都使用**哈希表结构（数组+单向链表）**，查询速度快
- 与`HashMap`一样，`**Hashtable**`**也不能保证其中**`**Key-Value**`**对的顺序**
- `Hashtable`判断两个`key`相等、两个`value`相等的标准，与`HashMap`一致
- **<font style="color:#DF2A3F;">与</font>**`**<font style="color:#DF2A3F;">HashMap</font>**`**<font style="color:#DF2A3F;">不同，</font>**`**<font style="color:#DF2A3F;">Hashtable</font>**`**<font style="color:#DF2A3F;">不允许使用</font>**`**<font style="color:#DF2A3F;">null</font>**`**<font style="color:#DF2A3F;">作为</font>**`**<font style="color:#DF2A3F;">key</font>**`**<font style="color:#DF2A3F;">或</font>**`**<font style="color:#DF2A3F;">value</font>**`

##### 面试题：`Hashtable`和`HashMap`的区别

- `HashMap`：底层是一个哈希表（`jdk7`：数组+链表；`jdk8`：数组+链表+红黑树），是**<font style="color:#DF2A3F;">一个线程不安全的集合，执行效率高</font>**
- `Hashtable`：底层也是一个哈希表（数组+链表），是**<font style="color:#DF2A3F;">一个线程安全的集合，执行效率低</font>**
- `HashMap`集合：可以存储`null`的键、`null`的值
- `Hashtable`集合：不能存储`null`的键、`null`的值
- `Hashtable`和`Vector`集合一样，在`jdk1.2`版本之后被更先进的集合`HashMap``ArrayList`取代了
- `HashMap`是`Map`的主要实现类，`Hashtable`是`Map`的古老实现类
- `Hashtable`的子类`Properties`（配置文件）依然活跃在历史舞台
- `**<font style="color:#DF2A3F;">Properties</font>**`**<font style="color:#DF2A3F;">集合是一个唯一和</font>**`**<font style="color:#DF2A3F;">IO</font>**`**<font style="color:#DF2A3F;">流相结合的集合</font>**

##### `Map`的实现类`Properties`

- `Properties`类是`Hashtable`的子类，该对象**<font style="color:#DF2A3F;">用于处理属性文件</font>**
- **<font style="color:#DF2A3F;">由于属性文件里的</font>**`**<font style="color:#DF2A3F;">key</font>**``**<font style="color:#DF2A3F;">value</font>**`**<font style="color:#DF2A3F;">都是字符串，所以</font>**`**<font style="color:#DF2A3F;">Properties</font>**`**<font style="color:#DF2A3F;">要求</font>**`**<font style="color:#DF2A3F;">key</font>**`**<font style="color:#DF2A3F;"></font>**`**<font style="color:#DF2A3F;">value</font>**`**<font style="color:#DF2A3F;">都是字符串类型</font>**
- 存取数据建议用`setProperty(String key,String value)``getProperty(String key)`方法

```java
@Test
public void test01() {
    Properties properties = System.getProperties();
    //当前源文件字符编码
    String fileEncoding = properties.getProperty("file.encoding");
    System.out.println("fileEncoding = " + fileEncoding);
}

@Test
public void test02() {
    Properties properties = new Properties();
    properties.setProperty("user","songhk");
    properties.setProperty("password","123456");
    System.out.println(properties);
}

@Test
public void test03() throws IOException {
    Properties pros = new Properties();
    pros.load(new FileInputStream("jdbc.properties"));
    String user = pros.getProperty("user");
    System.out.println(user);
}
```

### 7. `Collections`工具类

**<font style="color:#DF2A3F;">操作数组的工具类：</font>**`**<font style="color:#DF2A3F;">Arrays</font>**`**<font style="color:#DF2A3F;">，</font>**`**<font style="color:#DF2A3F;">Collections</font>**`**<font style="color:#DF2A3F;">是一个操作</font>**`**<font style="color:#DF2A3F;">Set</font>**``**<font style="color:#DF2A3F;">List</font>**`**<font style="color:#DF2A3F;">和</font>**`**<font style="color:#DF2A3F;">Map</font>**`**<font style="color:#DF2A3F;">等集合的工具类</font>**

#### 常用方法

`Collections`中提供了一系列**静态方法**对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法

**排序操作**

- `reverse(List)`：**反转**`List`中元素的顺序
- `shuffle(List)`：对`List`集合元素进行**随机排序**
- `sort(List)`：根据元素的**自然顺序**对指定`List`集合元素按**升序排序**
- `sort(List，Comparator)`：根据**指定的**`**Comparator**`**对**`**List**`**集合元素进行排序**
- `swap(List，int， int)`：将指定`list`集合中的`i`处元素和`j`处**元素进行交换**

**查找**

- `Object max(Collection)`：根据元素的**自然顺序**，返回给定集合中的**最大元素**
- `Object max(Collection，Comparator)`：根据`Comparator`指定的顺序，返回给定集合中的**最大元素**
- `Object min(Collection)`：根据元素的**自然顺序**，返回给定集合中的**最小元素**
- `Object min(Collection，Comparator)`：根据`Comparator`指定的顺序，返回给定集合中的**最小元素**
- `int binarySearch(List list,T key)`：在`List`集合中**查找某个元素的下标**，但是`List`的元素必须是`T`或`T`的子类对象，而且**<font style="color:#DF2A3F;">必须是可比较大小的，即支持自然排序的</font>**<font style="color:#DF2A3F;">。</font>**<font style="color:#DF2A3F;">而且集合也事先必须是有序的，否则结果不确定。</font>**
- `int binarySearch(List list,T key,Comparator c)`：在`List`集合中查找某个元素的下标，但是`List`的元素必须是`T`或`T`的子类对象，而且**<font style="color:#DF2A3F;">集合也事先必须是按照</font>**`**<font style="color:#DF2A3F;">c</font>**`**<font style="color:#DF2A3F;">比较器规则进行排序过的，否则结果不确定</font>**
- `int frequency(Collection c，Object o)`：**返回指定集合中指定元素的出现次数**

**复制、替换**

- `void copy(List dest,List src)`：将`src`中的**内容复制**到`dest`中
- `boolean replaceAll(List list，Object oldVal，Object newVal)`：**<font style="color:#DF2A3F;">用新值替换</font>**`**<font style="color:#DF2A3F;">List</font>**`**<font style="color:#DF2A3F;">对象的所有旧值</font>**
- 提供了多个`unmodifiableXxx()`方法：返回指定`Xxx`的不可修改的视图

**添加**

- `boolean addAll(Collection c,T... elements)`：将所有指定元素添加到指定`collection`

**同步**

- `Collections`类中提供了多个`synchronizedXxx()`方法：**<font style="color:#DF2A3F;">方法可将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</font>**

#### 举例

```java
import org.junit.Test;
import java.text.Collator;
import java.util.*;

public class TestCollections {
    @Test
    public void test01(){
        /*
        public static <T> boolean addAll(Collection<? super T> c,T... elements)
        将所有指定元素添加到指定 collection 中。Collection的集合的元素类型必须>=T类型
        */
        Collection<Object> coll = new ArrayList<>();
        Collections.addAll(coll, "hello","java");
        Collections.addAll(coll, 1,2,3,4);

        Collection<String> coll2 = new ArrayList<>();
        Collections.addAll(coll2, "hello","java");
        //Collections.addAll(coll2, 1,2,3,4);//String和Integer之间没有父子类关系
    }

    @Test
    public void test02(){
        /*
        * public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
        * 在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序
        *
        *  public static <T> T max(Collection<? extends T> coll,Comparator<? super T> comp)
        *  在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者
        *
        */
        List<Man> list = new ArrayList<>();
        list.add(new Man("张三",23));
        list.add(new Man("李四",24));
        list.add(new Man("王五",25));

        /*
         * Man max = Collections.max(list);//要求Man实现Comparable接口，或者父类实现
         * System.out.println(max);
         */

        Man max = Collections.max(list, new Comparator<Man>() {
            @Override
            public int compare(Man o1, Man o2) {
                return o2.getAge()-o2.getAge();
            }
        });
        System.out.println(max);
    }

    @Test
    public void test03(){
        /*
         * public static void reverse(List<?> list)
         * 反转指定列表List中元素的顺序。
         */
        List<String> list = new ArrayList<>();
        Collections.addAll(list,"hello","java","world");
        System.out.println(list);
        Collections.reverse(list);
        System.out.println(list);
    }

    @Test
    public void test04(){
        /* public static void shuffle(List<?> list)
         * List 集合元素进行随机排序，类似洗牌，打乱顺序
         */
        List<String> list = new ArrayList<>();
        Collections.addAll(list,"hello","java","world");

        Collections.shuffle(list);
        System.out.println(list);
    }

    @Test
    public void test05() {
        /* public static <T extends Comparable<? super T>> void sort(List<T> list)
         * 根据元素的自然顺序对指定 List 集合元素按升序排序
         * public static <T> void sort(List<T> list,Comparator<? super T> c)
         * 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
         */
        List<Man> list = new ArrayList<>();
        list.add(new Man("张三",23));
        list.add(new Man("李四",24));
        list.add(new Man("王五",25));
        Collections.sort(list);
        System.out.println(list);
        Collections.sort(list, new Comparator<Man>() {
            @Override
            public int compare(Man o1, Man o2) {
                return Collator.getInstance(Locale.CHINA).compare(o1.getName(),o2.getName());
            }
        });
        System.out.println(list);
    }

    @Test
    public void test06(){
        /* public static void swap(List<?> list,int i,int j)
         * 将指定 list 集合中的 i 处元素和 j 处元素进行交换
         */
        List<String> list = new ArrayList<>();
        Collections.addAll(list,"hello","java","world");

        Collections.swap(list,0,2);
        System.out.println(list);
    }

    @Test
    public void test07(){
        /* public static int frequency(Collection<?> c,Object o)
         * 返回指定集合中指定元素的出现次数
         */
        List<String> list = new ArrayList<>();
        Collections.addAll(list,"hello","java","world","hello","hello");
        int count = Collections.frequency(list, "hello");
        System.out.println("count = " + count);
    }

    @Test
    public void test08(){
        /* public static <T> void copy(List<? super T> dest,List<? extends T> src)
         * 将src中的内容复制到dest中
         */
        List<Integer> list = new ArrayList<>();
        for(int i=1; i<=5; i++){//1-5
            list.add(i);
        }

        List<Integer> list2 = new ArrayList<>();
        for(int i=11; i<=13; i++){//11-13
            list2.add(i);
        }
        Collections.copy(list, list2);
        System.out.println(list);
        List<Integer> list3 = new ArrayList<>();
        for(int i=11; i<=20; i++){//11-20
            list3.add(i);
        }
        //java.lang.IndexOutOfBoundsException: Source does not fit in dest
        //Collections.copy(list, list3);
        //System.out.println(list);
    }

    @Test
    public void test09(){
        /*public static <T> boolean replaceAll(List<T> list，T oldVal，T newVal)
         * 使用新值替换 List 对象的所有旧值
         */
        List<String> list = new ArrayList<>();
        Collections.addAll(list,"hello","java","world","hello","hello");
        Collections.replaceAll(list, "hello","song");
        System.out.println(list);
    }
}
```
