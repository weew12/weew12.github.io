---
title: 2 变量与运算符
createTime: 2025/08/22 22:41:51
permalink: /language/java/k3nmchta/
---
## 关键字、保留字、标识符、注释

### 关键字

被 Java 语言赋予特殊含义作专门用途的字符串，如：`class`、`public`、`static`、`void`等，这些单词已经被 Java 定义好了。

关键字一共50个，其中`const`、`goto`是保留字。`true`、`false`、`null`不在其中，看起来是关键字其实是字面量，表示特殊的布尔值和空值。

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398004700-3753e032-817c-48c1-99d4-19f019c4ccd0.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398009183-5f3bf02b-714c-4996-8caa-4c934afd4ec4.png)

### 关键字(扩展)

**1 abstract**

用于声明抽象类，以及抽象方法。

```java
    abstract class Animal {
        abstract void makeSound();

        public void sleep() {
            System.out.println("The animal is sleeping.");
        }
    }

    class Dog extends Animal {
        void makeSound() {
            System.out.println("The dog barks.");
        }
    }
```

**2 boolean**

Java 中的一种基本数据类型，表示布尔值，即真（`true`）或假（`false`）。`boolean` 数据类型常用于判断条件、循环控制和逻辑运算等场景。

```java
    boolean isStudent = true;

    if (isStudent) {
        System.out.println("This person is a student.");
    } else {
        System.out.println("This person is not a student.");
    }
```

**3 break**

用于跳出循环结构（如 `for`、`while` 和 `do-while` 循环）或 `switch` 语句。当遇到 `break` 语句时，程序将立即跳出当前循环或 `switch` 语句，继续执行紧跟在循环或 `switch` 语句后面的代码。

```java
    for (int i = 0; i < 10; i++) {
        if (i == 5) {
            break;
        }
        System.out.println("i: " + i);
    }
    System.out.println("Loop ended.");
```

**4 byte**

用于表示一个 `8` 位（`1` 字节）有符号整数。它的值范围是 `-128（-2^7）`到 `127（2^7 - 1）`。

由于 `byte` 类型占用的空间较小，它通常用于处理大量的数据，如文件读写、网络传输等场景，以节省内存空间。

```java
    byte minByte = -128;
    byte maxByte = 127;
```

**5 case**

通常与 `switch` 语句一起使用。`switch` 语句允许根据某个变量的值来选择执行不同的代码块。在 `switch` 语句中，`case` 用于标识每个可能的值和对应的代码块。

**6 catch**

用于捕获 `try` 语句中的异常。在 `try` 块中可能会抛出异常，而在 `catch` 块中可以捕获这些异常并进行处理。`catch` 块可以有多个，每个 `catch` 块可以捕获特定类型的异常。在 `catch` 块中，可以根据需要进行异常处理，例如输出错误信息、进行日志记录、恢复程序状态等。

```java
    try {
        int num = Integer.parseInt("abc");
    } catch (NumberFormatException e) {
        System.out.println("Invalid number format");
    }
```

**7 char**

用于声明一个字符类型的变量。`char` 类型的变量可以存储任意的 Unicode 字符，可以使用单引号将字符括起来来表示。

```java
    char c = 'A';
```

**8 class**

用于声明一个类。类是一种用户自定义的数据类型，用于封装数据和方法。类可以包含属性（变量）和方法（函数），用于描述对象的特征和行为。

```java
    public class Person {
        private String name;
        private int age;
    
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        public void sayHello() {
            System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
        }
    }
```

**9 continue**

用于继续下一个循环，可以在指定条件下跳过其余代码。

```java
    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            continue;
        }
        System.out.println(i);
    }
```

**10 default**

用于指定 switch 语句中除去 `case` 条件之外的默认代码块。

**11 do**

通常和 `while` 关键字配合使用，`do` 后紧跟循环体。

```java
    int i = 1;
    do {
        System.out.println(i);
        i++;
    } while (i <= 10);
```

**12 double**

用于声明一个双精度浮点类型的变量。

**13 else**

用于指示 `if` 语句中的备用分支。

```java
    int score = 75;
    if (score >= 60) {
        System.out.println("及格了");
    } else {
        System.out.println("挂科了");
    }
```

**14 enum**

用于定义一组固定的常量（枚举）。

```java
    public enum PlayerType {
        TENNIS,
        FOOTBALL,
        BASKETBALL
    }
```

**15 extends**

用于指示一个类是从另一个类或接口继承的。在 Java 中，类可以继承另一个类的属性和方法，从而实现代码的复用和扩展。被继承的类称为父类或超类，继承的类称为子类或派生类。

```java
    class Animal {
        public void eat() {
            System.out.println("动物正在吃东西");
        }
    }
    
    class Dog extends Animal {
        public void bark() {
            System.out.println("狗在汪汪叫");
        }
    }
    
    public class ExtendsDemo {
        public static void main(String[] args) {
            Dog dog = new Dog();
            dog.eat();
            dog.bark();
        }
    }
```

**16 final**

用于表示某个变量、方法或类是最终的，不能被修改或继承。

`final` **变量**：表示一个常量，一旦被赋值，其值就不能再被修改。这在声明不可变的值时非常有用。

```java
    final double PI = 3.14159265359;
```

`final` **方法**：表示一个不能被子类重写的方法。这在设计类时，确保某个方法的实现不会被子类修改时非常有用。

```java
    class Animal {
        final void makeSound() {
            System.out.println("动物发出声音.");
        }
    }
    
    class Dog extends Animal {
        // 错误: 无法覆盖来自 Animal 的 final 方法
        // void makeSound() {
        //     System.out.println("狗吠叫.");
        // }
    }
    
    public class Main {
        public static void main(String[] args) {
            Dog dog = new Dog();
            dog.makeSound();
        }
    }
```

`final` **类**：表示一个不能被继承的类。这在设计类时，确保其不会被其他类继承时非常有用。String 类就是 final 的。

```java
    final class Animal {
        void makeSound() {
            System.out.println("动物发出声音.");
        }
    }
    
    // 错误: 类型 Dog 无法继承 final 类 Animal
    // class Dog extends Animal {
    //     void makeSound() {
    //         System.out.println("狗吠叫.");
    //     }
    // }
    
    public class Main {
        public static void main(String[] args) {
            Animal animal = new Animal();
            animal.makeSound();
        }
    }
```

**17 finally**

和 `try-catch` 配合使用，表示无论是否处理异常，总是执行 `finally` 块中的代码。

```java
    try {
        int x = 10 / 0;  // 抛出异常
    } catch (Exception e) {
        System.out.println("发生了异常：" + e.getMessage());
    } finally {
        System.out.println("finally 块被执行");
    }
```

**18 float**

表示单精度浮点数。

```java
    float f1 = 3.14f;   // 注意要在数字后面加上 f 表示这是一个 float 类型
    float f2 = 1.23e-4f;   // 科学计数法表示小数
```

在 Java 中，浮点数默认是 `double` 类型，如果要使用 `float` 类型的数据，需要在数字后面加上一个 `f` 或者 `F`，表示这是一个 `float` 类型的字面量。另外，也可以使用科学计数法表示浮点数，例如 `1.23e-4` 表示 `0.000123`。

**19 for**

用于声明一个 `for` 循环，如果循环次数是固定的，建议使用 `for` 循环。

```java
    int[] arr = {1, 2, 3, 4, 5};
    for (int i = 0; i < arr.length; i++) {
        System.out.println("arr[" + i + "] = " + arr[i]);
    }
```

**20 if**

用于指定条件，如果条件为真，则执行对应代码。如果条件为假，则执行 else 分支的代码。

```java
    int n = -3;
    if (n > 0) {
        System.out.println(n + " 是正数");
    } else if (n < 0) {
        System.out.println(n + " 是负数");
    } else {
        System.out.println(n + " 是零");
    }
```

**21 implements**

用于实现接口。下面是一个实现了 `Runnable` 接口的类的示例：

```java
    public class MyThread implements Runnable {
        public void run() {
            // 线程执行的代码
        }
    }
```

**22 import**

用于导入对应的类或者接口。例如，如果要使用 Java 标准库中的 `ArrayList` 类，可以这样写：

```java
    import java.util.ArrayList;
```

**23 instanceof**

用于判断对象是否属于某个类型（`class`）或其子类的实例。

例如，假设有一个 `Person` 类和一个 `Student` 类，`Student` 类继承自 `Person` 类，可以使用 `instanceof` 运算符来判断一个对象是否为 `Person` 类或其子类的实例：

```java
    Person p = new Student();
    if (p instanceof Person) {
        System.out.println("p is an instance of Person");
    }
    if (p instanceof Student) {
        System.out.println("p is an instance of Student");
    }
```

**24 int**

用于表示整数值。

```java
    int x;           // 声明一个 int 类型的变量 x
    x = 10;          // 将整数值 10 赋给变量 x
    int y = 20;     // 声明并初始化一个 int 类型的变量 y，赋值为整数值 20
```

**25 interface**

用于声明接口。会定义一组方法的签名（即方法名、参数列表和返回值类型），但没有方法体。其他类可以实现接口，并提供方法的具体实现。

```java
    public interface MyInterface {
        void method1();
        int method2(String param);
    }
```

**26 long**

用于表示长整数值。

```java
    long x;           // 声明一个 long 类型的变量 x
    x = 10000000000L; // 将长整数值 10000000000 赋给变量 x，需要在数字后面加上 L 或 l 表示这是一个 long 类型的值
    long y = 20000000000L; // 声明并初始化一个 long 类型的变量 y，赋值为长整数值 20000000000
```

**27 native**

用于声明一个本地方法，本地方法是指在 Java 代码中声明但在本地代码（通常是 `C` 或 `C++` 代码）中实现的方法，它通常用于与操作系统或其他本地库进行交互。

```java
    public native void nativeMethod();
```

**28 new**

用于创建一个新的对象。以下是使用 `new` 关键字创建对象实例的基本语法：

```java
    ClassName obj = new ClassName();
```

以下是使用 `new` 关键字创建数组实例的基本语法：

```java
    int[] arr = new int[10];
```

**29 null**

如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 `null`，和空指针异常息息相关。

```java
    String str = null; // 声明一个字符串引用，初始化为 null
    MyClass obj = null; // 声明一个 MyClass 类型的引用，初始化为 null
```

**30 package**

用于声明类所在的包。包是一种组织类的机制，用于将相关的类组织在一起，避免命名冲突。

```java
    package com.example.mypackage;
```

**31 private**

一个访问权限修饰符，表示方法或变量只对当前类可见。

```java
    public class MyClass {
        private int x; // 私有属性 x，只能在当前类的内部访问
    
        private void foo() {
            // 私有方法 foo，只能在当前类的内部调用
        }
    }
```

**32 protected**

一个访问权限修饰符，表示方法或变量对同一包内的类和所有子类可见。

```java
    package com.example.mypackage;
    
    public class MyBaseClass {
        protected int x; // 受保护的属性 x，可以被子类和同一包中的其他类访问
    
        protected void foo() {
            // 受保护的方法 foo，可以被子类和同一包中的其他类调用
        }
    }
    
    package com.example.mypackage;
    
    public class MySubClass extends MyBaseClass {
        public void bar() {
            x = 10; // 可以访问 MyBaseClass 中的受保护属性 x
            foo(); // 可以调用 MyBaseClass 中的受保护方法 foo
        }
    }
```

在这个示例中，`MyBaseClass` 类有一个受保护的属性 `x` 和一个受保护的方法 `foo()`。这些成员可以被子类和同一包中的其他类访问和调用。`MySubClass` 类继承自 `MyBaseClass` 类，并可以访问和修改 `MyBaseClass` 中的受保护成员。

**33 public**

一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。`main()` 方法必须声明为 `public`。

```java
    public class MyClass {
        public int x; // 公有属性 x，可以被任何类访问
    
        public void foo() {
            // 公有方法 foo，可以被任何类调用
        }
    }
```

**34 return**

用于从方法中返回一个值或终止方法的执行。`return` 语句可以将方法的计算结果返回给调用者，或者在方法执行到某个特定条件时提前结束方法。

```java
    public int add(int a, int b) {
        int sum = a + b;
        return sum; // 返回 sum 的值，并结束方法的执行
    }
```

此外，`return` 语句还可以用于提前结束方法的执行。

**35 short**

用于表示短整数，占用 `2` 个字节（`16` 位）的内存空间。

```java
    short x = 10; // 声明一个 short 类型的变量 x，赋值为 10
    short y = 20; // 声明一个 short 类型的变量 y，赋值为 20
```

**36 static**

表示该变量或方法是静态变量或静态方法。

```java
    public class MyClass {
        public static int x; // 静态变量 x，属于类的成员
    
        public static void foo() {
            // 静态方法 foo，属于类的成员
        }
    }
```

**37 strictfp(strict floating-point)**

用于修饰一个类、接口或方法，用于限制浮点数计算的精度和舍入行为。

并不常见，通常用于修饰一个方法，用于限制浮点数计算的精度和舍入行为。当你在类、接口或方法上使用 `strictfp` 时，该范围内的所有浮点数计算将遵循 `IEEE 754` 标准的规定，以确保跨平台的浮点数计算的一致性。

不同的硬件平台和 `JVM` 实现可能对浮点数计算的精度和舍入行为有差异，这可能导致在不同环境中运行相同的浮点数计算代码产生不同的结果。使用 `strictfp` 关键字可以确保在所有平台上获得相同的浮点数计算结果，避免计算结果的不一致问题。

但请注意，使用 `strictfp` 可能会对性能产生影响，因为可能需要更多的计算和转换来确保遵循 `IEEE 754` 标准。因此，在使用 `strictfp` 时，需要权衡精度和一致性与性能之间的关系。

```java
    public strictfp class MyClass {
        public static void main(String[] args) {
            double a = 0.1;
            double b = 0.2;
            double result = a + b;
            System.out.println("Result: " + result);
        }
    }
```

输出：

```latex
    Result: 0.30000000000000004
```

在这个示例中，`MyClass` 类被声明为 `strictfp`，因此类中的所有浮点数计算都将遵循 `IEEE 754` 标准。

在大多数现代操作系统上，使用 `strictfp` 可能不会产生显著差异，因为大家都遵循 `IEEE 754` 标准，除非是一些较旧的硬件平台。

`IEEE 754` 标准（`IEEE Standard for Floating-Point Arithmetic`）是一个定义浮点数表示和运算的国际标准。由国际电气和电子工程师协会（IEEE）制定，首次发布于1985年。

`IEEE 754` 标准主要规定了以下几个方面：

浮点数表示：标准定义了两种浮点数格式，单精度（`32`位）和双精度（`64`位）。这两种格式分别由符号位、指数位和尾数位组成，用于表示浮点数的大小和精度。

四舍五入和舍入模式：标准定义了多种舍入模式，例如向最接近的数舍入（`Round to Nearest, Ties to Even`）、向零舍入（`Round toward Zero`）、向正无穷舍入（`Round toward +∞`）和向负无穷舍入（`Round toward -∞`）等。这些模式指导了浮点数计算过程中如何处理精度损失和舍入误差。

特殊值：标准定义了一些特殊的浮点数值，如正无穷（`+∞`）、负无穷（`-∞`）和非数值（`NaN`）。这些特殊值用于表示浮点数计算中可能出现的溢出、下溢和未定义结果等情况。

浮点数运算：标准规定了浮点数的基本运算（加、减、乘、除）和比较运算（等于、不等于、大于、小于、大于等于、小于等于）的行为和结果。这些运算需要遵循标准中规定的表示、舍入和特殊值处理规则。

示例

```java
    public class Ieee754Demo {
    
        public static void main(String[] args) {
            float a = 0.1f;
            float b = 0.2f;
            float c = a + b;
    
            System.out.println("a = " + a);
            System.out.println("b = " + b);
            System.out.println("c = a + b = " + c);
    
            double x = 1.0 / 0.0;
            double y = -1.0 / 0.0;
            double z = 0.0 / 0.0;
    
            System.out.println("x = 1.0 / 0.0 = " + x);
            System.out.println("y = -1.0 / 0.0 = " + y);
            System.out.println("z = 0.0 / 0.0 = " + z);
        }
    }
```

输出结果：

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762352490560-258e811d-1c58-4f17-a4b2-4d28db50a4fb.png)

可以看到 `IEEE 754` 标准中的浮点数表示和运算：

+ 单精度浮点数的加法：变量 `a` 和 `b` 分别存储了 `0.1` 和 `0.2`，它们的和 `c` 等于 `0.3`。由于浮点数表示的精度限制，`c` 的实际值可能与理论值略有误差。
+ 特殊值：变量 `x`、`y` 和 `z` 分别存储了正无穷（`+∞`）、负无穷（`-∞`）和非数值（`NaN`）。这些特殊值是由除法运算产生的，当被除数为 `0` 或结果无法表示时，会返回相应的特殊值。

**38 super**

在子类中使用 `super` 关键字可以调用父类的构造方法或方法。

```java
    class Animal {
        protected String name;
    
        public Animal(String name) {
            this.name = name;
        }
    
        public void eat() {
            System.out.println(name + " is eating.");
        }
    }
    
    public class Dog extends Animal {
        public Dog(String name) {
            super(name); // 调用父类的构造方法
        }
    
        public void bark() {
            System.out.println(name + " is barking.");
        }
    
        public void eat() {
            super.eat(); // 调用父类的方法
            System.out.println(name + " is eating bones.");
        }
    }
```

**39 switch**

用于根据某个变量的值选择执行不同的代码块。`switch` 语句通常与 `case` 子句和 `default` 子句一起使用。每个 `case` 子句表示一个可能的值和对应的代码块，而 `default` 子句用于处理不在 `case` 子句中的值。

```java
    public class Main {
        public static void main(String[] args) {
            int dayOfWeek = 3;
    
            switch (dayOfWeek) {
                case 1:
                    System.out.println("Monday");
                    break;
                case 2:
                    System.out.println("Tuesday");
                    break;
                case 3:
                    System.out.println("Wednesday");
                    break;
                case 4:
                    System.out.println("Thursday");
                    break;
                case 5:
                    System.out.println("Friday");
                    break;
                case 6:
                    System.out.println("Saturday");
                    break;
                case 7:
                    System.out.println("Sunday");
                    break;
                default:
                    System.out.println("Invalid day");
                    break;
            }
        }
    }
```

在这个示例中，定义了一个名为 `dayOfWeek` 的整数变量，并赋予了一个值 `3`。然后，使用 `switch` 语句根据 `dayOfWeek` 的值来输出对应的星期几。每个 `case` 子句表示 `dayOfWeek` 可能的值，后面紧跟着要执行的代码。使用 `break` 语句跳出 `switch` 语句，避免执行其他 `case` 子句的代码。如果 `dayOfWeek` 的值不在 `case` 子句中，`default` 子句将被执行。

**40 synchronized**

用于指定多线程代码中的同步方法、变量或者代码块，确保在多线程环境下对共享资源的访问是安全的。

```java
    public class MyClass {
        private int count;
    
        public synchronized void increment() {
            count++; // 同步方法
        }
    
        public void doSomething() {
            synchronized(this) { // 同步代码块
                // 执行一些需要同步的操作
            }
        }
    }
```

**41 this**

可用于在方法或构造方法中引用当前对象，避免与参数或局部变量发生命名冲突。

```java
    public class MyClass {
        private int num;
    
        public MyClass(int num) {
            this.num = num; // 使用 this 关键字引用当前对象的成员变量
        }
    
        public void doSomething() {
            System.out.println("Doing something with " + this.num); // 使用 this 关键字引用当前对象的成员变量
        }
    
        public MyClass getThis() {
            return this; // 返回当前对象本身
        }
    }
```

在构造方法中，使用 `this` 关键字引用当前对象的成员变量，并将传入的参数赋值给该成员变量。在方法 `doSomething()` 中，使用 `this` 关键字引用当前对象的成员变量，并输出该成员变量的值。在方法 `getThis()` 中，直接返回当前对象本身。

**42 throw**

用于主动抛出异常。在方法中使用 `throw` 关键字可以手动抛出一个异常对象。

```java
    public class MyClass {
        public void doSomething(int num) throws Exception {
            if (num < 0) {
                throw new Exception("num must be greater than zero"); // 手动抛出异常
            }
            // 执行一些操作
        }
    }
```

**43 throws**

用于声明异常。

```java
    public class MyClass {
        public void doSomething(int num) throws Exception {
            if (num < 0) {
                throw new Exception("num must be greater than zero"); // 手动抛出异常
            }
            // 执行一些操作
        }
    }
```

**44 transient**

修饰的字段不会被序列化。在序列化过程中，`transient` 修饰的字段的值将被忽略，不会被保存到序列化的字节流中。

```java
    public class MyClass implements Serializable {
        private int id;
        private String name;
        private transient String password;
    
        public MyClass(int id, String name, String password) {
            this.id = id;
            this.name = name;
            this.password = password;
        }
    
        // 省略 getter 和 setter 方法
    
        @Override
        public String toString() {
            return "MyClass{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", password='" + password + '\'' +
                    '}';
        }
    }
```

`MyClass` 类实现了 `Serializable` 接口，表示该类的对象可以被序列化。该类有三个成员变量，分别是 `id`、`name` 和 `password`。其中，`password` 成员变量被标记为 `transient`，表示在序列化过程中忽略这个成员变量。

**45 try**

用于包裹要捕获异常的代码块。

```java
    try {
        // 可能抛出异常的代码
        int result = 1 / 0;
    } catch (Exception e) {
        // 异常处理代码
        e.printStackTrace();
    }
```

**46 void**

用于指定方法没有返回值。

```java
    public void doSomething() {
        // 方法体
    }
```

**47 volatile**

保证不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。

```java
    public class MyThread extends Thread {
        private volatile boolean running = true;
    
        @Override
        public void run() {
            while (running) {
                // 线程执行的代码
            }
        }
    
        public void stopThread() {
            running = false;
        }
    }
```

`MyThread` 类有一个成员变量 `running`，被标记为 `volatile`，表示这个变量是共享的，可能会被多个线程同时访问。在 `run()` 方法中，使用 while 循环检查 `running` 变量的值，如果 `running` 为 true，就继续执行循环体中的代码。在另一个方法 `stopThread()` 中，将 `running` 变量的值设置为 `false`，表示需要停止线程。

**48 while**

如果循环次数不固定，建议使用 `while` 循环。

```java
    int i = 0;
    while (i < 10) {
        System.out.println(i);
        i++;
    }
```

**49 goto**

Java 中两个非常特殊的保留字（`goto` 和 `const`），它们不能在程序中使用。

`goto` 在 C语言中叫做‘无限跳转’语句，在 Java 中，不再使用 `goto` 语句，因为无限跳转会破坏程序结构。

Java 中可以使用标签（label）与 `break` 和 `continue` 语句结合来实现类似 `goto` 的跳转功能。

示例：

```java
    public class LabelDemo {
        public static void main(String[] args) {
            outerLoop:
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (i == 1 && j == 1) {
                        System.out.println("跳过 outerLoop 中的当前迭代");
                        continue outerLoop;
                    }
                    System.out.println("i: " + i + ", j: " + j);
                }
            }
            System.out.println("结束");
        }
    }
```

外层循环有一个名为 `outerLoop` 的标签。当 `i` 等于 1 且 `j` 等于 1 时，使用 `continue outerLoop` 语句跳过外层循环中的当前迭代，与 `goto` 的行为类似。

输出结果：

```latex
    i: 0, j: 0
    i: 0, j: 1
    i: 0, j: 2
    i: 1, j: 0
    跳过 outerLoop 中的当前迭代
    i: 2, j: 0
    i: 2, j: 1
    i: 2, j: 2
    结束
```

尽管可以使用标签实现类似 `goto` 的跳转功能，但这种用法在 Java 中仍然较少见，因为过度使用可能导致代码难以理解和维护。通常建议尽可能使用其他控制结构（如 `if`、`for` 和 `while` 语句）来组织代码。以下是一个使用 `if` 和 `for` 语句替代标签跳转的示例：

```java
    public class IfForDemo {
        public static void main(String[] args) {
            for (int i = 0; i < 3; i++) {
                boolean skipIteration = false;
                for (int j = 0; j < 3; j++) {
                    if (i == 1 && j == 1) {
                        System.out.println("跳过外层循环中的当前迭代");
                        skipIteration = true;
                        break;
                    }
                    System.out.println("i: " + i + ", j: " + j);
                }
                if (skipIteration) {
                    continue;
                }
            }
        }
    }
```

**50 const**

`const` 在C语言中是声明常量的关键字，在 Java 中可以使用 `public static final` 三个关键字的组合来达到常量的效果。

```java
    public class Circle {
        public static final double PI = 3.14159;
    
        public static double calculateArea(double radius) {
            return PI * radius * radius;
        }
    }
```

在示例中，`public static final` 关键字组合定义了一个名为 `PI` 的常量。因为它是 `public` 的，所以其他类可以访问这个常量。因为它是 `static` 的，所以它与类关联，而不是类的实例。因为它是 `final` 的，所以它的值不能被更改。

### 标识符

Java 中变量、方法、类名等命名时使用的字符序列。

**标识符命名规则**：

+ 由字母、数字、下划线、`$`组成
+ **不可数字开头**
+ 不可使用关键字和保留字，但可以包括，如：`testvoid`
+ 严格区分大小写，无长度限制
+ 不能包含空格

### 标识符命名规范

+ 包名：多单词组成时所有字母都小写
+ 类名、接口名：多单词组成时，所有单词都首字母大写
+ 变量名、方法名：多单词组成时，首个单词小写，其后的单词都首字母大写
+ 常量名：所有字母大写，多单词时每个单词都用下划线连接，如：`MAX_VALUE`

### 注释

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353477920-5ce8afd3-953c-4981-8071-cd875cd651ab.png)

#### 单行注释

单行注释通常用于解释方法内某单行代码的作用。

```java
public void method() {
    int age = 18; // age 用于表示年龄
}
```

**如果写在行尾的话，不符合阿里巴巴的开发规约**。

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353494543-9c6d4550-cf60-4edd-b1bf-5822ae765f5f.png)

正确的单行注释应当在被注释语句上方另起一行，使用 `//` 注释。

```java
public void method() {
    // age 用于表示年龄
    int age = 18;
}
```

#### 多行注释

多行注释通常用于解释一段代码的作用。

```java
public void method() {
    /*
    age 用于表示年纪
    name 用于表示姓名
    */
    int age = 18;
    String name = "沉默王二";
```

以 `/*` 开始，以 `*/` 结束。

#### 文档注释

文档注释可用在三个地方，类、字段和方法，用来解释它们是干嘛的。

```java
/**
 * 微信搜索「沉默王二」，回复 Java
 */
public class Demo {
    /**
     * 姓名
     */
    private int age;

    /**
     * main 方法作为程序的入口
     *
     * @param args 参数
     */
    public static void main(String[] args) {

    }
}
```

PS：在 `Intellij IDEA` 中，按下 `/**` 后敲下回车键就可以自动添加文档注释的格式，`*/` 是自动补全的。

通过 `javadoc` 命令生成代码文档：

**第一步**，在类文件上右键，找到「`Open in Terminal`」 可以打开命令行窗口。

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353509189-e02d0c04-762a-43eb-a5db-fdb086405885.png)

**第二步**，执行 `javadoc` 命令 `javadoc Demo.java -encoding utf-8`。`-encoding utf-8` 可以保证中文不发生乱码。

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353522046-bb38e03a-4574-4df4-b16c-40d5dbefe91a.png)

**第三步**，执行 `ls -l` 命令就可以看到生成代码文档时产生的文件，主要是一些可以组成网页的 `html`、`js` 和 `css` 文件。

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353534619-cdcd47b1-51f6-430f-9eee-c341e09c1315.png)

**第四步**，执行 `open index.html` 命令可以通过默认的浏览器打开文档注释。

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353549871-e7209d7e-9364-4ded-b7d8-d430fd94ec04.png)

**点击**「`Demo`」，可以查看到该类更具体的注释文档。

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353564451-3febe52f-8a39-428d-8377-3ad646bc4363.png)

#### 文档注释的注意事项

1 `javadoc` 命令只能为 `public` 和 `protected` 修饰的字段、方法和类生成文档。

`default` 和 `private` 修饰的字段和方法的注释将会被忽略掉。因为本来就不希望这些字段和方法暴露给调用者。如果类不是 `public` 的话，`javadoc` 会执行失败。

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353580134-c2d557bf-1994-45ee-930d-761f902d54b4.png)

2 文档注释中可以嵌入一些 `HTML` 标记，比如说段落标记 `<p>`，超链接标记 `<a></a>` 等，但不要使用标题标记，如 `<h1>`，因为 `javadoc` 会插入自己的标题，容易发生冲突。

3 文档注释中可以插入一些 `@` 注解，比如说 `@see` 引用其他类，`@version` 版本号，`@param` 参数标识符，`@author` 作者标识符，`@deprecated` 已废弃标识符等。

#### 注释规约

+ `类`、`字段`、`方法` 必须使用文档注释，不能使用单行注释和多行注释。因为注释文档在 IDE 编辑窗口中可以悬浮提示，提高编码效率。比如在使用 `String` 类的时候，鼠标悬停在 `String` 上时可以得到以下提示。

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353595258-549fdbfb-b868-4c26-ab8a-1ee7a6ff987f.png)

+ `所有的抽象方法`（包括接口中的方法）必须要用 `Javadoc` 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。
+ `所有的类`都尽量添加创建者和创建日期。

`Intellij IDEA` 中可以在「`File and Code Templates`」中设置。

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762353607043-08e09d49-04aa-4d0a-aa5c-d8e5c31aa7dd.png)

语法如下所示：

```java
/**
* 微信搜索「沉默王二」，回复 Java
* @author 沉默王二
* @date ${DATE}
*/
```

设置好后，在新建一个类的时候就可以自动生成了。

```java
/**
 * 微信搜索「沉默王二」，回复 Java
 *
 * @author 沉默王二
 * @date 2020/11/16
 */
public class Test {
}
```

+ `所有的枚举类型字段`必须要有注释，说明每个数据项的用途。
+ `代码修改的同时`，注释也要进行相应的修改。

注释是程序固有的一部分。

+ 注释要能够准确反映设计思想和代码逻辑;
+ 注释要能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。

## 变量的定义与分类、注意点
>
> <font style="color:rgb(44, 62, 80);">Java 是一种静态类型的编程语言，这意味着所有变量必须在使用之前声明好，也就是必须得先指定变量的类型和名称。</font>
>

### 变量的定义

变量用于在内存中保存数据，对应内存中的一个存储区域。

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398030231-1be5a193-c0fc-471f-b5b4-87ca2e03de8d.png)

**构成**：数据类型、变量名、存储的值

**变量声明**：数据类型 变量名 = 变量值，例如：

```powershell
int number = 15
```

**变量的定义格式**：

**声明**：数据类型 变量名

```java
// 存储一个整数类型的年龄
int age;
// 存储一个小数类型的体重
double weight;
// 存储一个单字符类型的性别
char gender;
// 存储一个布尔类型的婚姻状态
boolean marry;
// 存储一个字符串类型的姓名
String name;

// 声明多个同类型的变量
// 表示a,b,c三个变量都是int类型
int a,b,c;
```

**赋值**：变量名 = 值，给变量赋的值类型必须与声明的类型一致或兼容

+ 使用合适类型的常量值给已经声明的变量赋值：

```java
int age = 18;

int weight = 109;

char gender = '女';
```

+ 使用其他变量或表达式给变量赋值：

```java
int m = 1;
int n = m;

int x = 1;
int y = 2;
int z = 2 * x + y;
```

### 变量的分类

**变量按数据类型的分类**：

+ 基本数据类型： 整数、浮点数、字符、布尔型
+ 引用数据类型： 数组、接口、类、枚举、注解、记录

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398035452-95a6bbec-9a77-4e2c-beeb-9776a81aa78b.png)

### 变量作用域

变量可以分为局部变量、成员变量、静态变量。

<font style="color:rgb(44, 62, 80);">当变量是局部变量的时候，必须得先初始化，否则编译器不允许你使用它。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1762354017295-00e7a97a-2fb5-4ce3-ac21-bd759abe63aa.png)

<font style="color:rgb(44, 62, 80);">当变量是成员变量或者静态变量时，可以不进行初始化，它们会有一个默认值：</font>

```java
/**
 * @author 微信搜「沉默王二」，回复关键字 PDF
 */
public class LocalVar {
    private int a;
    static int b;

    public static void main(String[] args) {
        LocalVar lv = new LocalVar();
        System.out.println(lv.a); // 0
        System.out.println(b);    // 0
    }
}
```

<font style="color:rgb(44, 62, 80);">不同的基本数据类型，有不同的默认值和占用大小:</font>

| <font style="color:rgb(44, 62, 80);">数据类型</font> | <font style="color:rgb(44, 62, 80);">默认值</font> | <font style="color:rgb(44, 62, 80);">大小</font> |
| --- | --- | --- |
| <font style="color:rgb(44, 62, 80);">boolean</font> | <font style="color:rgb(44, 62, 80);">false</font> | <font style="color:rgb(44, 62, 80);">不确定</font> |
| <font style="color:rgb(44, 62, 80);">char</font> | <font style="color:rgb(44, 62, 80);">'\u0000'</font> | <font style="color:rgb(44, 62, 80);">2 字节</font> |
| <font style="color:rgb(44, 62, 80);">byte</font> | <font style="color:rgb(44, 62, 80);">0</font> | <font style="color:rgb(44, 62, 80);">1 字节</font> |
| <font style="color:rgb(44, 62, 80);">short</font> | <font style="color:rgb(44, 62, 80);">0</font> | <font style="color:rgb(44, 62, 80);">2 字节</font> |
| <font style="color:rgb(44, 62, 80);">int</font> | <font style="color:rgb(44, 62, 80);">0</font> | <font style="color:rgb(44, 62, 80);">4 字节</font> |
| <font style="color:rgb(44, 62, 80);">long</font> | <font style="color:rgb(44, 62, 80);">0L</font> | <font style="color:rgb(44, 62, 80);">8 字节</font> |
| <font style="color:rgb(44, 62, 80);">float</font> | <font style="color:rgb(44, 62, 80);">0.0f</font> | <font style="color:rgb(44, 62, 80);">4 字节</font> |
| <font style="color:rgb(44, 62, 80);">double</font> | <font style="color:rgb(44, 62, 80);">0.0</font> | <font style="color:rgb(44, 62, 80);">8 字节</font> |

### 注意点

+ 对于每个变量要：先声明，后使用
+ 变量作用域：`{}`内
+ 变量只在作用域内有效
+ 同一个作用域不可重复定义相同名变量

## 整型和浮点型变量的使用

### 整型

`byte`、`short`、`int`、`long`

Java 各整数类型有固定的表示范围和长度，**不受具体操作系统的影响**，以保证 Java 程序的可移植性。

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398042590-8970914a-3d14-4fa0-a950-10c01c4f3636.png)

定义`long`类型的变量，赋值是需要以`l`或`L`作为后缀。

Java 的**整型常量默认为**`int`**型。**

### 浮点型

`float`、`double`

同整数，Java 的浮点类型也有固定的表示范围和长度，**不受操作系统的影响。**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398047863-be097ed4-e5fe-4fe5-885f-cf8db376812f.png)

`float`单精度，位数可以精确到`7`位有效数字。

`double`双精度，精度是`float`的两倍。

Java 的**浮点型常量默认为**`double`**类型**。

注意：

+ **并不是所有的小数都能可以精确的用二进制浮点数表示。二进制浮点数不能精确的表示**`0.1`、`0.01`、`0.001`**这样**`10`**的负次幂**。
+ 浮点类型`float`、`double`的数据不适合在不容许舍入误差的金融计算领域。如果需要精确数字计算或保留指定位数的精度，需要使用`BigDecimal`类。

## 字符型和布尔型变量的使用

### 字符型

`char`

`char`表示通常意义上的字符（2字节），Java 中所有的字符都使用`Unicode`编码，一个字符可以存储一个字母、汉字、或者书面语的一个字符。

**字符型变量的三种表现形式**：

+ 使用单引号`''`括起来的单个字符

```java
char c1 = 'a'
```

+ 直接使用`Unicode`值来表示单个字符型常量

```java
char sharp = '\u0023' // 表示#
```

+ 使用转义字符`\`将其后的字符转变为特殊字符型常量

```java
char line = '\n' // 表示换行符 \n
```

**常见转义字符：**

| 转义字符 | 说明 | Unicode 表示方式 |
| :---: | :---: | :---: |
| \n | 换行符 | \u000a |
| \t | 制表符 | \u0009 |
| " | 双引号 | \u0022 |
| ' | 单引号 | \u0027 |
| \ | 反斜线 | \u005c |
| \b | 退格符 | \u0008 |
| \r | 回车符 | \u000d |

### 布尔型

`boolean`

`boolean`类型用来判断逻辑条件，一般用于流程控制语句中：

```java
boolean isFlag = true;

if(isFlag){
    // true分支
}else{
    // false分支
}
```

+ `if`条件控制语句
+ `while`循环控制语句
+ `for`循环控制语句
+ `do-while`循环控制语句

`boolean`类型数据只有两个值：`true`、`false`。

**Java 不可以使用**`0`或非`0`的整数替代`false`和`true`，与`C`**语言不一样！**

**注意：**  
不要这样写：

```java
if(isFlag == true)
```

因为容易错写成：

```java
// 这样就变成给isFlag赋值为true了
if(isFlag = true)
```

好的写法：

```java
if(isFlag)
// 或
if(!isFlag)
```

## 基本数据类型变量的自动类型提升

在 Java 中，不同的基本数据类（byte、short、int、long、char、float、double）变量的值经常需要进行互相转换。

转换的方式有两种：自动类型转换、强制类型转换。

**自动类型提升：**

将取值范围小的类型自动提升为取值范围大的类型。

基本数据类型的转换规则：

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398086244-f4a70e46-81c9-4717-ba26-f77a41acdcae.png)

1. 把存储范围小的值（常量值、变量的值、表达式计算的结果值）**赋值**给存储范围大的变量

```java
// char自动升级为int，其实就是把字符的编码值赋值给i变量了
int i = 'A';

// int自动升级为double
double d = 10;

// 右边的整数常量值如果在int范围，编译和运行都可以通过，
// 这里涉及到数据类型转换
long num = 1234567;

// 错误，右边的整数常量值超过byte范围
// byte bigB = 130;

// 右边的整数常量值如果超过int范围，必须加L，显式表示long类型。
// 否则编译不通过
long bigNum = 12345678912L;
```

2. 当存储范围小的数据类型与存储范围大的数据类型变量**一起混合运算**时，会按照其中最大的类型运算

```java
int i = 1;
byte b = 1;
double d = 1.0;

//混合运算，升级为double
double sum = i + b + d;
```

3. `byte`、`short`、`char`数据类型变量进行算术运算时，会按照`int`类型处理

```java
byte b1 = 1;
byte b2 = 2;
// 编译报错，b1 + b2自动升级为int
byte b3 = b1 + b2;

char c1 = '0';
char c2 = 'A';
// 至少需要使用int类型来接收
int i = c1 + c2;
// 113
System.out.println(c1 + c2);
```

## 基本数据类型变量的强制类型转换

**强制类型转换：**

将取值范围大的类型强制转换成取值范围小的类型。

自动类型提升是 Java 自动执行的，强制类型转换是需要我们自己手动执行。

**转换格式**：数据类型1 变量名 = (数据类型1) 被强转数据值;

当把取值范围大的值（常量值、变量值、表达式计算的结果值）强制转换为取值范围小的变量时，**可能会损失精度或溢出**。

```java
// 损失精度
int i = (int)3.14;

double d = 1.2;
// 损失精度
int num = (int)d;

int i = 200;
// 溢出
byte b = (byte)i;
```

当某个值要提升数据类型时，也可以使用强制类型转换，这种转换没有风险。

```java
int i = 1;
int j = 2;
double bigger = (double)(i/j);
```

声明`long`类型变量时，可以出现省略后缀的情况，`float`不行。

```java
long l1 = 123L;

// 此时可以看做是int类型的123自动类型提升为long类型
long l2 = 123;

// 报错，因为123123123123超出了int的范围。
// long l3 = 123123123123;

long l4 = 123123123123L;

// 报错，因为12.3看做是double，不能自动转换为float类型
// float f1 = 12.3;

float f2 = 12.3F;
float f3 = (float)12.3;
```

## String与基本数据类型变量间的运算

`String`不是基本数据类型，属于引用数据类型，使用一对`""`来表示一个字符串，**内部可以包含**`0`**个或多个字符串。**

**声明方式：**

```java
String str = "this is a string"
```

**运算规则：**

任意 8 种基本数据类型的数据与`String`类型只能进行`+`运算，且结果一定是`String`类型。

```java
System.out.println("" + 1 + 2);//12

int num = 10;
boolean b1 = true;
String s1 = "abc";

String s2 = s1 + num + b1;
System.out.println(s2);//abc10true

//编译不通过，因为int类型不能与boolean运算
//String s3 = num + b1 + s1;
String s4 = num + (b1 + s1);//编译通过
```

`String`类型不能通过强制类型转换转为其他类型。

```java
String str = "123";
int num = (int)str;//错误的
```

## [new] 数据类型补充(待整合)

[https://javabetter.cn/basic-grammar/basic-data-type.html](https://javabetter.cn/basic-grammar/basic-data-type.html)

## [new] 数据类型转换补充(待整合)

[https://javabetter.cn/basic-grammar/type-cast.html](https://javabetter.cn/basic-grammar/type-cast.html)

## 进制转换

**原码、反码、补码：**

// TODO 计算机基础知识补充

**二进制到十进制：**

// TODO 计算机基础知识补充  

**十进制到二进制：**

除`2`取余的逆

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398094374-4c05849b-0682-451f-95fe-c7d071b2613a.png)

## 二进制与八进制、十六进制间的转换

**各进制间的转换：**

// TODO 计算机基础知识补充

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398105528-de0ad428-9d04-43a4-915d-3fa6aa2883b7.png)

## 算数运算符

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398115364-bf70caf9-92ad-490f-ad6a-db71bb505cc8.png)

## 赋值运算符

| 运算符 | 运算 |
| :---: | :--- |
| += | 将符号左边的值和右边的值进行相加操作，最后将结果赋值给左边的变量 |
| -= | 将符号左边的值和右边的值进行相减操作，最后将结果赋值给左边的变量 |
| *= | 将符号左边的值和右边的值进行相乘操作，最后将结果赋值给左边的变量 |
| /= | 将符号左边的值和右边的值进行相除操作，最后将结果赋值给左边的变量 |
| %= | 将符号左边的值和右边的值进行取余操作，最后将结果赋值给左边的变量 |

## 比较运算符、逻辑运算符

**比较运算符：**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398121858-51c1dcd5-e9e2-4891-82b3-b38276b3cfac.png)

**逻辑运算符：**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398125928-73954553-f4c4-4c06-9dca-6bbf72aed488.png)

`&` 和 `&&`：表示"且"关系，当符号左右两边布尔值都是true时，结果才能为true。否则，为`false`。

`|` 和 `||` ：表示"或"关系，当符号两边布尔值有一边为true时，结果为true。当两边都为`false`时，结果为`false`。

`!` ：表示"非"关系，当变量布尔值为`true`时，结果为`false`。当变量布尔值为`false`时，结果为`true`。

`^` ：当符号左右两边布尔值不同时，结果为`true`。当两边布尔值相同时，结果为`false`。

**区分**`&`**和**`&&`**：**

**相同点**：如果符号左边是`true`，则二者都执行符号右边的操作。

**不同点**：

+ `&`**： 如果符号左边是**`false`**,则继续执行符号右边的操作**
+ `&&` ：如果符号左边是`false`,则不再继续执行符号右边的操作
+ 建议：开发中，推荐使用 `&&`

**区分**`|`**和**`||`**：**

**相同点**：如果符号左边是`false`，则二者都执行符号右边的操作。

**不同点**：

+ | ： 如果符号左边是`true`，则继续执行符号右边的操作
+ || ：如果符号左边是`true`，则不再继续执行符号右边的操作
+ 建议：开发中，推荐使用 `||`

## 位运算符

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398145971-28f9c5d9-657f-4a50-ae8a-0d39379da78a.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398154065-2cc3b256-f0d3-4fb6-adc9-68de0e66033e.png)

## 条件运算符与运算符的优先级

**条件运算符（其他叫法：三目运算符）：**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733398164382-f3587a26-07a5-4d94-b20c-7c69228405a9.png)

**运算符优先级：**

| 优先级 | 说明 | Java运算符 |
| :---: | :---: | :---: |
| 1 | 括号 | ()、[]、{} |
| 2 | 正负号 | +、- |
| 3 | 单元运算符 | ++、--、~、！ |
| 4 | 乘法、除法、求余 | *、/、% |
| 5 | 加法、减法 | +、- |
| 6 | 移位运算符 | <<、>>、>>> |
| 7 | 关系运算符 | <、<=、>=、>、instanceof |
| 8 | 等价运算符 | ==、!= |
| 9 | 按位与 | & |
| 10 | 按位异或 | ^ |
| 11 | 按位或 |  |
| 12 | 条件与 | && |
| 13 | 条件或 |  |
| 14 | 三元运算符 | ? : |
| 15 | 赋值运算符 | =、+=、-=、*=、/=、%= |
| 16 | 位赋值运算符 | &=、|=、<<=、>>=、>>>= |

## [new] 运算符补充(待整合)

[https://javabetter.cn/basic-grammar/operator.html](https://javabetter.cn/basic-grammar/operator.html)

## 字符集

// TODO 计算机基础知识补充
