---
title: 14 泛型(Generic)
createTime: 2025/08/22 22:41:51
permalink: /language/java/4u2og2wz/
---
## 泛型概述

`Java`**<font style="color:#DF2A3F;">中的泛型，就类似于下面场景中的标签。</font>**

### 生活中的例子

- **举例**`1`：中药店里每个抽屉外面贴着的标签

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733193177086-46c5c6b0-37cf-4022-82de-3a192c337077.png)

- **举例**`2`：超市购物架上很多瓶子，每个瓶子装的是什么，有标签

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733193181266-27a0ac5f-6ee0-486e-9f69-bb5b274187e7.png)

- **举例**`3`：家庭厨房中，各类调料的标签

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733193185026-e8101eb6-08be-47df-977b-31a710ed636e.png)

### 泛型的引入

在`Java`中在声明方法时，**<font style="color:#DF2A3F;">当在完成方法功能时如果有未知的数据需要参与，这些未知的数据需要在调用方法时才能确定，那么就把这样的数据通过形参表示。在方法体中，用这个形参名来代表那个未知的数据，调用者在调用时，传入对应的实参就可以了。</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733193192987-954d30d7-195b-470b-82ce-d97fc3389fa8.png)

受以上启发，`JDK1.5`**设计了**<font style="color:#DF2A3F;">泛型</font>**的概念，泛型即：**<font style="color:#DF2A3F;">类型参数</font>**，这个类型参数**<font style="color:#DF2A3F;">在声明它的类、接口或方法中，代表未知的某种通用类型</font>**。**

**举例**`1`**：**

**<font style="color:#DF2A3F;">集合类在设计阶段</font>**`/`**<font style="color:#DF2A3F;">声明阶段不能确定这个容器到底实际存的是什么类型的对象</font>**，所以在`JDK5.0`之前只能把元素类型设计为`Object`，`JDK5.0`时`Java`引入了 **<font style="color:#DF2A3F;">参数化类型</font>**（**`Parameterized Type`**）的概念，**允许在创建集合时指定集合元素的类型**。**比如**：`List<String>`表明该`List`只能保存字符串类型的对象。使用集合存储数据时，除了元素的类型不确定，其他部分是确定的（例如：关于这个元素如何保存，如何管理等）。

**举例**`2`**：**

`java.lang.Comparable`**<font style="color:#DF2A3F;">接口和</font>**`java.util.Comparator`**<font style="color:#DF2A3F;">接口</font>**，是用于比较对象大小的接口。这两个接口只是限定了当一个对象大于另一个对象时返回`正整数`，小于返回`负整数`，等于返回`0`，但**并不确定是什么类型的对象比较大小**。`JDK5.0`之前只能用`Object`类型表示，使用时既麻烦又不安全，**因此**`JDK5.0`**给它们增加了泛型。**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733193197247-41126c8a-3a73-4b0e-b0c6-51698b13a228.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733193204168-640ea81f-4ffa-4890-af9b-705beb315b6e.png)

**其中类型参数就是泛型**。<font style="color:#DF2A3F;"> 所谓泛型，就是</font>**<font style="color:#DF2A3F;">允许在定义类、接口时通过一个标识表示类中某个属性的类型或某个方法的返回值或参数的类型</font>**<font style="color:#DF2A3F;">，这个类型参数将在使用时（</font>**<font style="color:#DF2A3F;">例如</font>**<font style="color:#DF2A3F;">：继承或实现这个接口、创建对象或调用方法时）确定（</font>**<font style="color:#DF2A3F;">即</font>**<font style="color:#DF2A3F;">：传入实际的类型参数，也称为</font>**<font style="color:#DF2A3F;">类型实参</font>**<font style="color:#DF2A3F;">）</font>。

## 使用泛型举例

**<font style="color:#DF2A3F;">自从</font>**`JDK5.0`**<font style="color:#DF2A3F;">引入泛型的概念之后，对之前核心类库中的</font>**`API`**<font style="color:#DF2A3F;">做了很大的修改</font>**。**例如**：`JDK5.0`**改写了集合框架中全部接口和类、**`java.lang.Comparable`**接口、**`java.util.Comparator`**接口、**`Class`**类等，为这些接口、类增加了泛型支持，从而可以在声明变量、创建对象时传入类型实参。**

### <font style="color:#DF2A3F;">集合中</font>使用泛型

**集合中没有使用泛型时**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733193210698-0494aaaa-5de3-4898-86dd-e0901ba963f1.png)

**集合中使用泛型时**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733193215038-2aa72158-e128-4496-9f88-f6a761d04bd5.png)

`Java` **泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生 `ClassCastException` 异常。即：把不安全的因素在编译期间就排除了，而不是运行期；既然通过了编译，那么类型一定是符合要求的，就避免了类型转换。** 同时，代码更加简洁、健壮。**把一个集合中的内容限制为一个特定的数据类型，这就是 `generic` 背后的核心思想**。

**<font style="color:#DF2A3F;">集合中使用泛型举例：</font>**

```java
// 泛型在List中的使用
@Test
public void test1(){
  // 举例：将学生成绩保存在ArrayList中
  // 标准写法：
  // ArrayList<Integer> list = new ArrayList<Integer>();
  // jdk7的新特性：类型推断
  ArrayList<Integer> list = new ArrayList<>();

  // 自动装箱
  list.add(56);
  list.add(76);
  list.add(88);
  list.add(89);
  // 当添加非Integer类型数据时，编译不通过
  // list.add("Tom"); // 编译报错

  Iterator<Integer> iterator = list.iterator();
  while(iterator.hasNext()){
    // 不需要强转，直接可以获取添加时的元素的数据类型
    Integer score = iterator.next();
    System.out.println(score);
  }
}
```

```java
// 泛型在Map中的使用
@Test
public void test2(){
  HashMap<String,Integer> map = new HashMap<>();

  map.put("Tom",67);
  map.put("Jim",56);
  map.put("Rose",88);
  // 编译不通过
  // map.put(67,"Jack");

  // 遍历key集
  Set<String> keySet = map.keySet();
  for(String str:keySet){
    System.out.println(str);
  }

  // 遍历value集
  Collection<Integer> values = map.values();
  Iterator<Integer> iterator = values.iterator();
  while(iterator.hasNext()){
    Integer value = iterator.next();
    System.out.println(value);
  }

  // 遍历entry集
  Set<Map.Entry<String, Integer>> entrySet = map.entrySet();
  Iterator<Map.Entry<String, Integer>> iterator1 = entrySet.iterator();
  while(iterator1.hasNext()){
    Map.Entry<String, Integer> entry = iterator1.next();
    String key = entry.getKey();
    Integer value = entry.getValue();
    System.out.println(key + ":" + value);
  }
}
```

**练习**

- 创建一个`ArrayList`集合对象，并指定泛型为`<Integer>`
- 添加`5`个`[0,100)`以内的整数到集合中
- 使用`foreach`遍历输出`5`个整数
- 使用集合的`removeIf`方法删除偶数，为`Predicate`接口指定泛型
- 再使用`Iterator`迭代器输出剩下的元素，为`Iterator`接口指定泛型

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;
import java.util.function.Predicate;

public class TestNumber {
    public static void main(String[] args) {
        ArrayList<Integer> coll = new ArrayList<Integer>();
        Random random = new Random();
        for (int i = 1; i <= 5 ; i++) {
            coll.add(random.nextInt(100));
        }

        System.out.println("coll中5个随机数是：");
        for (Integer integer : coll) {
            System.out.println(integer);
        }

        // 方式1：使用集合的removeIf方法删除偶数
        coll.removeIf(new Predicate<Integer>() {
            @Override
            public boolean test(Integer integer) {
                return integer % 2 == 0;
            }
        });

        // 方式2：调用Iterator接口的remove()方法
        //Iterator<Integer> iterator1 = coll.iterator();
        //while(coll.hasNext()){
        //    Integer i = coll.next();
        //   if(i % 2 == 0){
        //       coll.remove();
        //    }
        //}

        System.out.println("coll中删除偶数后：");
        Iterator<Integer> iterator = coll.iterator();
        while(iterator.hasNext()){
            Integer number = iterator.next();
            System.out.println(number);
        }

    }
}
```

### 比较器中使用泛型

**举例**

```java
public class Circle{
    private double radius;

    public Circle(double radius) {
        super();
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }

    @Override
    public String toString() {
        return "Circle [radius=" + radius + "]";
    }
}
```

<font style="color:#DF2A3F;">使用泛型之前：</font>

```java
import java.util.Comparator;

class CircleComparator implements Comparator{
    @Override
    public int compare(Object o1, Object o2) {
        // 强制类型转换
        Circle c1 = (Circle) o1;
        Circle c2 = (Circle) o2;
        return Double.compare(c1.getRadius(), c2.getRadius());
    }
}

// 测试
public class TestNoGeneric {
    public static void main(String[] args) {
        CircleComparator com = new CircleComparator();
        System.out.println(com.compare(new Circle(1), new Circle(2)));
        // 运行时异常：ClassCastException
        // System.out.println(com.compare("圆1", "圆2"));
    }
}
```

**<font style="color:#DF2A3F;">使用泛型之后</font>**：

```java
import java.util.Comparator;

class CircleComparator1 implements Comparator<Circle> {

    @Override
    public int compare(Circle o1, Circle o2) {
        // 不再需要强制类型转换，代码更简洁
        return Double.compare(o1.getRadius(), o2.getRadius());
    }
}

// 测试
public class TestHasGeneric {
    public static void main(String[] args) {
        CircleComparator1 com = new CircleComparator1();
        System.out.println(com.compare(new Circle(1), new Circle(2)));
        // System.out.println(com.compare("圆1", "圆2"));
        // 编译错误，因为"圆1", "圆2"不是Circle类型，是String类型，
        // 编译器提前报错，而不是冒着风险在运行时再报错。
    }
}
```

### 相关使用说明

- **<font style="color:#DF2A3F;">在创建集合对象的时候，可以指明泛型的类型</font>**
  - `List<Integer> list = new ArrayList<Integer>();`
- `JDK7.0`有新特性，可以简写
  - `List<Integer> list = new ArrayList<>(); // 类型推断`
- **<font style="color:#DF2A3F;">泛型也称为泛型参数，即：参数的类型，只能使用引用数据类型进行赋值</font>**
  - 不能使用基本数据类型，<font style="color:#DF2A3F;">可以使用包装类替换</font>
- **<font style="color:#DF2A3F;">集合声明时，声明泛型参数</font>**。在使用集合时，可以具体指明泛型的类型。一旦指明，类或接口内部，凡是使用泛型参数的位置，都指定为具体的参数类型。**<font style="color:#DF2A3F;">如果没有指明的话，看做是</font>**`Object`**<font style="color:#DF2A3F;">类型</font>**

## 自定义泛型结构

### 泛型的基础说明

1. `<类型>`**这种语法形式就叫泛型**

    - `<类型>`的形式称为<font style="color:#DF2A3F;">类型参数</font>，"类型"习惯上使用`T`表示，是`Type`的缩写。**即**：`<T>`
    - `<T>`**<font style="color:#DF2A3F;">代表未知的数据类型</font>**，可以指定为`<String>` `<Integer>` `<Circle>`等
    - 类比方法的参数，可以把`<T>`称为<font style="color:#DF2A3F;">类型形参</font>，将`<Circle>`称为 <font style="color:#DF2A3F;">类型实参</font>，有助于理解泛型
    - 这里的`T`，可以替换成`K`、`V`等任意字母

2. **在哪里可以声明类型变量**`<T>`

    - **声明类或接口时，在类名或接口名后面声明泛型类型**，这样的类或接口称为：**<font style="color:#DF2A3F;">泛型类或泛型接口</font>**

    ```java
    [修饰符] class 类名<类型变量列表> [extends 父类] [implements 接口们] {

    }
    //例如：
    public class ArrayList<E>

    [修饰符] interface 接口名<类型变量列表> [implements 接口们] {

    }
    //例如：
    public interface Map<K,V> {
        ...
    }
    ```

    - **声明方法时，在修饰符与返回值类型之间声明类型变量**，声明了类型变量的方法称为：**<font style="color:#DF2A3F;">泛型方法</font>**

    ```java
    [修饰符] <类型变量列表> 返回值类型 方法名([形参列表])[throws 异常列表]{
        //...
    }

    //例如：java.util.Arrays类中的
    public static <T> List<T> asList(T... a){
        ....
    }
    ```

### 自定义<font style="color:#DF2A3F;">泛型类</font>或<font style="color:#DF2A3F;">泛型接口</font>

**<font style="color:#DF2A3F;">当在类或接口中定义某个成员时，该成员的相关类型是不确定的，而这个类型需要在使用这个类或接口时才可以确定，那么可以使用泛型类、泛型接口。</font>**

#### 说明

- 在声明完自定义泛型类以后，可以在类的内部（**比如**：属性、方法、构造器中）使用类的泛型
- 在创建自定义泛型类的对象时，可以指明泛型参数类型，一旦指明，内部凡是使用类的泛型参数的位置，都具体化为指定的类的泛型类型
- **<font style="color:#DF2A3F;">在创建自定义泛型类的对象时，没有指明泛型参数类型，那么泛型将被擦除，泛型对应的类型均按照</font>**`Object`**<font style="color:#DF2A3F;">处理，但不等价于</font>**`Object`
  - **经验**：**<font style="color:#DF2A3F;">泛型要使用一路都用。要不用，一路都不要用。</font>**
- **<font style="color:#DF2A3F;">泛型的指定中必须使用引用数据类型，不能使用基本数据类型，基本数据类型只能使用包装类替换</font>**
- **<font style="color:#DF2A3F;">除创建泛型类对象外，子类继承泛型类、实现类实现泛型接口时，也可以确定泛型结构中的泛型参数</font>**

**如果在给泛型类提供子类时，子类也不确定泛型的类型，则可以继续使用泛型参数，还可以在现有的父类的泛型参数的基础上，新增泛型参数。**

#### <font style="color:#DF2A3F;">注意</font>

- <font style="color:#DF2A3F;">泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：</font>`<E1,E2,E3>`
- `JDK7.0`开始，泛型的简化操作：`ArrayList<Fruit> flist = new ArrayList<>();`
- 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象
- **<font style="color:#DF2A3F;">不能使用</font>**`new E[]`**<font style="color:#DF2A3F;">，但是可以：</font>**`E[] elements = (E[])new Object[capacity];`
  - **参考**：`ArrayList`源码中声明：`Object[] elementData`，而非泛型参数类型数组
- 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，但 **<font style="color:#DF2A3F;">不可以在静态方法中使用类的泛型</font>**
- **<font style="color:#DF2A3F;">异常类不能是带泛型的</font>**

#### <font style="color:#DF2A3F;">补充</font>

**静态方法中不能使用类的泛型**：这句话的意思是，在静态方法中不能直接使用类的泛型类型参数。

**例子**：

```java
// 在这个例子中，MyClass 类有一个泛型类型参数 T。
// 然而，静态方法 myStaticMethod 试图使用这个泛型类型参数 T，这是不允许的。
// 编译器会报错，因为静态方法在类加载时就已经存在，
// 而泛型类型参数 T 是在创建类的实例时才确定的。
public class MyClass<T> {
    // 类的泛型类型参数 T

    // 静态方法
    public static void myStaticMethod(T value) { // 这里会报错
        System.out.println(value);
    }
}
```

**解释**：

- 类的泛型类型参数（如`T`）是在创建类的实例时才确定的
- 静态方法在类加载时就已经存在，不需要创建类的实例就可以调用
- 因此，静态方法不能依赖于类的泛型类型参数，因为这些参数在静态方法存在时还没有确定

#### 举例

**举例**`1`：

```java
class Person<T> {
    // 使用T类型定义变量
    private T info;

    // 使用T类型定义一般方法
    public T getInfo() {
        return info;
    }

    public void setInfo(T info) {
        this.info = info;
    }

    // 使用T类型定义构造器
    public Person() {}
    public Person(T info) {
        this.info = info;
    }

    // static的方法中不能声明泛型
    //public static void show(T t) {
    //
    //}
    // 不能在try-catch中使用泛型定义
    //public void test() {
        //try {
        //
        //} catch (MyException<T> ex) {
        //
        //}
    //}
}
```

**举例**`2`**：**

```java
class Father<T1, T2> { }

// 子类不保留父类的泛型
// 1) 没有类型 擦除
class Son1 extends Father {
    // 等价于class Son extends Father<Object,Object>{
}
// 2) 具体类型
class Son2 extends Father<Integer, String> { }

// 子类保留父类的泛型
// 1) 全部保留
class Son3<T1, T2> extends Father<T1, T2> { }
// 2) 部分保留
class Son4<T2> extends Father<Integer, T2> { }
```

**举例**`3`：

```java
class Father<T1, T2> { }

// 子类不保留父类的泛型
// 1) 没有类型 擦除
class Son<A, B> extends Father{
    //等价于class Son extends Father<Object,Object>{
}
// 2) 具体类型
class Son2<A, B> extends Father<Integer, String> { }

// 子类保留父类的泛型
// 1) 全部保留
class Son3<T1, T2, A, B> extends Father<T1, T2> {
}
// 2) 部分保留
class Son4<T2, A, B> extends Father<Integer, T2> {
}
```

#### 练习

**练习**`1`**：** 声明一个学生类，该学生包含姓名、成绩，而此时学生的成绩类型不确定，为什么呢？因为，语文老师希望成绩是`优秀`、`良好`、`及格`、`不及格`，数学老师希望成绩是`89.5`、`65.0`，英语老师希望成绩是`A`、`B`、`C`、`D`、`E`，那么在设计这个学生类时，就可以使用泛型。

```java
class Student<T> {
    private String name;
    private T score;

    public Student() {
        super();
    }

    public Student(String name, T score) {
        super();
        this.name = name;
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public T getScore() {
        return score;
    }

    public void setScore(T score) {
        this.score = score;
    }

    @Override
    public String toString() {
        return "姓名：" + name + ", 成绩：" + score;
    }
}

public class TestStudent {
    public static void main(String[] args) {
        // 语文老师使用时
        Student<String> stu1 = new Student<String>("张三", "良好");

        // 数学老师使用时
            // 错误，必须是引用数据类型
            // Student<double> stu2 = new Student<double>("张三", 90.5);
        Student<Double> stu2 = new Student<Double>("张三", 90.5);

        // 英语老师使用时
        Student<Character> stu3 = new Student<Character>("张三", 'C');

        // 错误的指定
        // Student<Object> stu = new Student<String>();//错误的
    }
}
```

**练习**`2`**：**  
定义个泛型类`DAO<T>`，在其中定义一个`Map`成员变量，`Map`的键为`String`类型，值为`T`类型。

- 分别创建以下方法：
  - `public void save(String id,T entity)`：保存`T`类型的对象到`Map`成员变量中
  - `public T get(String id)`：从`map`中获取`id`对应的对象
  - `public void update(String id,T entity)`：替换`map`中`key`为`id`的内容
  - `public List<T> list()`：返回`map`中存放的所有`T` 对象
  - `public void delete(String id)`：删除指定`id`对象
- 定义一个`User`类：
  - 包含：`private`成员变量：（`int`类型）`id`、`age`，（`String`类型）`name`
- 定义一个测试类：
  - 创建`DAO`对象，调用`save`、`get`、`update`、`list`、`delete`方法操作`User`对象
- 使用`Junit`单元测试类进行测试

```java
public class DAO<T> {
    private Map<String,T> map ;

    {
        map = new HashMap<String,T>();
    }

    // 保存 T 类型的对象到 map 成员变量中
    public void save(String id, T entity) {
        if(!map.containsKey(id)){
            map.put(id,entity);
        }
    }

    // 从 map 中获取 id 对应的对象
    public T get(String id){
        return map.get(id);
    }

    // 替换 map 中key为id的内容,改为 entity 对象
    public void update(String id,T entity){
        if(map.containsKey(id)){
            map.put(id,entity);
        }
    }

    // 返回 map 中存放的所有 T 对象
    public List<T> list(){
        // 错误的：
//        Collection<T> values = map.values();
//        System.out.println(values.getClass());
//        return (List<T>) values;
        // 正确的方式1：
//        ArrayList<T> list = new ArrayList<>();
//        Collection<T> values = map.values();
//        list.addAll(values);
//        return list;
        // 正确的方式2：
        Collection<T> values = map.values();
        ArrayList<T> list = new ArrayList<>(values);
        return list;
    }

    //删除指定 id 对象
    public void delete(String id){
        map.remove(id);
    }
}
```

```java
import java.util.Objects;

public class User {
    private int id;
    private int age;
    private String name;

    public User() {
    }

    public User(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", age=" + age +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return id == user.id && age == user.age && Objects.equals(name, user.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, age, name);
    }
}
```

```java
import java.util.List;

public class DAOTest {
    public static void main(String[] args) {
        DAO<User> dao = new DAO<>();

        dao.save("1001",new User(1,34,"曹操"));
        dao.save("1002",new User(2,33,"刘备"));
        dao.save("1003",new User(3,24,"孙权"));

        dao.update("1002",new User(2,23,"刘禅"));

        dao.delete("1003");

        List<User> list = dao.list();
        for(User u : list){
            System.out.println(u);
        }
    }
}
```

### 自定义<font style="color:#DF2A3F;">泛型方法</font>

**<font style="color:#DF2A3F;">若定义类、接口时未使用</font>**`<泛型参数>`**<font style="color:#DF2A3F;">，但某个方法形参类型不确定，这个方法可以定义</font>**`<泛型参数>`**<font style="color:#DF2A3F;">。</font>**

#### 说明

- **<font style="color:#DF2A3F;">泛型方法的格式</font>**：

```java
[访问权限] <泛型> 返回值类型 方法名([泛型标识 参数名称]) [抛出的异常] {
    ...
}
```

- **方法也可以被泛型化，与其所在的类是否是泛型类没有关系**
- **泛型方法中的泛型参数在方法被调用时确定**
- **<font style="color:#DF2A3F;">泛型方法可以根据需要，声明为</font>**`static`**<font style="color:#DF2A3F;">的</font>**
  - **<font style="color:#DF2A3F;">补充说明：</font>**
    - 泛型方法可以有自己的类型参数（如：`<E>`<font style="color:rgb(64, 64, 64);">）</font>
    - <font style="color:rgb(64, 64, 64);">这些类型参数可以在方法的参数、返回类型或方法体内使用</font>
    - <font style="color:rgb(64, 64, 64);">只要泛型方法不依赖于类的泛型类型参数，它就可以声明为静态的</font>

#### 举例

**举例**`1`：

```java
// 泛型方法
public class DAO {
    public <E> E get(int id, E e) {
        E result = null;
        return result;
    }
}
```

**举例**`2`**：**

```java
// 静态泛型方法
public static <T> void fromArrayToCollection(T[] a, Collection<T> c) {
    for (T o : a) {
        c.add(o);
    }
}

// 测试
public static void main(String[] args) {

    Object[] ao = new Object[100];
    Collection<Object> co = new ArrayList<Object>();
    fromArrayToCollection(ao, co);

    String[] sa = new String[20];
    Collection<String> cs = new ArrayList<>();
    fromArrayToCollection(sa, cs);

    Collection<Double> cd = new ArrayList<>();
    // 下面代码中T是Double类，但sa是String类型，编译错误。
    // fromArrayToCollection(sa, cd);
    // 下面代码中T是Object类型，sa是String类型，可以赋值成功。
    fromArrayToCollection(sa, co);
}
```

**举例**`3`**：**

```java
class MyArrays {
    public static <T> void sort(T[] arr){
        for (int i = 1; i < arr.length; i++) {
            for (int j = 0; j < arr.length-i; j++) {
                if(((Comparable<T>)arr[j]).compareTo(arr[j+1])>0){
                    T temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
    }
}

public class MyArraysTest {
    public static void main(String[] args) {
        int[] arr = {3,2,5,1,4};
        // 错误的，因为int[]不是对象数组
        // MyArrays.sort(arr);

        String[] strings = {"hello","java","song"};
        MyArrays.sort(strings);
        System.out.println(Arrays.toString(strings));

        Circle[] circles = {new Circle(2.0),new Circle(1.2),new Circle(3.0)};
        // 编译通过，运行报错，因为Circle没有实现Comparable接口
        MyArrays.sort(circles);
    }
}
```

#### 练习

**练习**`1`：编写一个泛型方法，<font style="color:#DF2A3F;">实现任意引用类型数组指定位置元素交换</font>

`public static <E> void method1( E[] e,int a,int b)`

```java
public class Exer01 {

    // 编写一个泛型方法，实现任意引用类型数组指定位置元素交换
    public static <E> void method( E[] arr,int a,int b){
        E temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    @Test
    public void testMethod(){
        Integer[] arr = new Integer[]{10,20,30,40};
        method(arr,2,3);
        for(Integer i : arr){
            System.out.println(i);
        }
    }
}
```

**练习**`2`：编写一个泛型方法，<font style="color:#DF2A3F;">接收一个任意引用类型的数组，并反转数组中的所有元素</font>

`public static <E> void method2( E[] e)`

```java
public class Exer01 {

    // 编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素
    public static <E> void method1( E[] arr){
        for(int min = 0,max = arr.length - 1;min < max; min++,max--){
            E temp = arr[min];
            arr[min] = arr[max];
            arr[max] = temp;
        }
    }

    @Test
    public void testMethod1(){
        Integer[] arr = new Integer[]{10,20,30,40};
        method1(arr);
        for(Integer i : arr){
            System.out.println(i);
        }
    }
}
```

## 泛型在继承上的体现

**<font style="color:#DF2A3F;">若</font>**`B`**<font style="color:#DF2A3F;">是</font>**`A`**<font style="color:#DF2A3F;">的子类型（子类或子接口），</font>**`G`**<font style="color:#DF2A3F;">是具有泛型声明的类或接口，</font>**`G<B>`**<font style="color:#DF2A3F;">不是</font>**`G<A>`**<font style="color:#DF2A3F;">的子类型！</font>**

**比如：**`String`**是**`Object`**的子类，但是**`List<String>`**并不是**`List<Object>`**的子类。**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733193236133-4e98fcbf-b12a-4e59-a7ab-ae5c80ad3593.png)

```java
public void testGenericAndSubClass() {
    Person[] persons = null;
    Man[] mans = null;

    // Person[] 是 Man[] 的父类
    persons = mans;
    Person p = mans[0];

    // 在泛型的集合上
    List<Person> personList = null;
    List<Man> manList = null;
    //personList = manList;(报错)
}
```

**思考**：对比如下两段代码有何不同

- **片段**`1`

```java
public void printCollection(Collection c) {
    Iterator i = c.iterator();
    for (int k = 0; k < c.size(); k++) {
        System.out.println(i.next());
    }
}
```

- **片段**`2`

```java
public void printCollection(Collection<Object> c) {
    for (Object e : c) {
        System.out.println(e);
    }
}
```

- **<font style="color:#DF2A3F;">代码</font>**`1`<font style="color:#DF2A3F;">：使用了原始类型</font>`Collection`<font style="color:#DF2A3F;">，编译器会进行类型擦除，运行时无法知道集合的具体类型</font>
- **<font style="color:#DF2A3F;">代码</font>**`2`<font style="color:#DF2A3F;">：使用了泛型类型</font>`Collection<Object>`<font style="color:#DF2A3F;">，编译器会保留类型信息，尽管在运行时类型信息会被擦除，但在编译时可以进行类型检查</font>

#### <font style="color:#DF2A3F;">补充</font>

**泛型擦除和类型安全**

- 泛型擦除：
  - `Java`的泛型在编译时会进行类型擦除，这意味着泛型类型信息在运行时会被擦除。
    - **例如**：`List<String>`在运行时会被擦除为`List`
- 类型安全：
  - 泛型的主要目的是提供类型安全。通过使用泛型，编译器可以在编译时检查类型，确保只能向泛型集合中添加正确类型的对象

**显示声明泛型参数**

当显示声明泛型参数时，编译器会进行严格的类型检查，确保只能向泛型集合中添加正确类型的对象。**例如**：

```java
List<String> list = new ArrayList<>();
// 编译器会检查类型，确保只能添加 String
list.add("Hello");
```

在这种情况下，编译器会在编译时检查类型，确保只能向`List<String>`中添加`String`类型的对象。如果尝试添加其他类型的对象，编译器会报错：

```java
// 编译器会报错，因为 123 不是 String 类型
list.add(123);
```

**不显示声明泛型参数**

如果不显示声明泛型参数，而是使用原始类型，**例如**：`List`，编译器不会进行类型检查，这意味着可以向集合中添加任何类型的对象。**例如**：

```java
List list = new ArrayList();
// 可以添加 String
list.add("Hello");
// 也可以添加 Integer
list.add(123);
```

在这种情况下，编译器不会进行类型检查，可以向集合中添加任何类型的对象。这可能会导致运行时类型转换异常：

```java
// 运行时会抛出 ClassCastException，因为 list.get(1) 是 Integer 类型
String str = (String) list.get(1);
```

**总结**

- **<font style="color:#DF2A3F;">显示声明泛型参数</font>**：编译器会在编译时进行严格的类型检查，确保只能向泛型集合中添加正确类型的对象。**这可以避免运行时类型转换异常**
- **<font style="color:#DF2A3F;">不显示声明泛型参数</font>**：编译器不会进行类型检查，可以向集合中添加任何类型的对象。**这可能会导致运行时类型转换异常**

## 通配符的使用

**<font style="color:#DF2A3F;">当声明一个变量/形参时，这个变量/形参的类型是一个泛型类或泛型接口。例如：</font>**`Comparator<T>`**<font style="color:#DF2A3F;">类型，但是仍然无法确定这个泛型类或泛型接口的类型变量</font>**`<T>`**<font style="color:#DF2A3F;">的具体类型，此时考虑使用类型通配符 </font>**`?`**<font style="color:#DF2A3F;">。</font>**

### 通配符的理解

使用类型通配符：`?`，**比如**：`List<?>`、`Map<?,?>`

`List<?>`**<font style="color:#DF2A3F;">是</font>**`List<String>`**<font style="color:#DF2A3F;">、</font>**`List<Object>`**<font style="color:#DF2A3F;">等各种泛型</font>**`List`**<font style="color:#DF2A3F;">的父类。</font>**

### 通配符的读与写

#### 写操作

**<font style="color:#DF2A3F;">将任意元素加入到其中不是类型安全的</font>**

```java
Collection<?> c = new ArrayList();
// 编译时错误
// c.add(new Object());
```

因为不知道`c`的元素类型，不能向其中添加对象。`add`方法有类型参数`E`作为集合的元素类型。传给`add`的任何参数都必须是一个未知类型的子类。因为不知道那是什么类型，所以无法传任何东西进去。唯一可以插入的元素是`null`，因为它是所有引用类型的默认值。

#### 读操作

**<font style="color:#DF2A3F;">读取</font>**`List<?>`**<font style="color:#DF2A3F;">的对象</font>**`list`**<font style="color:#DF2A3F;">中的元素时，永远是安全的，因为不管</font>**`list`**<font style="color:#DF2A3F;">的真实类型是什么，它包含的都是</font>**`Object`**<font style="color:#DF2A3F;">。</font>**

**举例**`1`：

```java
public class TestWildcard {
    public static void m4(Collection<?> coll){
        for (Object o : coll) {
            System.out.println(o);
        }
    }
}
```

**举例**`2`**：**

```java
public static void main(String[] args) {
    List<?> list = null;
    list = new ArrayList<String>();
    list = new ArrayList<Double>();
    // list.add(3);//编译不通过
    list.add(null);

    List<String> l1 = new ArrayList<String>();
    List<Integer> l2 = new ArrayList<Integer>();
    l1.add("尚硅谷");
    l2.add(15);
    read(l1);
    read(l2);
}

public static void read(List<?> list) {
    for (Object o : list) {
        System.out.println(o);
    }
}
```

### 使用注意点

- **注意点**`1`：**<font style="color:#DF2A3F;">不能用在泛型方法声明上，返回值类型前面</font>**`<>`**<font style="color:#DF2A3F;">不能使用</font>**`?`（<font style="color:#DF2A3F;">编译错误</font>）

```java
public static <?> void test(ArrayList<?> list){ }
```

- **注意点**`2`：**<font style="color:#DF2A3F;">不能用在泛型类的声明上</font>**（<font style="color:#DF2A3F;">编译错误</font>）

```java
class GenericTypeClass<?>{ }
```

- **注意点**`3`：**<font style="color:#DF2A3F;">不能用在创建对象上</font>**，右边属于创建集合对象（<font style="color:#DF2A3F;">编译错误</font>）

```java
ArrayList<?> list2 = new ArrayList<?>();
```

### <font style="color:#DF2A3F;">有限制的通配符</font>

- `<?>`
  - **<font style="color:#DF2A3F;">允许所有泛型的引用调用</font>**
- **通配符**<font style="color:#DF2A3F;">指定上限</font>：`<? extends 类 / 接口>`
  - 使用时指定的类型必须是 **<font style="color:#DF2A3F;">继承某个类，或者实现某个接口</font>**，即：`<=`
- **通配符**<font style="color:#DF2A3F;">指定下限</font>：`<? super 类 / 接口>`
  - 使用时指定的类型必须是 **<font style="color:#DF2A3F;">操作的类或接口，或者是操作的类的父类或接口的父接口</font>**，即：`>=`
- **说明：**

```java
 <? extends Number>     //(无穷小 , Number]
 //只允许泛型为Number及Number子类的引用调用

 <? super Number>      //[Number , 无穷大)
 //只允许泛型为Number及Number父类的引用调用

 <? extends Comparable>
 //只允许泛型为实现Comparable接口的实现类的引用调用
```

**举例**`1`

```java
 class Creature { }
 class Person extends Creature { }
 class Man extends Person { }

 class PersonTest {
     public static <T extends Person> void test(T t){
         System.out.println(t);
     }

     public static void main(String[] args) {
         test(new Person());
         test(new Man());
         //The method test(T) in the type PersonTest is not
         //applicable for the arguments (Creature)
         test(new Creature());
     }
 }
```

**举例**`2`

```java
 public static void main(String[] args) {
     Collection<Integer> list1 = new ArrayList<Integer>();
     Collection<String> list2 = new ArrayList<String>();
     Collection<Number> list3 = new ArrayList<Number>();
     Collection<Object> list4 = new ArrayList<Object>();

     getElement1(list1);
     getElement1(list2);//报错
     getElement1(list3);
     getElement1(list4);//报错

     getElement2(list1);//报错
     getElement2(list2);//报错
     getElement2(list3);
     getElement2(list4);

 }

 // 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类
 public static void getElement1(Collection<? extends Number> coll){ }

 // 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类
 public static void getElement2(Collection<? super Number> coll){ }
```

**举例**`3`

```java
 public static void printCollection1(Collection<? extends Person> coll) {
     // Iterator只能用Iterator<?>或Iterator<? extends Person>
     Iterator<?> iterator = coll.iterator();
     while (iterator.hasNext()) {
         Person per = iterator.next();
         System.out.println(per);
     }
 }

 public static void printCollection2(Collection<? super Person> coll) {
     // Iterator只能用Iterator<?>或Iterator<? super Person>
     Iterator<?> iterator = coll.iterator();
     while (iterator.hasNext()) {
         Object obj = iterator.next();
         System.out.println(obj);
     }
 }
```

**举例**`4`

这两个测试案例展示了`Java`泛型中的两个重要概念：`? extends T`和`? super T`，它们分别表示上界通配符和下界通配符。

1. `? extends T`**<font style="color:#DF2A3F;">上界通配符</font>**  
   `? extends T`表示类型参数是`T`或`T`的子类。这种通配符用于读取操作，但不允许写入操作（除了`null`）

```java
@Test
public void test1(){
    List<Person> list2 = new ArrayList<Person>();
    List<? extends Person> list4 = null;

    list2.add(new Person());
    list4 = list2;

    // 读取：可以读
    Person p1 = list4.get(0);

    // 写入：除了 null 之外，不能写入
    list4.add(null);
    // list4.add(new Person()); // 编译错误
    // list4.add(new Student()); // 编译错误
}
```

**解释**：

- **读取操作**：`list4`是`List<? extends Person>`类型，表示它可以包含`Person`或`Person`的子类。因此，可以从`list4`中读取元素，并将其赋值给`Person`类型的变量。
- **写入操作**：由于`list4`的类型是`? extends Person`，编译器无法确定具体的类型（可能是`Person`、`Student`或其他`Person`的子类）。因此，不允许向`list4`中添加任何非`null`的元素，以避免类型不匹配。

2. `? super T`**<font style="color:#DF2A3F;">下界通配符</font>**  
   `? super T`表示类型参数是`T`或`T`的父类。这种通配符用于写入操作，但读取操作只能返回`Object`类型。

```java
@Test
public void test2(){
    List<Person> list2 = new ArrayList<Person>();
    List<? super Person> list5 = null;

    list2.add(new Person());
    list5 = list2;

    // 读取：可以实现，但只能返回 Object 类型
    Object obj = list5.get(0);

    // 写入：可以写入 Person 及 Person 子类的对象
    list5.add(new Person());
    list5.add(new Student());
}

```

**解释：**

- **读取操作**：`list5`是`List<? super Person>`类型，表示它可以包含`Person`或`Person`的父类。由于无法确定具体的父类类型，因此读取操作只能返回`Object`类型。
- **写入操作**：由于`list5`的类型是`? super Person`，编译器知道它可以包含`Person`或`Person`的父类。因此，可以向`list5`中添加`Person`或`Person`的子类对象，因为这些对象都可以赋值给`Person`或其父类。

### 泛型应用举例

**举例**`1`：**<font style="color:#DF2A3F;">泛型嵌套</font>**

```java
public static void main(String[] args) {
    HashMap<String, ArrayList<Citizen>> map = new HashMap<String, ArrayList<Citizen>>();
    ArrayList<Citizen> list = new ArrayList<Citizen>();
    list.add(new Citizen("赵又廷"));
    list.add(new Citizen("高圆圆"));
    list.add(new Citizen("瑞亚"));
    map.put("赵又廷", list);

    Set<Entry<String, ArrayList<Citizen>>> entrySet = map.entrySet();
    Iterator<Entry<String, ArrayList<Citizen>>> iterator = entrySet.iterator();
    while (iterator.hasNext()) {
        Entry<String, ArrayList<Citizen>> entry = iterator.next();
        String key = entry.getKey();
        ArrayList<Citizen> value = entry.getValue();
        System.out.println("户主：" + key);
        System.out.println("家庭成员：" + value);
    }
}
```

**举例**`2`：**<font style="color:#DF2A3F;">个人信息设计</font>**

用户在设计类的时候往往会使用类的关联关系，**例如**：一个人中可以定义一个信息的属性，但是一个人可能有各种各样的信息（如：联系方式、基本信息等），所以此信息属性的类型就可以通过泛型进行声明，然后只要设计相应的信息类即可。

```java
// 只有此接口的子类才是表示人的信息
interface Info{
}

// 表示联系方式
class Contact implements Info{
    // 联系地址
    private String address ;
    // 联系方式
    private String telephone ;
    // 邮政编码
    private String zipcode ;

    public Contact(String address,String telephone,String zipcode){
        this.address = address;
        this.telephone = telephone;
        this.zipcode = zipcode;
    }

    public void setAddress(String address){
        this.address = address ;
    }

    public void setTelephone(String telephone){
        this.telephone = telephone ;
    }

    public void setZipcode(String zipcode){
        this.zipcode = zipcode;
    }

    public String getAddress(){
        return this.address ;
    }

    public String getTelephone(){
        return this.telephone ;
    }

    public String getZipcode(){
        return this.zipcode;
    }

    @Override
    public String toString() {
        return "Contact [address=" + address + ", telephone=" + telephone
                + ", zipcode=" + zipcode + "]";
    }
}

class Introduction implements Info{
    // 姓名
    private String name ;
    // 性别
    private String sex ;
    // 年龄
    private int age ;

    public Introduction(String name,String sex,int age){
        this.name = name;
        this.sex = sex;
        this.age = age;
    }

    public void setName(String name){
        this.name = name ;
    }

    public void setSex(String sex){
        this.sex = sex ;
    }

    public void setAge(int age){
        this.age = age ;
    }

    public String getName(){
        return this.name ;
    }

    public String getSex(){
        return this.sex ;
    }

    public int getAge(){
        return this.age ;
    }

    @Override
    public String toString() {
        return "Introduction [name=" + name + ", sex=" + sex + ", age=" + age
                + "]";
    }
}

class Person<T extends Info>{
    private T info ;

    // 通过构造器设置信息属性内容
    public Person(T info){
        this.info = info;
    }

    public void setInfo(T info){
        this.info = info ;
    }

    public T getInfo(){
        return info ;
    }

    @Override
    public String toString() {
        return "Person [info=" + info + "]";
    }
}

public class GenericPerson{
    public static void main(String args[]){
        // 声明Person对象
        Person<Contact> per = null ;
        per = new Person<Contact>(new Contact("北京市","01088888888","102206")) ;
        System.out.println(per);

        // 声明Person对象
        Person<Introduction> per2 = null ;
        per2 = new Person<Introduction>(new Introduction("李雷","男",24));
        System.out.println(per2) ;
    }
}
```
