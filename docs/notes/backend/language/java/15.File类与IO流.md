---
title: File类与IO流
createTime: 2025/08/22 22:41:51
permalink: /language/java/xbz1gklc/
---
### `java.io.File`类的使用

#### 概述

- `File`类及各种流，都定义在`java.io`包下
- **<font style="color:#DF2A3F;">一个</font>**`**<font style="color:#DF2A3F;">File</font>**`**<font style="color:#DF2A3F;">对象代表硬盘或网络中可能存在的一个文件或者文件目录，与平台无关</font>**
- `**<font style="color:#DF2A3F;">File</font>**`**<font style="color:#DF2A3F;">能新建、删除、重命名文件和目录，但</font>**`**<font style="color:#DF2A3F;">File</font>**`**<font style="color:#DF2A3F;">不能访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流（</font>**`**File**`**对象可以作为参数传递给流的构造器\*\***<font style="color:#DF2A3F;">）</font>\*\*
- 想要在`Java`程序中表示一个真实存在的文件或目录，那么必须有一个`File`对象，**但是**`**Java**`**程序中的一个File对象，可能没有一个真实存在的文件或目录**

#### 构造器

- `public File(String pathname)`：以`pathname`为路径创建`File`对象，**可以是绝对路径或者相对路径，如果**`**pathname**`**是相对路径，则默认的当前路径在系统属性**`**user.dir**`**中存储**
- `public File(**String parent, String child**)`：以`parent`为父路径，`child`为子路径创建`File`对象
- `public File(**File parent, String child**)`：根据父`File`对象和子文件路径创建`File`对象

#### 关于路径

- **<font style="color:#DF2A3F;">绝对路径</font>**：从盘符开始的路径，这是**一个完整的路径**
- **<font style="color:#DF2A3F;">相对路径</font>**：相对于项目目录的路径
  - `**IDEA**`**中，**`**main**`**中的文件的相对路径，是相对于"\*\***<font style="color:#DF2A3F;">当前工程</font>\***\*"**
  - `**IDEA**`**中，单元测试方法中的文件的相对路径，是相对于"\*\***<font style="color:#DF2A3F;">当前</font>**`**<font style="color:#DF2A3F;">module</font>**`**"\*\*
- **测试：**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732676815201-72a1298a-728a-4b91-8483-a7109c221198.png)

```java
package io.github.weew12;

public class TestPath {
    public static void main(String[] args) {

        System.out.println(System.getProperty("user.dir"));
    }
}

```

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732676838124-e1857fab-1545-4f41-bc8c-6bb747ccb0bc.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732676880810-69a5be33-79ec-4715-8b15-353d9a7ced16.png)

```java
import org.junit.Test;

public class TestPath {
    @Test
    public void test1() {
        System.out.println(System.getProperty("user.dir"));
    }

}
```

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732676913283-83a16c44-0943-4d70-8f5e-2bc627e05fb1.png)

#### `File`使用举例

```java
import java.io.File;

public class FileObjectTest {
    public static void main(String[] args) {
        // 文件路径名
        String pathname = "D:\\aaa.txt";
        File file1 = new File(pathname);

        // 文件路径名
        String pathname2 = "D:\\aaa\\bbb.txt";
        File file2 = new File(pathname2);

        // 通过父路径和子路径字符串
        String parent = "d:\\aaa";
        String child = "bbb.txt";
        File file3 = new File(parent, child);

        // 通过父级File对象和子路径字符串
        File parentDir = new File("d:\\aaa");
        String childFile = "bbb.txt";
        File file4 = new File(parentDir, childFile);
    }

    @Test
    public void test01() throws IOException{
        // 绝对路径
        File f1 = new File("d:\\atguigu\\javase\\HelloIO.java");
        System.out.println("文件/目录的名称：" + f1.getName());
        System.out.println("文件/目录的构造路径名：" + f1.getPath());
        System.out.println("文件/目录的绝对路径名：" + f1.getAbsolutePath());
        System.out.println("文件/目录的父目录名：" + f1.getParent());
    }

    @Test
    public void test02()throws IOException{
        // 绝对路径，从根路径开始
        File f2 = new File("/HelloIO.java");
        System.out.println("文件/目录的名称：" + f2.getName());
        System.out.println("文件/目录的构造路径名：" + f2.getPath());
        System.out.println("文件/目录的绝对路径名：" + f2.getAbsolutePath());
        System.out.println("文件/目录的父目录名：" + f2.getParent());
    }

    @Test
    public void test03() throws IOException {
        // 相对路径
        File f3 = new File("HelloIO.java");
        System.out.println("user.dir =" + System.getProperty("user.dir"));
        System.out.println("文件/目录的名称：" + f3.getName());
        System.out.println("文件/目录的构造路径名：" + f3.getPath());
        System.out.println("文件/目录的绝对路径名：" + f3.getAbsolutePath());
        System.out.println("文件/目录的父目录名：" + f3.getParent());
    }

    @Test
    public void test04() throws IOException{
        // 相对路径
        File f5 = new File("HelloIO.java");
        System.out.println("user.dir =" + System.getProperty("user.dir"));
        System.out.println("文件/目录的名称：" + f5.getName());
        System.out.println("文件/目录的构造路径名：" + f5.getPath());
        System.out.println("文件/目录的绝对路径名：" + f5.getAbsolutePath());
        System.out.println("文件/目录的父目录名：" + f5.getParent());
    }
}
```

**<font style="color:#DF2A3F;">注意：</font>**

- **无论该路径下是否存在文件或者目录，都不影响**`**File**`**对象的创建**
- `windows`路径分隔符使用`\`，而`**Java**`**程序中的**`**\**`**表示转义字符**。在`Windows`中表示路径，需要用`\`或直接使用`/`，`Java`程序支持将`/`当成平台无关的路径分隔符。**也可直接使用**`**File.separator**`**常量值表示**

```java
File file2 = new File("d:" + File.separator + "atguigu" + File.separator + "info.txt");
```

- **当构造路径是绝对路径时，那么**`**getPath**`**和**`**getAbsolutePath**`**结果一样** ; **当构造路径是相对路径时，**`**getAbsolutePath的路径**`**=**`**user.dir的路径**`**+**`**构造路径**`

#### <font style="color:#DF2A3F;">常用方法</font>

##### 获取<font style="color:#DF2A3F;">文件和目录基本信息</font>

- `public String getName()`：获取**名称**
- `public String getPath()`：获取**路径**
- `public String getAbsolutePath()`：获取**绝对路径**
- `public File getAbsoluteFile()`：获取**绝对路径**表示的文件
- `public String getParent()`：获取**上层文件目录路径**，若无返回`null`
- `public long length()`：获取**文件长度**（字节数），<font style="color:#DF2A3F;">不能获取目录的长度</font>
- `public long lastModified()`：获取**最后一次的修改时间**（<font style="color:#DF2A3F;">毫秒值</font>）

<font style="color:#DF2A3F;">如果</font>`<font style="color:#DF2A3F;">File</font>`<font style="color:#DF2A3F;">对象代表的文件或目录存在，则</font>`<font style="color:#DF2A3F;">File</font>`<font style="color:#DF2A3F;">对象实例初始化时，就会用硬盘中对应文件或目录的属性信息（时间、类型等）为</font>`<font style="color:#DF2A3F;">File</font>`<font style="color:#DF2A3F;">对象的属性赋值；否则，除了路径和名称，</font>`<font style="color:#DF2A3F;">File</font>`<font style="color:#DF2A3F;">对象的其他属性将会保留默认值。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378544920-7cd12c69-b13e-4c4e-a273-40f3d4850b02.png)

**测试代码：**

```java
import java.io.File;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;

public class FileInfoMethods {
    public static void main(String[] args) {
        File file = new File("F:/aaa/FileTest.java");
        System.out.println("文件构造路径 " + file.getPath());
        System.out.println("文件名称 " + file.getName());
        System.out.println("文件长度" + file.length());
        System.out.println("文件最后修改时间" + LocalDateTime.ofInstant(Instant.ofEpochMilli(file.lastModified()), ZoneId.of("Asia/Shanghai")));

        System.out.println();

        File file2 = new File("F:/aaa");
        System.out.println("目录构造路径 " + file2.getPath());
        System.out.println("目录名称 " + file2.getName());
        System.out.println("目录长度" + file2.length());
        System.out.println("目录最后修改时间" + LocalDateTime.ofInstant(Instant.ofEpochMilli(file2.lastModified()), ZoneId.of("Asia/Shanghai")));
    }
}
```

**输出结果：**

```bash
文件构造路径 F:\aaa\FileTest.java
文件名称 FileTest.java
文件长度465
文件最后修改时间2024-12-04T11:04:02.147

目录构造路径 F:\aaa
目录名称 aaa
目录长度0
目录最后修改时间2024-12-04T11:04:38.326
```

##### 列出<font style="color:#DF2A3F;">目录的下一级</font>

- `public String[] list()`：返回一个`**String**`**数组**，表示该`File`目录中的**所有子文件或目录**
- `public File[] listFiles()`：返回一个`**File**`**数组**，表示该File目录中的**所有的子文件或目录**

**测试代码：**

```java
import java.io.File;
import java.util.Arrays;

public class DirListFiles {
    public static void main(String[] args) {
        File file = new File("F:/aaa");
        // list()
        String[] list = file.list();
        System.out.println(Arrays.toString(list));
        // listFiles()
        File[] files = file.listFiles();
        System.out.println(files);
    }
}
```

**输出结果：**

```bash
[FileTest.java]
[Ljava.io.File;@7291c18f
```

##### `File`类的<font style="color:#DF2A3F;">重命名功能</font>

- `public boolean renameTo(File dest)`：把文件**重命名**为指定的文件路径

**测试代码：**

```java
import java.io.File;

public class FileRename {
    public static void main(String[] args) {
        File renameFile = new File("F:/aaa/FileTest.java");
        File toRenameFile = new File("F:/aaa/FileTest1.java");
        boolean success = renameFile.renameTo(toRenameFile);
        System.out.println(success ? "重命名成功" : "重命名失败");
    }
}
```

##### <font style="color:#DF2A3F;">判断功能</font>的方法

- `public boolean exists()`：此`File`表示的**文件或目录是否实际存在**
- `public boolean isDirectory()`：此`File`表示的**是否为目录**
- `public boolean isFile()`：此`File`表示的**是否为文件**
- `public boolean canRead()`：判断**是否可读**
- `public boolean canWrite()`：判断**是否可写**
- `public boolean isHidden()`：判断**是否隐藏**

**测试代码：**

```java
import java.io.File;

public class FileIs {
    public static void main(String[] args) {
        // 文件
        File file1 = new File("F:/aaa/FileTest1.java");
        // 目录
        File dir1 = new File("F:/aaa");

        // 文件或目录是否存在
        System.out.println(file1.getName() + (file1.exists() ? "存在" : "不存在"));
        System.out.println(dir1.getName() + (dir1.exists() ? "存在" : "不存在"));
        // 是否为目录
        System.out.println(file1.getName() + (file1.isDirectory() ? "是目录" : "不是目录"));
        System.out.println(dir1.getName() + (dir1.isDirectory() ? "是目录" : "不是目录"));
        // 是否为文件
        System.out.println(file1.getName() + (file1.isFile() ? "是文件" : "不是文件"));
        System.out.println(dir1.getName() + (dir1.isFile() ? "是文件" : "不是文件"));
        // 是否可读
        System.out.println(file1.getName() + (file1.canRead() ? "可读" : "不可读"));
        System.out.println(dir1.getName() + (dir1.canRead() ? "可读" : "不可读"));
        // 是否可写
        System.out.println(file1.getName() + (file1.canWrite() ? "可写" : "不可写"));
        System.out.println(dir1.getName() + (dir1.canWrite() ? "可写" : "不可写"));
        // 是否隐藏
        System.out.println(file1.getName() + (file1.isHidden() ? "是隐藏文件" : "不是隐藏文件"));
        System.out.println(dir1.getName() + (dir1.isHidden() ? "是隐藏文件" : "不是隐藏文件"));

        System.out.println("==========================");

        // 不存在文件
        File file2 = new File("F:/aaa/FileTest2.java");
        System.out.println("file2.exists(): " + file2.exists());
        System.out.println("file2.isFile(): " + file2.isFile());
        System.out.println("file2.isDirectory(): " + file2.isDirectory());

        // 不存在目录
        File dir2 = new File("F:/bbb");
        System.out.println("dir2.exists(): " + dir2.exists());
        System.out.println("dir2.isFile(): " + dir2.isFile());
        System.out.println("dir2.isDirectory(): " + dir2.isDirectory());
    }
}

```

**输出结果：**

```plain
FileTest1.java存在
aaa存在
FileTest1.java不是目录
aaa是目录
FileTest1.java是文件
aaa不是文件
FileTest1.java可读
aaa可读
FileTest1.java可写
aaa可写
FileTest1.java不是隐藏文件
aaa不是隐藏文件
==========================
file2.exists(): false
file2.isFile(): false
file2.isDirectory(): false
dir2.exists(): false
dir2.isFile(): false
dir2.isDirectory(): false
```

##### <font style="color:#DF2A3F;">创建、删除</font>功能

- `public boolean createNewFile()`：**创建文件**，若文件存在则不创建并返回`false`
- `public boolean mkdir()`：**<font style="color:#DF2A3F;">若目录存在就不创建；若目录的上层目录不存在也不创建</font>**
- `public boolean mkdirs()`：**<font style="color:#DF2A3F;">创建文件目录；若上层文件目录不存在则一并创建</font>**
- `public boolean delete()`：删除文件或文件夹
  - **<font style="color:#DF2A3F;">删除注意事项</font>**<font style="color:#DF2A3F;">：</font>
    - `**<font style="color:#DF2A3F;">Java</font>**`**<font style="color:#DF2A3F;">中的删除不走回收站</font>**
    - **<font style="color:#DF2A3F;">要删除一个目录，请注意该目录内不能包含文件或者目录</font>**

**测试代码：**

```java
import java.io.File;
import java.io.IOException;

public class FileCreateAndDelete {
    public static void main(String[] args) throws IOException {
        // 文件创建 createNewFile
        File createFile1 = new File("F:/aaa/FileTest1.java");
        File createFile2 = new File("F:/aaa/FileTest2.java");
        System.out.println(createFile1.getName() + (createFile1.exists() ? "文件存在" : "文件不存在"));
        System.out.println(createFile1.getName() + (createFile1.createNewFile() ? "文件创建成功" : "文件创建失败"));
        System.out.println(createFile2.getName() + (createFile2.exists() ? "文件存在" : "文件不存在"));
        System.out.println(createFile2.getName() + (createFile2.createNewFile() ? "文件创建成功" : "文件创建失败"));
        System.out.println();
        // 目录创建 mkdir
        File dir1 = new File("F:/aaa");
        File dir2 = new File("F:/bbb");
        System.out.println(dir1.getName() + (dir1.exists() ? "目录存在" : "目录不存在"));
        System.out.println(dir1.getName() + (dir1.mkdir() ? "目录创建成功" : "目录创建失败"));
        System.out.println(dir2.getName() + (dir2.exists() ? "目录存在" : "目录不存在"));
        System.out.println(dir2.getName() + (dir2.mkdir() ? "目录创建成功" : "目录创建失败"));
        System.out.println();
        // 创建多级目录 mkdirs
        File dir3 = new File("F:/aaa/bbb");
        System.out.println(dir3.getAbsolutePath() + (dir3.exists() ? "目录存在" : "目录不存在"));
        System.out.println(dir3.getAbsolutePath() + (dir3.mkdirs() ? "多级目录创建成功" : "多级目录创建失败"));
        System.out.println();
        // 文件删除
        System.out.println(createFile2.getName() + (createFile2.exists() ? "文件存在" : "文件不存在"));
        boolean delete = createFile2.delete();
        System.out.println(delete ? (createFile2.getName() + "删除成功") : (createFile2.getName() + "删除失败"));
        System.out.println(createFile2.getName() + (createFile2.exists() ? "文件存在" : "文件不存在"));
        System.out.println();
        // 目录删除
        System.out.println(dir2.getAbsolutePath() + (dir2.exists() ? "目录存在" : "目录不存在"));
        System.out.println((dir2.list().length > 0) ? "目录不为空" : "目录为空");
        boolean delete1 = dir2.delete();
        System.out.println((delete1 ? (dir2.getAbsolutePath() + "删除成功") : (dir2.getAbsolutePath() + "删除失败")));
    }
}
```

**输出结果：**

```plain
FileTest1.java文件存在
FileTest1.java文件创建失败
FileTest2.java文件不存在
FileTest2.java文件创建成功

aaa目录存在
aaa目录创建失败
bbb目录不存在
bbb目录创建成功

F:\aaa\bbb目录存在
F:\aaa\bbb多级目录创建失败

FileTest2.java文件存在
FileTest2.java删除成功
FileTest2.java文件不存在

F:\bbb目录存在
目录为空
F:\bbb删除成功
```

##### 练习

判断指定目录下是否有后缀名为`.jpg`的文件，如果就输出该文件名称

```java
public class FindFileTest {
    /*
     * File类提供了两个文件过滤器方法
     * public String[] list(FilenameFilter filter)
     * public File[] listFiles(FileFilter filter)
     */
    @Test
    public void test3(){
        File srcFile = new File("d:\\code");

        File[] subFiles = srcFile.listFiles(new FilenameFilter() {

            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(".jpg");
            }
        });

        for(File file : subFiles){
            System.out.println(file.getAbsolutePath());
        }
    }

}
```

### IO流原理及流的分类

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733216663237-1399e810-153b-4c5d-91ff-11a7830dda04.png)

#### `Java IO`原理

- `**<font style="color:#DF2A3F;">Java</font>**`**<font style="color:#DF2A3F;">程序中，对于数据的输入/输出操作以"流(</font>**`**<font style="color:#DF2A3F;">stream</font>**`**<font style="color:#DF2A3F;">)"的方式进行，可以看做是数据的流动</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378606159-3a0bc24f-8bb3-45a0-bae4-01f99adbe677.png)

- `**I/O**`**流中的**`**I/O**`**是**`**Input/Output**`**的缩写**，`**<font style="color:#DF2A3F;">I/O</font>**`**<font style="color:#DF2A3F;">技术用于处理设备之间的数据传输</font>**
  - 如：读/写文件、网络通讯等
  - **输入**`**input**`**：\*\***<font style="color:#DF2A3F;">读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中</font>\*\*
  - **输出**`**output**`**：\*\***<font style="color:#DF2A3F;">将程序（内存）数据输出到磁盘、光盘等存储设备中</font>\*\*

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378626609-9aab2cdc-aa12-4f05-89c4-dfba228421da.png)

#### 流的分类

`**<font style="color:#DF2A3F;">java.io</font>**`**<font style="color:#DF2A3F;">包提供了各种“流”类和接口，用于获取不同数据，并通过标准方法输入或输出数据 </font>**

- **<font style="color:#DF2A3F;">按数据的流向</font>**不同分为：**输入流**和**输出流**
  - **输入流**：把数据<font style="color:#DF2A3F;">从其他设备上读取到内存中</font>的流
    - 以`**InputStream**`、`**Reader**`结尾
  - **输出流** ：把<font style="color:#DF2A3F;">数据从内存中写出到其他设备上</font>的流
    - 以`**OutputStream**`、`**Writer**`结尾
- **<font style="color:#DF2A3F;">按操作数据单位</font>**的不同分为：**字节流**（`**8bit**`）和**字符流**（`**16bit**`）
  - **字节流** ：以**字节为单位**，读写数据的流
    - 以`InputStream`、`OutputStream`结尾
  - **字符流** ：以**字符为单位**，读写数据的流
    - 以`Reader`、`Writer`结尾
- **<font style="color:#DF2A3F;">根据IO流的角色</font>**不同分为：**节点流**和**处理流**
  - **节点流**：**<font style="color:#DF2A3F;">直接从数据源或目的地读写数据</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378737246-78ff19b3-386d-43a3-a307-35cf736bb101.png)

    - **处理流**：**<font style="color:#DF2A3F;">不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上</font>**，**<font style="color:#DF2A3F;">通过对数据的处理为程序提供更为强大的读写功能</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378745393-f85f8ee8-1da8-4a6a-9f33-fb4081baa6e2.png)

**小结：图解**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378750808-7d7414d5-0d4d-4810-b7b2-3626a0afa039.png)

#### 流的`API`

- `Java`的`IO`流共涉及`40`多个类，实际上非常规则，都是从如下`4`个抽象基类派生的

|                  （抽象基类）                  |    输入流     |     输出流     |
| :--------------------------------------------: | :-----------: | :------------: |
| **<font style="color:#DF2A3F;">字节流</font>** | `InputStream` | `OutputStream` |
| **<font style="color:#DF2A3F;">字符流</font>** |   `Reader`    |    `Writer`    |

- **<font style="color:#DF2A3F;">由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378758142-21d392ae-812f-4467-b4fb-496d116e6e0c.png)

##### 常用的节点流

- **<font style="color:#DF2A3F;">文件流</font>**：`FileInputStream``FileOutputStrean``FileReader``FileWriter`
- **<font style="color:#DF2A3F;">字节/字符数组流</font>**：`ByteArrayInputStream``ByteArrayOutputStream``CharArrayReader``CharArrayWriter`（**对数组进行处理的节点流，对应的不再是文件，而是内存中的一个数组**）

##### 常用的处理流

- **<font style="color:#DF2A3F;">缓冲流</font>**：`BufferedInputStream``BufferedOutputStream``BufferedReader``BufferedWriter`
  - 作用：**增加缓冲功能，避免频繁读写硬盘，进而提升读写效率**
- **<font style="color:#DF2A3F;">转换流</font>**：`InputStreamReader``OutputStreamWriter`
  - 作用：**实现字节流和字符流之间的转换**
- **<font style="color:#DF2A3F;">对象流</font>**：`ObjectInputStream`、`ObjectOutputStream`
  - 作用：**<font style="color:#DF2A3F;">提供直接读写</font>**`**<font style="color:#DF2A3F;">Java</font>**`**<font style="color:#DF2A3F;">对象功能</font>**

### 节点流`1`：`FileReader`\`FileWriter`

#### `Reader`与`Writer`

`**<font style="color:#DF2A3F;">Java</font>**`**<font style="color:#DF2A3F;">提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件</font>\*\***。不能操作图片、视频等非文本文件**。**常见的文本文件格式\*\*：`.txt``.java``.c``.cpp``.py`等。

**<font style="color:#DF2A3F;">注意</font>\*\***：**`**.doc**``**.xls**``**.ppt**`**这些都不是文本文件\*\*

##### <font style="color:#DF2A3F;">字符输入流</font>：`Reader`

`java.io.Reader`抽象类是表示用于读取字符流的所有类的父类，**可以读取字符信息到内存中**，<font style="color:#DF2A3F;">它定义了字符输入流的基本共性功能方法</font>

- `public int read()`：**从输入流读取**`**1**`**个字符。 虽然读取了**`**1**`**个字符，但是会自动提升为**`**int**`**类型，返回该字符的**`**Unicode**`**编码值。如果已经到达流末尾了，则返回**`**-1**`\*\*\*\*
- `public int read(char[] cbuf)`：**从输入流中读取一些字符，并将它们存储到字符数组**`**cbuf**`**。**每次最多读取`cbuf.length`个字符，返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回`-1`
- `public int read(char[] cbuf,int off,int len)`：**从输入流中读取一些字符，并将它们存储到字符数组**`**cbuf**`**中，从**`**cbuf[off]**`**开始的位置存储，每次最多读取**`**len**`**个字符**。返回实际读取的字符个数，如果已经到达流末尾，没有数据可读，则返回`-1`
- `public void close()`：**关闭此流并释放与此流相关联的任何系统资源**

**<font style="color:#DF2A3F;">注意：当完成流的操作时，必须调用</font>**`**<font style="color:#DF2A3F;">close()</font>**`**<font style="color:#DF2A3F;">方法，释放系统资源，否则会造成内存泄漏</font>**

##### <font style="color:#DF2A3F;">字符输出流</font>：`Writer`

`java.io.Writer`抽象类是表示用于写出字符流的所有类的超类，**将指定的字符信息写出到目的地**，<font style="color:#DF2A3F;">它定义了字符输出流的基本共性功能方法</font>

- `public void write(int c)`：**写出单个字符**
- `public void write(char[] cbuf)`：**写出字符数组**
- `public void write(char[] cbuf, int off, int len)`：**写出字符数组的某一部分**，`off`：数组的开始索引，`len`：写出的字符个数
- `public void write(String str)`：**写出字符串**
- `public void write(String str, int off, int len)`：**写出字符串的某一部分**，`off`：字符串的开始索引，`len`：写出的字符个数
- `public void flush()`：**刷新该流的缓冲**
- `public void close()`：**关闭此流**

**<font style="color:#DF2A3F;">注意：当完成流的操作时，必须调用</font>**`**<font style="color:#DF2A3F;">close()</font>**`**<font style="color:#DF2A3F;">方法，释放系统资源，否则会造成内存泄漏 </font>**

#### `FileReader`与`FileWriter`

##### `FileReader`

`java.io.FileReader`类**<font style="color:#DF2A3F;">用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区</font>**

- `FileReader(File file)`：创建一个新的`FileReader`，**给定要读取的**`**File**`**对象**
- `FileReader(String fileName)`：创建一个新的 `FileReader`，**给定要读取的文件名称**

**案例**：读取`hello.txt`文件中的字符数据，并显示在控制台上

```java
import org.junit.Test;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class FileReaderTest {
    /**
     * 读取方式1
     */
    @Test
    public void test1() throws IOException {
        // 读取方式1
        // 1. 创建File对象 对应某个磁盘上的文件
        File file = new File("hello.txt");
        // 2. 创建FileReader 将File作为参数初始化
        FileReader fileReader = new FileReader(file);

        // 3. 读取文件中的数据
        int data;
        // 每次读取一个字符 返回-1表示到达文件末尾
        while ((data = fileReader.read()) != -1) {
            System.out.println(((char) data));
        }
        // 4. 关闭相关流资源 避免出现内存泄露
        fileReader.close();
    }

    /**
     * 读取方式2
     * 使用try-catch-finally结构
     */
    @Test
    public void test2() {
        // 读取方式1
        // 1. 创建File对象 对应某个磁盘上的文件
        File file = new File("hello.txt");
        FileReader fileReader = null;
        try {
            // 2. 创建FileReader 将File作为参数初始化
            fileReader = new FileReader(file);
            // 3. 读取文件中的数据
            int data;
            // 每次读取一个字符 返回-1表示到达文件末尾
            while ((data = fileReader.read()) != -1) {
                System.out.println(((char) data));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 关闭相关流资源 避免出现内存泄露
            try {
                if (fileReader != null) {
                    fileReader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 读取方式3
     * 使用read(char[] buff) 每次读取多个字符
     */
    @Test
    public void test3() {
        // 读取方式1
        // 1. 创建File对象 对应某个磁盘上的文件
        File file = new File("hello.txt");
        FileReader fileReader = null;
        try {
            // 2. 创建FileReader 将File作为参数初始化
            fileReader = new FileReader(file);
            // 字符数组 存储读取的字符
            char[] chars = new char[5];
            // 3. 读取文件中的数据
            int len;
            // 一次读取chars.length 个数的字符 返回每次读取的字符个数
            while ((len = fileReader.read(chars)) != -1) {
                String s = new String(chars, 0, len);
                System.out.println(s);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 关闭相关流资源 避免出现内存泄露
            try {
                if (fileReader != null) {
                    fileReader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

不同实现方式的类比：

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378766214-7c2c892a-869c-4961-af5c-bc4315691e55.png)

##### `FileWriter`

`java.io.FileWriter`类**<font style="color:#DF2A3F;">用于写出字符到文件，构造时使用系统默认的字符编码和默认字节缓冲区</font>**

- `FileWriter(File file)`：创建一个新的`FileWriter`，**给定要读取的**`**File**`**对象**
- `FileWriter(String fileName)`：创建一个新的`FileWriter`，**给定要读取的文件的名称**
- `FileWriter(File file,boolean append)`：**<font style="color:#DF2A3F;">创建一个新的</font>**`**<font style="color:#DF2A3F;">FileWriter</font>**`**<font style="color:#DF2A3F;">，指明是否在现有文件末尾追加内容</font>**

**<font style="color:#DF2A3F;">案例：</font>**

```java
import org.junit.Test;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class FileWriterTest {
    @Test
    public void test1() throws IOException {
        // 指定文件
        File file = new File("hello.txt");
        // 创建FileWriter对象
        FileWriter fileWriter = new FileWriter(file);
        // write(int c)
        fileWriter.write(97);
        fileWriter.write('b');
        fileWriter.write('C');
        fileWriter.write(30000);
        fileWriter.write('\n');
        // write(char[] buff)
        char[] cBuff = {'a', 'a', 'a'};
        fileWriter.write(cBuff);
        fileWriter.write('\n');
        // write(char[] buff, int off, int len)
        char[] cBuff2 = new char[10];
        "hello world!".getChars(6, 12, cBuff2, 0);
        fileWriter.write(cBuff2, 0, 5);
        fileWriter.write('\n');
        // write(String str, int off, int len)
        fileWriter.write(new String("hello world!"), 0, 5);
        // 关闭资源
        fileWriter.close();
    }

    @Test
    public void test2() {
        // 指定文件
        File file = new File("hello.txt");
        // 创建FileWriter对象
        FileWriter fileWriter = null;
        try {
            fileWriter = new FileWriter(file);
            // write(int c)
            fileWriter.write(97);
            fileWriter.write('b');
            fileWriter.write('C');
            fileWriter.write(30000);
            fileWriter.write('\n');
            // write(char[] buff)
            char[] cBuff = {'a', 'a', 'a'};
            fileWriter.write(cBuff);
            fileWriter.write('\n');
            // write(char[] buff, int off, int len)
            char[] cBuff2 = new char[10];
            "hello world!".getChars(6, 12, cBuff2, 0);
            fileWriter.write(cBuff2, 0, 5);
            fileWriter.write('\n');
            // write(String str, int off, int len)
            fileWriter.write(new String("hello world!"), 0, 5);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            try {
                if (fileWriter != null) {
                    fileWriter.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

##### 小结

- **<font style="color:#DF2A3F;">因为出现流资源的调用，为了避免内存泄漏，需要使用</font>**`**<font style="color:#DF2A3F;">try-catch-finally</font>**`**<font style="color:#DF2A3F;">处理异常</font>**
- **对于\*\***<font style="color:#DF2A3F;">输入流</font>\***\*来说，**`**File**`**类的对象必须在物理磁盘上存在，否则执行就会报**`**FileNotFoundException**`**；如果传入的是一个目录则会报**`**IOException**`**异常**
- **对于\*\***<font style="color:#DF2A3F;">输出流</font>\***\*来说，**`**File**`**类的对象是可以不存在的**
  - 如果`File`类的对象不存在，则可以在输出的过程中自动创建`File`类的对象
  - 如果`File`类的对象存在
    - <font style="color:#DF2A3F;">如果调用</font>`<font style="color:#DF2A3F;">FileWriter(File file)</font>`<font style="color:#DF2A3F;">或</font>`<font style="color:#DF2A3F;">FileWriter(File file,false)</font>`<font style="color:#DF2A3F;">，输出时会新建</font>`<font style="color:#DF2A3F;">File</font>`<font style="color:#DF2A3F;">文件覆盖已有的文件</font>
    - **<font style="color:#DF2A3F;">如果调用</font>**`**<font style="color:#DF2A3F;">FileWriter(File file,true)</font>**`**<font style="color:#DF2A3F;">构造器，则在现有的文件末尾追加写出内容</font>**

#### 关于`flush`刷新

**<font style="color:#DF2A3F;">因为内置缓冲区的原因，如果</font>**`**<font style="color:#DF2A3F;">FileWriter</font>**`**<font style="color:#DF2A3F;">不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要</font>**`**<font style="color:#DF2A3F;">flush()</font>**`**<font style="color:#DF2A3F;">方法了</font>**

- `flush()`：**刷新缓冲区，\*\***<font style="color:#DF2A3F;">流对象可以继续使用</font>\*\*
- `close()`：**先刷新缓冲区，然后通知系统释放资源，\*\***<font style="color:#DF2A3F;">流对象不可以再被使用了</font>\*\*

**<font style="color:#DF2A3F;">注意</font>\*\***：即便是**`**flush()**`**方法写出了数据，操作的最后还是要调用**`**close**`**方法，释放系统资源\*\*

**案例：**

```java
public class FWWriteFlush {
    //注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式
    @Test
    public void test() throws IOException {
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter("fw.txt");
        // 写出数据，通过flush
        // 写出第1个字符
        fw.write('刷');
        fw.flush();
        // 继续写出第2个字符，写出成功
        fw.write('新');
        fw.flush();

        // 写出数据，通过close
        // 写出第1个字符
        fw.write('关');
        fw.close();
        // 继续写出第2个字符,【报错】java.io.IOException: Stream closed
        fw.write('闭');
        fw.close();
    }
}
```

### 节点流`2`：`FileInputStream`\`FileOutputStream`

**<font style="color:#DF2A3F;">如果读取或写出的数据是非文本文件，则</font>**`**<font style="color:#DF2A3F;">Reader</font>**`**<font style="color:#DF2A3F;">、</font>**`**<font style="color:#DF2A3F;">Writer</font>**`**<font style="color:#DF2A3F;">就无能为力了，必须使用字节流</font>**

#### `InputStream`和`OutputStream`

##### <font style="color:#DF2A3F;">字节输入流</font>：`InputStream`

`java.io.InputStream`抽象类是表示字节输入流的所有类的超类，**可以读取字节信息到内存中**。<font style="color:#DF2A3F;">它定义了字节输入流的基本共性功能方法</font>

- `public int read()`：**从输入流读取一个字节，返回读取的字节值。虽然读取了一个字节，但是会自动提升为**`**int**`**类型。如果已经到达流末尾，没有数据可读，则返回**`**-1**`
- `public int read(byte[] b)`：**从输入流中读取一些字节数，并将它们存储到字节数组**`**b**`**中**，**每次最多读取**`**b.length**`**个字节**，返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回`-1`
- `public int read(byte[] b,int off,int len)`：**从输入流中读取一些字节数，并将它们存储到字节数组**`**b**`**中，从**`**b[off]**`**开始存储，每次最多读取**`**len**`**个字节**，返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回`-1`
- `public void close()`：**关闭此输入流并释放与此流相关联的任何系统资源**

**<font style="color:#DF2A3F;">说明</font>\*\***：**`**close()**`**方法，当完成流的操作时，必须调用此方法，释放系统资源。\*\*

##### <font style="color:#DF2A3F;">字节输出流</font>：`OutputStream`

`java.io.OutputStream`抽象类是表示字节输出流的所有类的超类，**将指定的字节信息写出到目的地**，<font style="color:#DF2A3F;">它定义了字节输出流的基本共性功能方法</font>

- `public void write(int b)`：**将指定的字节写入输出流。\*\***<font style="color:#DF2A3F;">虽然参数为</font>**`**<font style="color:#DF2A3F;">int</font>**`**<font style="color:#DF2A3F;">类型</font>**`**<font style="color:#DF2A3F;">4</font>**`**<font style="color:#DF2A3F;">个字节，但是只会保留一个字节的信息写出</font>\*\*
- `public void write(byte[] b)`：**将**`**b.length**`**字节从指定的字节数组写入输出流**
- `public void write(byte[] b, int off, int len)`：**从指定的字节数组写入**`**len**`**字节，从偏移量**`**off**`**开始输出到此输出流**
- `public void flush()`：**刷新此输出流并强制任何缓冲的输出字节被写出**
- `public void close()`：**关闭此输出流并释放与此流相关联的任何系统资源**

**<font style="color:#DF2A3F;">说明</font>\*\***：**`**close()**`**方法，当完成流的操作时，必须调用此方法，释放系统资源。\*\*

#### `FileInputStream`与`FileOutputStream`

##### `FileInputStream`

`java.io.FileInputStream`类是文件输入流，**从文件中读取字节**

- `FileInputStream(File file)`：**通过打开与实际文件的连接来创建一个**`**FileInputStream**`**，该文件由文件系统中的**`**File**`**对象**`**file**`**命名**
- `FileInputStream(String name)`：**通过打开与实际文件的连接来创建一个**`**FileInputStream**`**，该文件由文件系统中的路径名**`**name**`**命名**

**举例：**

`read.txt`文件中的内容：`abcde`，使用`FileInputStream`读取文件内容。

```java
import org.junit.Test;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileInputStreamTest {
    /**
     * 读取方式1
     */
    @Test
    public void test1() throws IOException {
        // 使用File对象创建流对象
        File file = new File("read.txt");
        FileInputStream fileInputStream = new FileInputStream(file);
        // 读取数据 返回1个字节
        int read = fileInputStream.read();
        System.out.println(((char) read));
        read = fileInputStream.read();
        System.out.println(((char) read));
        read = fileInputStream.read();
        System.out.println(((char) read));
        read = fileInputStream.read();
        System.out.println(((char) read));
        read = fileInputStream.read();
        System.out.println(((char) read));
        // 读取到末尾 返回-1
        read = fileInputStream.read();
        System.out.println(read);
        // 关闭资源
        fileInputStream.close();
    }

    /**
     * 读取方式2
     */
    @Test
    public void test2() throws IOException {
        // 使用文件名创建流对象
        FileInputStream fileInputStream = new FileInputStream("read.txt");
        // 定义变量 保存数据
        int read;
        // 循环读取到末尾
        while ((read = fileInputStream.read()) != -1) {
            System.out.println(((char) read));
        }
        // 关闭资源
        fileInputStream.close();
    }

    /**
     * 读取方式3
     */
    @Test
    public void test3() throws IOException {
        // 使用文件名创建流对象
        FileInputStream fileInputStream = new FileInputStream("read.txt");
        // 存储每次读取的字节数
        int len;
        // 存储读取出来的字节
        byte[] b = new byte[3];
        // 循环读取
        while ((len = fileInputStream.read(b)) != -1) {
            // 字节数组构造字符串 并输出
            System.out.println(new String(b, 0, len));
        }
        // 关闭资源
        fileInputStream.close();
    }
}

```

**输出**`**1**`**：**

```bash
a
b
c
d
e
-1
```

**输出**`**2**`**：**

```bash
a
b
c
d
e
```

**输出**`**3**`**：**

```bash
abc
de
```

##### `FileOutputStream`

`java.io.FileOutputStream`类是文件输出流，**用于将字节数据写出到文件**

- `public FileOutputStream(File file)`：**创建文件输出流，写出到指定**`**File**`**对象表示的文件**
- `public FileOutputStream(String name)`：**创建文件输出流，写出到指定**`**name**`**表示的文件**
- `public FileOutputStream(File file, **boolean append**)`：**创建文件输出流，指明是否在现有文件\*\***<font style="color:#DF2A3F;">末尾追加内容</font>\*\*

**举例：**

```java
import org.junit.Test;
import java.io.*;

public class FileOutputStreamTest {
    /**
     * 写出方式1    单个写出
     * 正规写法：应该使用try-catch-finally处理异常
     */
    @Test
    public void test1() throws IOException {
        // 使用File创建流对象
        File file = new File("write.txt");
        FileOutputStream fileOutputStream = new FileOutputStream(file);
        // 写出数据
        fileOutputStream.write(97);
        fileOutputStream.write(98);
        fileOutputStream.write(99);
        // 关闭资源
        fileOutputStream.close();
    }

    /**
     * 写出方式2    多个写出 指定位置
     */
    @Test
    public void test2() throws IOException {
        // 使用文件名创建流对象
        FileOutputStream fileOutputStream = new FileOutputStream("write.txt");
        // 字符串转为字节数组
        byte[] bytes = "abcde".getBytes();
        // 写出从索引2开始的两个字节: 实际写出的是cd两个字符
        fileOutputStream.write(bytes, 2, 2);
        // 关闭资源
        fileOutputStream.close();
    }

    /**
     * 写出方式3    追加写出
     */
    @Test
    public void test3() throws IOException {
        // 使用文件名创建流对象
        FileOutputStream fileOutputStream = new FileOutputStream("write.txt", true);
        // 字符串转为字节数组
        byte[] bytes = "abcde".getBytes();
        // 写出从索引2开始的两个字节: 实际写出的是cd两个字符
        fileOutputStream.write(bytes);
        // 关闭资源
        fileOutputStream.close();
    }

    /**
     * 利用FileInputStream 和 FileOutputStream 实现文件复制
     */
    @Test
    public void fileCopyTest() {
        FileInputStream fis = null;
        FileOutputStream fos = null;

        // 1. 造文件 造流
        try {
            fis = new FileInputStream("read.txt");
            fos = new FileOutputStream("read-copy.txt");
            // 2. 复制操作（读、写）
            byte[] buffer = new byte[1024];
            // 每次读取的字节数
            int len;
            while ((len = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, len);
            }
            System.out.println("复制成功！");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3. 关闭资源
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            try {
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**练习：**实现图片加密操作。

**提示：**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733216727989-69da234b-33da-45e9-8e69-235ddef43206.png)

**代码：**

```java
import org.junit.Test;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class PicEncryptTest {
    /**
     * 图片文件加密
     * 字节 = 字节 ^ 5
     */
    @Test
    public void encryptPic() {
        FileInputStream fis = null;
        FileOutputStream fos = null;

        try {
            fis = new FileInputStream("testPic.png");
            fos = new FileOutputStream("testPic-enc.png");

            int len;
            byte[] buff = new byte[1024];
            while ((len = fis.read(buff)) != -1) {
                for (int i = 0; i < buff.length; i++) {
                    buff[i] = ((byte) (buff[i] ^ 5));
                }
                fos.write(buff, 0, len);
            }
            System.out.println("加密成功！");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            try {
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 图片文件解密
     * 字节 = 字节 ^ 5
     * 解释：两次相同的异或操作会抵消
     */
    @Test
    public void decryptPic() {
        FileInputStream fis = null;
        FileOutputStream fos = null;

        try {
            fis = new FileInputStream("testPic-enc.png");
            fos = new FileOutputStream("testPic-dec.png");

            int len;
            byte[] buff = new byte[1024];
            while ((len = fis.read(buff)) != -1) {
                for (int i = 0; i < buff.length; i++) {
                    buff[i] = ((byte) (buff[i] ^ 5));
                }
                fos.write(buff, 0, len);
            }
            System.out.println("加密成功！");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            try {
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 处理流`1`：缓冲流

- **<font style="color:#DF2A3F;">为了提高数据读写的速度，</font>**`**<font style="color:#DF2A3F;">Java API</font>**`**<font style="color:#DF2A3F;">提供了带缓冲功能的缓冲流</font>**
- **<font style="color:#DF2A3F;">缓冲流要“套接”在相应的节点流之上</font>**，**根据数据\*\***<font style="color:#DF2A3F;">操作单位</font>\***\*可以把缓冲流分为**：
  - **<font style="color:#DF2A3F;">字节</font>\*\***缓冲流**：`**BufferedInputStream**``**BufferedOutputStream\*\*`
  - **<font style="color:#DF2A3F;">字符</font>\*\***缓冲流**：`**BufferedReader**``**BufferedWriter\*\*`
- **缓冲流的基本原理**：**<font style="color:#DF2A3F;">在创建流对象时，内部会创建一个缓冲区数组</font>**
  - **缺省使用**`**8192**`**个字节(**`**8KB**`**)的缓冲区**
  - **<font style="color:#DF2A3F;">通过缓冲区读写，减少系统</font>**`**<font style="color:#DF2A3F;">IO</font>**`**<font style="color:#DF2A3F;">次数，从而提高读写的效率</font>**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733216737356-338d2ed3-cce8-4cc0-bb77-67079019d1f6.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378780075-df923c16-4e2f-4101-9876-9ca2e4b5437f.png)

#### 构造器

- `public **BufferedInputStream**(**InputStream** in)`：**创建一个新的字节型的缓冲\*\***<font style="color:#DF2A3F;">输入流 </font>\*\*
- `public **BufferedOutputStream**(**OutputStream** out)`：**创建一个新的字节型的缓冲\*\***<font style="color:#DF2A3F;">输出流</font>\*\*

**代码举例：**

```java
// 创建字节缓冲输入流
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("abc.jpg"));
// 创建字节缓冲输出流
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("abc_copy.jpg"));
```

- `public **BufferedReader**(**Reader** in)`：**创建一个新的字符型的缓冲\*\***<font style="color:#DF2A3F;">输入流</font>\*\*
- `public **BufferedWriter**(**Writer** out)`：**创建一个新的字符型的缓冲\*\***<font style="color:#DF2A3F;">输出流</font>\*\*

**代码举例：**

```java
// 创建字符缓冲输入流
BufferedReader br = new BufferedReader(new FileReader("br.txt"));
// 创建字符缓冲输出流
BufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt"));
```

#### 效率测试

查询`API`，缓冲流读写方法与基本的流是一致的，通过复制大文件（`263MB`），测试它的效率

```java
import org.junit.Test;
import java.io.*;

public class BufferedStreamEfficiencyTest {
    /**
     * 方式1： 通过 FileInputStream 和 FileOutputStream 复制非文本文件
     */
    public void copyFileWithFileStream(String srcPath, String destPath) {
        FileInputStream fis = null;
        FileOutputStream fos = null;

        try {
            // 1. 造流
            fis = new FileInputStream(srcPath);
            fos = new FileOutputStream(destPath);

            // 2. 复制文件
            int len;
            byte[] buff = new byte[100];
            while ((len = fis.read(buff)) != -1) {
                fos.write(buff, 0, len);
            }
            System.out.println("复制成功...");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3. 关闭资源
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            try {
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 方式1 效率测试
     */
    @Test
    public void copyFileWithFileStreamTest() {
        String src = "F:/aaa/深入浅出SpringBoot2.x.pdf";
        String dest = "F:/aaa/copy1-深入浅出SpringBoot2.x.pdf";
        long start = System.currentTimeMillis();
        copyFileWithFileStream(src, dest);
        long end = System.currentTimeMillis();
        // 14145ms
        System.out.println("copyFileWithFileStreamTest 花费时间: " + (end - start) + "ms");
    }

    /**
     * 通过 BufferedInputStream 和 BufferedOutputStream复制文件
     */
    public void copyWithBufferedStream(String srcPath, String destPath) {
        FileInputStream fis = null;
        BufferedInputStream bis = null;
        FileOutputStream fos = null;
        BufferedOutputStream bos = null;

        try {
            // 1. 造流
            fis = new FileInputStream(srcPath);
            bis = new BufferedInputStream(fis);
            fos = new FileOutputStream(destPath);
            bos = new BufferedOutputStream(fos);

            // 2. 复制文件
            int len;
            byte[] buff = new byte[100];
            while ((len = bis.read(buff)) != -1) {
                fos.write(buff, 0, len);
            }
            System.out.println("复制成功...");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3. 关闭资源
            try {
                if (bos != null) {
                    bos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            try {
                if (bis != null) {
                    bis.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

    /**
     * 方式2 效率测试
     */
    @Test
    public void copyWithBufferedStreamTest() {
        String src = "F:/aaa/深入浅出SpringBoot2.x.pdf";
        String dest = "F:/aaa/copy2-深入浅出SpringBoot2.x.pdf";
        long start = System.currentTimeMillis();
        copyWithBufferedStream(src, dest);
        long end = System.currentTimeMillis();
        // 10425ms
        System.out.println("copyWithBufferedStream 花费时间: " + (end - start) + "ms");
    }
}
```

#### 字符缓冲流特有方法

字符缓冲流的基本方法与普通字符流调用方式一致，<font style="color:#DF2A3F;">以下是它们具备的特有方法</font>：

- `BufferedReader：public String readLine()`：**读一行文字**
- `BufferedWriter：public void newLine()`：写一行**行分隔符**，**由系统属性定义符号**

```java
public class BufferedIOLine {
    @Test
    public void testReadLine()throws IOException {
        // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader("in.txt"));
        // 定义字符串,保存读取的一行文字
        String line;
        // 循环读取,读取到最后返回null
        while ((line = br.readLine())!=null) {
            System.out.println(line);
        }
        // 释放资源
        br.close();
    }

    @Test
    public void testNewLine()throws IOException{
        // 创建流对象
        BufferedWriter bw = new BufferedWriter(new FileWriter("out.txt"));
        // 写出数据
        bw.write("尚");
        // 写出换行
        bw.newLine();
        bw.write("硅");
        bw.newLine();
        bw.write("谷");
        bw.newLine();
        // 释放资源
        bw.close();
    }
}
```

**<font style="color:#DF2A3F;">说明</font>\*\***：\*\*

- **涉及到嵌套的多个流时，如果都显式关闭的话，需要\*\***<font style="color:#DF2A3F;">先关闭外层的流，再关闭内层的流</font>\*\*
- **<font style="color:#DF2A3F;">其实在开发中，只需要关闭最外层的流即可，因为在关闭外层流时，内层的流也会被关闭</font>**
  - **<font style="color:#DF2A3F;">补充（嵌套流的实现）</font>**：<font style="color:#DF2A3F;">在</font>`<font style="color:#DF2A3F;">Java</font>`<font style="color:#DF2A3F;">中，许多流的实现类（如</font>`<font style="color:#DF2A3F;">BufferedReader</font>`<font style="color:#DF2A3F;">、</font>`<font style="color:#DF2A3F;">InputStreamReader</font>`<font style="color:#DF2A3F;">等）在其</font>`<font style="color:#DF2A3F;">close()</font>`<font style="color:#DF2A3F;">方法中会调用其底层流的</font>`<font style="color:#DF2A3F;">close()</font>`<font style="color:#DF2A3F;">方法。</font>**<font style="color:#DF2A3F;">例如</font>**<font style="color:#DF2A3F;">：</font>`BufferedReader`的`close()`方法会调用其内部`Reader`的`close()`方法，而这个`Reader`可能又是一个`InputStreamReader`，它又会调用其内部`InputStream`的`close()`方法

#### 练习

姓氏统计：一个文本文件中存储着姓名，现在想统计所有的姓氏在文件中出现的次数，文件格式如下：

```plain
张 三
李 四
王 小五
```

**测试代码：**

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class StatisticNamesTest {
    public static void main(String[] args) {
        // 存储统计结果
        HashMap<String, Integer> map = new HashMap<>();

        // 读取文件进行统计
        BufferedReader bufferedReader = null;
        try {
            bufferedReader = new BufferedReader(new FileReader("names.txt"));
            String line = null;
            StringBuilder stringBuffer = new StringBuilder();
            while ((line = bufferedReader.readLine()) != null) {
                char[] chars = line.toCharArray();
                for (char aChar : chars) {
                    if (aChar != ' ') {
                        stringBuffer.append(aChar);
                    } else {
                        String s = stringBuffer.toString();
                        if (map.containsKey(s)) {
                            map.put(s, map.get(s) + 1);
                        } else {
                            map.put(s, 1);
                        }
                        stringBuffer.delete(0, stringBuffer.length());
                        break;
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bufferedReader != null) {
                    bufferedReader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        // 输出结果
        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        for (Map.Entry<String, Integer> entry : entries) {
            System.out.println(entry.getKey() + " " + entry.getValue());
        }
    }
}
```

**输出结果：**

```bash
张 1
王 1
李 1
```

### 处理流`2`：转换流

#### <font style="color:#DF2A3F;">问题引入</font>

- **情况**`**1**`**：**使用`FileReader`读取项目中的文本文件，由于`IDEA`设置中针对项目设置了`UTF-8`编码，当读取`Windows`系统中创建的文本文件时，如果`Windows`系统默认是`GBK`编码，则**<font style="color:#DF2A3F;">读入内存中的字符会出现乱码。</font>\*\***那么如何读取**`**GBK**`**编码的文件呢？\***\*<font style="color:#DF2A3F;"></font>**

```java
import java.io.FileReader;
import java.io.IOException;

public class FileReaderEncodeProblemTest {
    public static void main(String[] args) throws IOException {
        FileReader fileReader = new FileReader("file-gbk.txt");

        int data;
        StringBuilder stringBuffer = new StringBuilder();
        while ((data = fileReader.read()) != -1) {
            stringBuffer.append(((char) data));
        }
        fileReader.close();
        System.out.println(stringBuffer.toString());
    }
}
// 输出结果：����һ��GBK������ַ���
```

- **情况**`**2**`**：**针对文本文件，使用一个字节流进行数据的读入，希望将数据显示在控制台上。**<font style="color:#DF2A3F;">对于包含中文的文本数据，可能会出现乱码。</font>**

#### 转换流的理解

- **作用：\*\***<font style="color:#DF2A3F;">转换流是字节与字符间的桥梁</font>\*\*

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378791746-52b40a46-525d-4a6f-9177-19adab177a0b.png)

- 具体来说：

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733378797146-394db895-2607-4946-91e5-c57198bede23.png)

#### `InputStreamReader`与`OutputStreamWriter`

- `**InputStreamReader**`
  - 转换流`java.io.InputStreamReader`是`Reader`的子类，是从字节流到字符流的桥梁。**<font style="color:#DF2A3F;">它读取字节，并使用指定的字符集将其解码为字符</font>**，**<font style="color:#DF2A3F;">字符集可以由名称指定或接受平台的默认字符集</font>**
  - **构造器**
    - `InputStreamReader(InputStream in)`：创建一个**使用默认字符集**的字符流
    - `InputStreamReader(InputStream in, String charsetName)`：创建一个**指定字符集**的字符流

```java
// 使用默认字符集
InputStreamReader isr1 = new InputStreamReader(new FileInputStream("in.txt"));
// 使用指定字符集
InputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK");
```

    - **样例代码：**

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class InputStreamReaderTest {
    public static void main(String[] args) throws IOException {
        // 方式1
        // 使用默认的utf-8编码
        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream("file-gbk.txt"));
        int charData1;
        StringBuilder stringBuffer = new StringBuilder();
        while ((charData1 = inputStreamReader.read()) != -1) {
            stringBuffer.append(((char) charData1));
        }
        // 字符串乱码
        // 输出：����һ��GBK������ַ���
        System.out.println(stringBuffer);

        // 方式2
        // 指定使用gbk编码
        InputStreamReader inputStreamReader2 = new InputStreamReader(new FileInputStream("file-gbk.txt"), "GBK");
        int charData2;
        StringBuilder stringBuilder2 = new StringBuilder();
        while ((charData2 = inputStreamReader2.read()) != -1) {
            stringBuilder2.append(((char) charData2));
        }
        // 字符串正常输出
        // 输出：这是一个GBK编码的字符串
        System.out.println(stringBuilder2);
    }
}
```

- `**OutputStreamWriter**`
  - 转换流`java.io.OutputStreamWriter`是`Writer`的子类，是从字符流到字节流的桥梁。**<font style="color:#DF2A3F;">它使用指定的字符集将字符编码为字节，字符集可以由名称指定或接受平台的默认字符集</font>**
  - **构造器**
    - `OutputStreamWriter(OutputStream in)`：创建一个**使用默认字符集**的字符流
    - `OutputStreamWriter(OutputStream in,String charsetName)`：创建一个**指定字符集**的字符流

```java
// 使用默认字符集
OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream("out.txt"));
// 使用指定的字符集
OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream("out.txt") , "GBK");
```

    - **样例代码：**

```java
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

public class OutputStreamWriterTest {
    public static void main(String[] args) throws IOException {
        // 使用默认utf-8 编码字符
        OutputStreamWriter outputStreamWriter1 = new OutputStreamWriter(new FileOutputStream("file-out-utf8.txt"));
        outputStreamWriter1.write("你好");
        outputStreamWriter1.close();

        // 指定 gbk 编码字符
        OutputStreamWriter outputStreamWriter2 = new OutputStreamWriter(new FileOutputStream("file-out-gbk.txt"), "GBK");
        outputStreamWriter2.write("你好");
        outputStreamWriter2.close();
    }
}
```

#### 字符编码和字符集

##### 编码与解码

- **计算机中储存的信息都是用二进制数表示的**，**<font style="color:#DF2A3F;">而在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果</font>**。**按照某种规则\*\***<font style="color:#DF2A3F;">，将字符存储到计算机中，称为</font>\***\*编码\*\***<font style="color:#DF2A3F;">；反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为</font>\***\*解码**
- **字符编码（**`**Character Encoding**`**）：**一套自然语言字符与二进制数之间的**<font style="color:#DF2A3F;">对应规则</font>**
- **编码表**：生活中文字和计算机中二进制的对应规则
- **乱码的情况**：按照`A`规则存储，同样按照`A`规则解析，那么就能显示正确的文本符号；反之，**<font style="color:#DF2A3F;">按照</font>**`**<font style="color:#DF2A3F;">A</font>**`**<font style="color:#DF2A3F;">规则存储，再按照</font>**`**<font style="color:#DF2A3F;">B</font>**`**<font style="color:#DF2A3F;">规则解析，就会导致乱码现象</font>**
- **编码（**`**Encode**`**）**：**<font style="color:#DF2A3F;">字符</font>**(人能看懂的)`**-->**`**字节**(人看不懂的)
- **解码（**`**Decode**`**）**：**字节**(人看不懂的)`**-->**`**<font style="color:#DF2A3F;">字符</font>**(人能看懂的)

##### 字符集

- **字符集（**`**Charset**`**）：也叫编码表**，**<font style="color:#DF2A3F;">是一个系统支持的所有字符的集合</font>**。<font style="color:#DF2A3F;">它包括各国家文字、标点符号、图形符号、数字等</font>
- 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。**常见字符集**：`**ASCII**`字符集、`**GBK**`字符集、`**Unicode**`字符集等。**<font style="color:#DF2A3F;">当指定了编码，它所对应的字符集自然就指定了</font>**
- `**ASCII**`**字符集**
  - 上个世纪`60`年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系做了统一规定，这被称为`**ASCII**`**码（**`**American Standard Code for Information Interchange**`**，美国信息交换标准代码）**
  - `**<font style="color:#DF2A3F;">ASCII</font>**`**<font style="color:#DF2A3F;">码用于显示现代英语</font>**，**主要包括**：<font style="color:#DF2A3F;">控制字符</font>（回车键、退格、换行键等）和<font style="color:#DF2A3F;">可显示字符</font>（英文大小写字符、阿拉伯数字和西文符号）
  - 基本的`ASCII`字符集：使用`7`位（`bits`）表示`1`个字符，最前面的`1`位统一规定为`0`，共`128`个字符。**比如**：**<font style="color:#DF2A3F;">空格</font>**`**<font style="color:#DF2A3F;">SPACE</font>**`**<font style="color:#DF2A3F;">是</font>**`**<font style="color:#DF2A3F;">32</font>**`**<font style="color:#DF2A3F;">（二进制</font>**`**<font style="color:#DF2A3F;">00100000</font>**`**<font style="color:#DF2A3F;">），大写的字母</font>**`**<font style="color:#DF2A3F;">A</font>**`**<font style="color:#DF2A3F;">是</font>**`**<font style="color:#DF2A3F;">65</font>**`**<font style="color:#DF2A3F;">（二进制</font>**`**<font style="color:#DF2A3F;">01000001</font>**`**<font style="color:#DF2A3F;">）</font>**
  - **<font style="color:#DF2A3F;">缺点</font>**：**不能表示所有字符**
- `**ISO-8859-1**`**字符集**
  - **拉丁码表**，别名`Latin-1`，**<font style="color:#DF2A3F;">用于显示欧洲语言</font>**，包括：荷兰语、德语、意大利语、葡萄牙语等
  - **<font style="color:#DF2A3F;">使用单字节编码，兼容ASCII编码</font>**
- `**GBxxx**`**字符集**
  - `**<font style="color:#DF2A3F;">GB</font>**`**<font style="color:#DF2A3F;">就是国标的意思，是为了显示中文而设计的一套字符集</font>**
    - `**GB2312**`：**简体中文码表**，<font style="color:#DF2A3F;">一个小于</font>`<font style="color:#DF2A3F;">127</font>`<font style="color:#DF2A3F;">的字符的意义与原来相同，向下兼容</font>`<font style="color:#DF2A3F;">ASCII</font>`<font style="color:#DF2A3F;">码，但两个大于</font>`<font style="color:#DF2A3F;">127</font>`<font style="color:#DF2A3F;">的字符连在一起时，就表示一个汉字</font>，大约包含`7000`多个简体汉字，此外还包含：数学符号、罗马希腊的字母、日文的假名等，即：常说的"全角"字符，而原来在`127`号以下的那些符号就叫"半角"字符
    - `**GBK**`：最常用的中文码表，**是在**`**GB2312**`**标准基础上的扩展规范**，使用了**<font style="color:#DF2A3F;">双字节编码</font>**方案，共收录了`21003`个汉字，完全兼容`GB2312`标准，<font style="color:#DF2A3F;">支持繁体汉字以及日韩汉字等</font>
    - `**GB18030**`：**最新的中文码表**，收录汉字`70244`个，采用**<font style="color:#DF2A3F;">多字节编码</font>**，每个字可以由`1`个、`2`个或`4`个字节组成，**<font style="color:#DF2A3F;">支持中国国内少数民族的文字</font>**，同时支持繁体汉字以及日韩汉字等
- `**Unicode**`**字符集**
  - `**<font style="color:#DF2A3F;">Unicode</font>**`**<font style="color:#DF2A3F;">编码是为表达任意语言的任意字符而设计</font>**，**又称：统一码、标准万国码，**`Unicode`将世界上所有的文字用`2`个字节统一进行编码，为每个字符设定唯一的二进制编码，以满足跨语言、跨平台进行文本处理的要求
  - `**Unicode**`**的缺点：**
    - `**1.**`英文字母只用`1`个字节表示就够了，用更多的字节存储是极大的浪费
    - `**2.**`如何才能区别`Unicode`和`ASCII`？计算机怎么知道`2`个字节表示`1`个符号，而不是分别表示`2`个符号呢？
    - `**3.**`如果和`GBK`等双字节编码方式一样，用最高位是`1`或`0`表示`2`个字节和`1`个字节，就少了很多值无法用于表示字符，不够表示所有字符
  - `Unicode`在很长一段时间内无法推广，直到互联网的出现。为解决`Unicode`如何在网络上传输的问题，于是面向传输的众多`**UTF**`**(**`**Unicode Transformation Format**`**)**标准出现，具体来说有三种编码方案：`UTF-8`、`UTF-16`和`UTF-32`
- `**UTF-8**`**字符集**
  - `Unicode`是字符集，`**UTF-8**`**、**`**UTF-16**`**、**`**UTF-32**`**是三种将数字转换到程序数据的编码方案**。`UTF-8`就是每次`8`个位传输数据，而`UTF-16`就是每次`16`个位，其中`UTF-8`是在互联网上使用最广的一种`Unicode`的实现方式
  - 互联网工程工作小组（`IETF`）要求所有互联网协议都必须支持`UTF-8`编码。所以，我们开发Web应用，也要使用`UTF-8`编码。`UTF-8`是一种变长的编码方式，它使用`1~4`个字节为每个字符编码，**编码规则：**
    - `**1.**``128`个`US-ASCII`字符，只需`1`个字节编码
    - `**2.**`拉丁文等字符，需要`2`个字节编码
    - `**3.**`**<font style="color:#DF2A3F;">大部分常用字（含中文），使用</font>**`**<font style="color:#DF2A3F;">3</font>**`**<font style="color:#DF2A3F;">个字节编码</font>**
    - `**4.**`其他极少使用的`Unicode`辅助字符，使用`4`字节编码

**举例：**

| `**Unicode**`**符号范围(十六进制)** | `**UTF-8**`**编码方式（二进制）**  |
| ----------------------------------: | :---------------------------------- |
|                 0000 0000-0000 007F | 0xxxxxxx（兼容原来的`ASCII`）       |
|                 0000 0080-0000 07FF | 110xxxxx 10xxxxxx                   |
|                 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx          |
|                 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

##### 小结

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733377715600-2be5761f-b5f0-4f51-9a0c-36f480904c1f.png)

**<font style="color:#DF2A3F;">注意</font>**：**在中文操作系统上，**`**ANSI**`**（美国国家标准学会：**`**AMERICAN NATIONAL STANDARDS INSTITUTE: ANSI**`**）编码即为**`**GBK**`**；在英文操作系统上，**`**ANSI**`**编码即为**`**ISO-8859-1**`**。**

#### 练习

把当前`module`下的`康师傅的话.txt`字符编码为`GBK`，复制到电脑桌面目录下的`寄语.txt`， 字符编码为`UTF-8`。`康师傅的话.txt`的文本内容：

```plain
六项精进：
（一）付出不亚于任何人的努力
（二）要谦虚，不要骄傲
（三）要每天反省
（四）活着，就要感谢
（五）积善行、思利他
（六）不要有感性的烦恼
```

**测试代码：**

```java
import java.io.*;

public class InputStreamReaderAndOutputStreamWriterTest {
    public static void main(String[] args) {
        // 创建流
        InputStreamReader inputStreamReader = null;
        OutputStreamWriter outputStreamWriter = null;

        try {
            inputStreamReader = new InputStreamReader(new FileInputStream("康师傅的话.txt"), "GBK");
            outputStreamWriter = new OutputStreamWriter(new FileOutputStream("寄语.txt"), "UTF-8");
            // 复制文件内容
            int len;
            char[] buff = new char[512];
            while ((len = inputStreamReader.read(buff)) != -1) {
                outputStreamWriter.write(buff, 0, len);
            }
            System.out.println("文件复制成功");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            try {
                if (inputStreamReader != null) {
                    inputStreamReader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            try {
                if (outputStreamWriter != null) {
                    outputStreamWriter.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 处理流`3`和`4`：数据流、对象流

#### 数据流与对象流说明

**<font style="color:#DF2A3F;">如果需要将内存中定义的变量（包括：基本数据类型、引用数据类型）保存在文件中，那怎么办呢？</font>**

```java
int age = 300;
char gender = '男';
int energy = 5000;
double price = 75.5;
boolean relive = true;

String name = "巫师";
Student stu = new Student("张三",23,89);
```

`**<font style="color:#DF2A3F;">Java</font>**`**<font style="color:#DF2A3F;">提供了数据流和对象流来处理这些类型的数据：</font>**

- **数据流**：`**DataOutputStream**``**DataInputStream**`
  - `DataOutputStream`：**允许应用程序将基本数据类型、**`**String**`**类型的变量写入输出流中**
  - `DataInputStream`：**允许应用程序以与机器无关的方式从底层输入流中读取基本数据类型、**`**String**`**类型的变量**
  - `**DataInputStream**`**中的方法：**
    - `byte read**<font style="color:#DF2A3F;">Byte</font>**()`
    - `short read**<font style="color:#DF2A3F;">Short</font>**()`
    - `int read**<font style="color:#DF2A3F;">Int</font>**()`
    - `long read**<font style="color:#DF2A3F;">Long</font>**()`
    - `float read**<font style="color:#DF2A3F;">Float</font>**()`
    - `double read**<font style="color:#DF2A3F;">Double</font>**()`
    - `char read**<font style="color:#DF2A3F;">Char</font>**()`
    - `boolean read**<font style="color:#DF2A3F;">Boolean</font>**()`
    - `String read**<font style="color:#DF2A3F;">UTF</font>**()`
    - `**<font style="color:#DF2A3F;">void readFully(byte[] b)</font>**`
  - `**DataOutputStream**`**中的方法：\*\***<font style="color:#DF2A3F;">将上述的方法的</font>**`**<font style="color:#DF2A3F;">read</font>**`**<font style="color:#DF2A3F;">改为相应的</font>**`**<font style="color:#DF2A3F;">write</font>**`**<font style="color:#DF2A3F;">即可</font>\*\*
  - **<font style="color:#DF2A3F;">数据流的弊端</font>**：**<font style="color:#DF2A3F;">只支持</font>**`**<font style="color:#DF2A3F;">Java</font>**`**<font style="color:#DF2A3F;">基本数据类型和字符串的读写，而不支持其它</font>**`**<font style="color:#DF2A3F;">Java</font>**`**<font style="color:#DF2A3F;">对象的类型。</font>\*\***而**`**ObjectOutputStream**`**和**`**ObjectInputStream**`**既支持**`**Java**`**基本数据类型的数据读写，又支持**`**Java**`**对象的读写\*\*
- **对象流**：`**ObjectOutputStream**``**ObjectInputStream**`
  - `ObjectOutputStream`：**将**`**Java**`**<font style="color:#DF2A3F;">基本数据类型和对象</font>\*\***写入字节输出流中，通过在流中使用文件可以实现**`**Java**`**<font style="color:#DF2A3F;">各种基本数据类型的数据以及对象的持久存储</font>\*\*
  - `ObjectInputStream`：`**ObjectInputStream**`**对以前使用**`**ObjectOutputStream**`**写出的\*\***<font style="color:#DF2A3F;">基本数据类型的数据和对象进行读入操作，保存在内存中</font>\*\*

**说明：**<font style="color:#DF2A3F;">对象流的强大之处就是可以把</font>`<font style="color:#DF2A3F;">Java</font>`<font style="color:#DF2A3F;">中的对象写入到数据源中，也能把对象从数据源中还原回来</font>。

#### 对象流`API`

##### `ObjectOutputStream`

###### 构造器

- `public **ObjectOutputStream**(**OutputStream** out)`：创建一个指定的`ObjectOutputStream`

```java
FileOutputStream fos = new FileOutputStream("game.dat");
ObjectOutputStream oos = new ObjectOutputStream(fos);
```

###### 方法

- `public void write**<font style="color:#DF2A3F;">Boolean</font>**(boolean val)`：写出一个`boolean`值
- `public void write**<font style="color:#DF2A3F;">Byte</font>**(int val)`：写出一个`8`位字节
- `public void write**<font style="color:#DF2A3F;">Short</font>**(int val)`：写出一个`16`位的`short`值
- `public void write**<font style="color:#DF2A3F;">Char</font>**(int val)`：写出一个`16`位的`char`值
- `public void write**<font style="color:#DF2A3F;">Int</font>**(int val)`：写出一个`32`位的`int`值
- `public void write**<font style="color:#DF2A3F;">Long</font>**(long val)`：写出一个`64`位的`long`值
- `public void write**<font style="color:#DF2A3F;">Float</font>**(float val)`：写出一个`32`位的`float`值
- `public void write**<font style="color:#DF2A3F;">Double</font>**(double val)`：写出一个`64`位的`double`值
- `**public void write****<font style="color:#DF2A3F;">UTF</font>****(String str)**`：将表示长度信息的`2`个字节写入输出流，后跟字符串 `s`中每个字符的`UTF-8`修改版表示形式。根据字符的值，将字符串`s`中每个字符转换成`1`个字节、`2`个字节或`3`个字节的字节组。**注意**：**<font style="color:#DF2A3F;">将</font>**`**<font style="color:#DF2A3F;">String</font>**`**<font style="color:#DF2A3F;">作为基本数据写入流中与将它作为</font>**`**<font style="color:#DF2A3F;">Object</font>**`**<font style="color:#DF2A3F;">写入流中明显不同，如果</font>**`**<font style="color:#DF2A3F;">s</font>**`**<font style="color:#DF2A3F;">为</font>**`**<font style="color:#DF2A3F;">null</font>**`**<font style="color:#DF2A3F;">则抛出 </font>**`**<font style="color:#DF2A3F;">NullPointerException</font>**`
- `**<font style="color:#DF2A3F;">public void writeObject(Object obj)</font>**`：写出一个`obj`对象
- `public void close()`：**关闭此输出流并释放与此流相关联的任何系统资源**

##### `ObjectInputStream`

###### 构造器

- `public **ObjectInputStream**(**InputStream** in)`：创建一个指定的`ObjectInputStream`

```java
FileInputStream fis = new FileInputStream("game.dat");
ObjectInputStream ois = new ObjectInputStream(fis);
```

###### 方法

- `public boolean read**<font style="color:#DF2A3F;">Boolean</font>**()`：读取一个`boolean`值
- `public byte read**<font style="color:#DF2A3F;">Byte</font>**()`：读取一个`8`位的字节
- `public short read**<font style="color:#DF2A3F;">Short</font>**()`：读取一个`16`位的`short`值
- `public char read**<font style="color:#DF2A3F;">Char</font>**()`：读取一个`16`位的`char`值
- `public int read**<font style="color:#DF2A3F;">Int</font>**()`：读取一个`32`位的`int`值
- `public long read**<font style="color:#DF2A3F;">Long</font>**()`：读取一个`64`位的`long`值
- `public float read**<font style="color:#DF2A3F;">Float</font>**()`：读取一个`32`位的`float`值
- `public double read**<font style="color:#DF2A3F;">Double</font>**()`：读取一个`64`位的`double`值
- `public String read**<font style="color:#DF2A3F;">UTF</font>**()`：读取`UTF-8`修改版格式的`String`
- `**<font style="color:#DF2A3F;">public void readObject(Object obj)</font>**`：读入一个`obj`对象
- `public void close()`：**关闭此输入流并释放与此流相关联的任何系统资源**

#### 认识对象序列化机制

1. **何为对象序列化机制？**

<font style="color:#DF2A3F;">对象序列化机制允许把内存中的</font>`<font style="color:#DF2A3F;">Java</font>`<font style="color:#DF2A3F;">对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上或通过网络将这种二进制流传输到另一个网络节点</font>。**当其它程序获取了这种二进制流，就可以恢复成原来的**`**Java**`**对象。**

- **<font style="color:#DF2A3F;">序列化过程</font>**：用一个字节序列可以表示一个对象，该字节序列包含该对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息
- **<font style="color:#DF2A3F;">反序列化过程</font>**：该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、类型和对象中存储的数据信息，都可以用来在内存中创建对象

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733380450500-4de2bc2b-905d-4031-bf6e-5d2bcfe1d54a.png)

2. **序列化机制的重要性**

- 序列化是`RMI`（`**Remote Method Invoke**`**：远程方法调用**）过程的参数和返回值都必须实现的机制，而`RMI`是`JavaEE`的基础，因此序列化机制是`JavaEE`平台的基础
- **序列化的好处**：可将任何实现了`Serializable`接口的对象转化为字节数据，使其在保存和传输时可被还原

3. **实现原理**

- **序列化**：用`ObjectOutputStream`类保存基本类型数据或对象
  - `public final void writeObject (Object obj)` : 将指定的对象写出
- **反序列化**：用`ObjectInputStream`类读取基本类型数据或对象
  - `public final Object readObject ()` : 读取一个对象

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733380618585-61d1b10e-0ba3-4c0d-9da3-3a1ed007fc46.png)

#### 如何实现序列化机制

**<font style="color:#DF2A3F;">如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的。为了让某个类是可序列化的，该类必须实现</font>**`**<font style="color:#DF2A3F;">java.io.Serializable</font>**`**<font style="color:#DF2A3F;">接口。</font>**`Serializable`是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出`NotSerializableException`。

- <font style="color:#DF2A3F;">若对象的某个属性也是引用数据类型，如果该属性也要序列化的话，也要实现</font>`<font style="color:#DF2A3F;">Serializable</font>`<font style="color:#DF2A3F;">接口</font>
- **<font style="color:#DF2A3F;">要序列化的类的所有属性必须是可序列化的，如果某个属性不需要序列化，则该属性必须使用</font>**`**<font style="color:#DF2A3F;">transient</font>**`**<font style="color:#DF2A3F;">关键字修饰注明是瞬态的</font>**
- <font style="color:#DF2A3F;">静态</font>`<font style="color:#DF2A3F;">static</font>`<font style="color:#DF2A3F;">变量的值不会序列化，因为静态变量的值不属于某个对象</font>

**案例代码**`**1**`**（简单数据类型序列化与反序列化）：**

```java
import org.junit.Test;
import java.io.*;

public class ReadAndWriteDataOfSimpleTypeTest {
    /**
     * 简单数据类型序列化
     */
    @Test
    public void serializationTest() throws IOException {
        String name = "weew12";
        int age = 25;
        char gender = '男';
        int energy = 5000;
        double price = 75.5;
        boolean relive = true;

        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("ReadAndWriteDataOfAnyTypeTest.dat"));
        objectOutputStream.writeUTF(name);
        objectOutputStream.writeInt(age);
        objectOutputStream.writeChar(gender);
        objectOutputStream.writeInt(energy);
        objectOutputStream.writeDouble(price);
        objectOutputStream.writeBoolean(relive);
        objectOutputStream.close();
    }

    /**
     * 简单数据类型反序列化
     */
    @Test
    public void deSerializationTest() throws IOException {
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("ReadAndWriteDataOfAnyTypeTest.dat"));
        String name = objectInputStream.readUTF();
        int age = objectInputStream.readInt();
        char gender = objectInputStream.readChar();
        int energy = objectInputStream.readInt();
        double price = objectInputStream.readDouble();
        boolean relive = objectInputStream.readBoolean();
        objectInputStream.close();
        System.out.println(name + " " + age + " " + gender + " " + energy + " " + price + " " + relive);
    }
}
```

**案例代码**`**2**`**（复杂数据类型序列化与反序列化）：**

```java
import org.junit.Test;
import java.io.*;

public class ReadAndWriteDataOfComplexTypeTest {
    /**
     * 序列化
     */
    @Test
    public void serialization() throws IOException {
        RwEmployee.setCompany("weew12.io");
        RwEmployee rwEmployee = new RwEmployee("weew12", "China", 26);
        // 创建序列化流对象
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("ReadAndWriteDataOfComplexTypeTest.dat"));
        // 写出对象
        objectOutputStream.writeObject(rwEmployee);
        // 关闭资源
        objectOutputStream.close();
        System.out.println("写出成功...");
        System.out.println(rwEmployee);
    }

    /**
     * 反序列化
     */
    @Test
    public void deSerialization() throws IOException, ClassNotFoundException {
        // 创建反序列化流对象
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("ReadAndWriteDataOfComplexTypeTest.dat"));
        // 读取一个对象
        Object readObject = objectInputStream.readObject();
        // 关闭资源
        objectInputStream.close();
        System.out.println("读取成功...");
        System.out.println(readObject);
    }
}

class RwEmployee implements Serializable {
    static final long serialVersionUID = 1733382052207L;
    /**
     * 静态变量不会被序列化
     */
    public static String company;
    private String name;
    private String address;
    /**
     * transient 瞬态修饰 不会被序列化
     */
    private transient int age;

    public RwEmployee(String name, String address, int age) {
        this.name = name;
        this.address = address;
        this.age = age;
    }

    public static String getCompany() {
        return company;
    }

    public static void setCompany(String company) {
        RwEmployee.company = company;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "RwEmployee{" +
                "name='" + name + '\'' +
                ", address='" + address + '\'' +
                ", age=" + age +
                '}';
    }
}
```

**案例代码**`**3**`**：**

<font style="color:#DF2A3F;">如果有多个对象需要序列化，则可以将对象放到集合中，再序列化集合对象即可。</font>

```java
import org.junit.Test;
import java.io.*;
import java.util.ArrayList;

public class MultipleObjectSerializationTest {
    /**
     * 序列化
     */
    @Test
    public void multipleObjSerialization() throws IOException {
        ArrayList<RwEmployee> rwEmployees = new ArrayList<>();
        rwEmployees.add(new RwEmployee("张三", "上海", 28));
        rwEmployees.add(new RwEmployee("李四", "长沙", 25));
        rwEmployees.add(new RwEmployee("王五", "广州", 27));
        // 创建序列化流对象
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("MultipleObjectSerializationTest.dat"));
        // 写出对象
        objectOutputStream.writeObject(rwEmployees);
        // 关闭资源
        objectOutputStream.close();
        System.out.println("写出成功...");
        System.out.println(rwEmployees);
    }

    /**
     * 反序列化
     */
    @Test
    public void multipleObjDeSerialization() throws IOException, ClassNotFoundException {
        // 创建反序列化流对象
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("MultipleObjectSerializationTest.dat"));
        // 读取一个对象
        Object o = objectInputStream.readObject();
        // 释放资源
        objectInputStream.close();
        System.out.println("读入成功...");
        System.out.println(o);
    }
}
```

#### 反序列化失败问题

**问题**`**1**`**：**

<font style="color:#DF2A3F;">对于</font>`<font style="color:#DF2A3F;">JVM</font>`<font style="color:#DF2A3F;">可以反序列化的对象，它必须是能够找到</font>`<font style="color:#DF2A3F;">class</font>`<font style="color:#DF2A3F;">文件的类，如果找不到该类的</font>`<font style="color:#DF2A3F;">class</font>`<font style="color:#DF2A3F;">文件，则抛出一个</font>`<font style="color:#DF2A3F;">ClassNotFoundException</font>`<font style="color:#DF2A3F;">异常。</font>

**问题**`**2**`**：**

当`JVM`反序列化对象时，能找到`class`文件，但是`class`文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个`InvalidClassException`异常。**发生这个异常的原因如下：**

- <font style="color:#DF2A3F;">该类的序列版本号与从流中读取的类描述符的版本号不匹配 </font>
- <font style="color:#DF2A3F;">该类包含未知数据类型</font>

**解决办法**：

`**<font style="color:#DF2A3F;">Serializable</font>**`**<font style="color:#DF2A3F;">接口给需要序列化的类提供了一个序列版本号：</font>**`**<font style="color:#DF2A3F;">serialVersionUID</font>**`**<font style="color:#DF2A3F;">，凡是实现</font>**`**<font style="color:#DF2A3F;">Serializable</font>**`**<font style="color:#DF2A3F;">接口的类都应该有一个表示序列化版本标识符的静态变量：</font>**

```java
// 它的值由程序员随意指定即可
static final long serialVersionUID = 234242343243L;
```

- `**serialVersionUID**`**用来表明类的不同版本间的兼容性**。<font style="color:#DF2A3F;">简单来说，</font>`<font style="color:#DF2A3F;">Java</font>`<font style="color:#DF2A3F;">的序列化机制是通过在运行时判断类的</font>`<font style="color:#DF2A3F;">serialVersionUID</font>`<font style="color:#DF2A3F;">来验证版本一致性的。在进行反序列化时，</font>`<font style="color:#DF2A3F;">JVM</font>`<font style="color:#DF2A3F;">会把传来的字节流中的</font>`<font style="color:#DF2A3F;">serialVersionUID</font>`<font style="color:#DF2A3F;">与本地相应实体类的</font>`<font style="color:#DF2A3F;">serialVersionUID</font>`<font style="color:#DF2A3F;">进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常</font>`**<font style="color:#DF2A3F;">InvalidCastException</font>**`
- **如果类没有显示定义这个静态常量，它的值是**`**Java**`**运行时环境根据类的内部细节自动生成的**。**<font style="color:#DF2A3F;">若类的实例变量做了修改，</font>**`**<font style="color:#DF2A3F;">serialVersionUID</font>**`**<font style="color:#DF2A3F;">可能发生变化。因此，建议显式声明</font>**
- **<font style="color:#DF2A3F;">如果声明了</font>**`**<font style="color:#DF2A3F;">serialVersionUID</font>**`**<font style="color:#DF2A3F;">，即使在序列化完成之后修改了类导致类重新编译，则原来的数据也能正常反序列化，只是新增的字段值是默认值而已</font>**

```java
import java.io.Serializable;

public class Employee implements Serializable {
    // 增加serialVersionUID
    private static final long serialVersionUID = 1324234L;
    //其它结构：略
}
```

#### 面试题

<font style="color:#DF2A3F;">谈谈你对</font>`<font style="color:#DF2A3F;">java.io.Serializable</font>`<font style="color:#DF2A3F;">接口的理解，我们知道它用于序列化，是空方法接口，还有其它认识吗？ </font>

- 实现了`Serializable`接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程也可通过网络进行，这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在`Windows`机器上创建一个对象，对其序列化，然后通过网络发给一台`Unix`机器，然后在那里准确无误地重新“装配”，不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。
- 由于大部分作为参数的类如`String`、`Integer`等都实现了`java.io.Serializable`的接口，也可以利用多态的性质，作为参数使接口更灵活。

### 其他流的使用

#### 标准输入、输出流

- `System.in`和`System.out`分别代表了系统标准的输入和输出设备
- 默认输入设备是：键盘，输出设备是：显示器
- `System.in`的类型是`InputStream`
- `System.out`的类型是`PrintStream`，其是`OutputStream`子类`FilterOutputStream`的子类
- **重定向：**通过`System`类的`setIn`，`setOut`方法对默认设备进行改变
  - `public static void setIn(InputStream in)`
  - `public static void setOut(PrintStream out)`

**举例：**从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入`e`或者`exit`时，退出程序。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class OtherStreamExerciseTest {
    public static void main(String[] args) {
        System.out.println("请输入信息[退出输入 e 或 exit ]:");

        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String input = null;

        try {
            while ((input = bufferedReader.readLine()) != null) {
                if ("e".equalsIgnoreCase(input) || "exit".equalsIgnoreCase(input)) {
                    System.out.println("退出...");
                    break;
                }
                System.out.println("--->:" + input.toUpperCase());
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                bufferedReader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**拓展：**

`**System**`**类中有三个常量对象**：`System.out`、`System.in`、`System.err`。`System`类中这三个常量对象的声明：

```java
public final static InputStream in = null;
public final static PrintStream out = null;
public final static PrintStream err = null;
```

**问题与解答：**

- 这三个常量对象有`final`声明，但是却初始化为`null`。`final`声明的常量一旦赋值就不能修改，那么`null`不会空指针异常吗？
- 这三个常量对象为什么要小写？`final`声明的常量按照命名规范不是应该大写吗？
- 这三个常量的对象有`set`方法？`final`声明的常量不是不能修改值吗？`set`方法是如何修改它们的值的？

`**<font style="color:#DF2A3F;">final</font>**`**<font style="color:#DF2A3F;">声明的常量，表示在</font>**`**<font style="color:#DF2A3F;">Java</font>**`**<font style="color:#DF2A3F;">的语法体系中它们的值是不能修改的，而这三个常量对象的值是由</font>**`**<font style="color:#DF2A3F;">C/C++</font>**`**<font style="color:#DF2A3F;">等系统函数进行初始化和修改值的，所以它们故意没有用大写，也有</font>**`**<font style="color:#DF2A3F;">set</font>**`**<font style="color:#DF2A3F;">方法。</font>**

```java
public static void setOut(PrintStream out) {
    checkIO();
    setOut0(out);
}

public static void setErr(PrintStream err) {
    checkIO();
    setErr0(err);
}

public static void setIn(InputStream in) {
    checkIO();
    setIn0(in);
}

private static void checkIO() {
    SecurityManager sm = getSecurityManager();
    if (sm != null) {
        sm.checkPermission(new RuntimePermission("setIO"));
    }
}

private static native void setIn0(InputStream in);
private static native void setOut0(PrintStream out);
private static native void setErr0(PrintStream err);
```

#### 打印流

- **实现将基本数据类型的数据格式转化为字符串输出**
- `**PrintStream**`**和**`**PrintWriter**`
  - 提供了一系列重载的`print()`和`println()`方法，用于多种数据类型的输出

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733388380751-43f88612-51e8-41ae-a064-035c10ee64f1.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733388384668-21f9fce3-21f2-431b-ba0f-2da0b17b9879.png)

    - `PrintStream`和`PrintWriter`的输出不会抛出`IOException`异常
    - `PrintStream`和`PrintWriter`有自动`flush`功能
    - `PrintStream`打印的所有字符都使用平台的默认字符编码转换为字节，在需要写入字符而不是写入字节的情况下，应该使用`PrintWriter` 类
    - `System.out`返回的是`PrintStream`的实例

- **构造器**
  - `PrintStream(File file)`：创建具有指定文件且不带自动行刷新的新打印流
  - `PrintStream(File file, String csn)`：创建具有指定文件名称和字符集且不带自动行刷新的新打印流
  - `PrintStream(OutputStream out)`：创建新的打印流
  - `PrintStream(OutputStream out, boolean autoFlush)`：创建新的打印流，`autoFlush`如果为`true`，则每当写入`byte`数组、调用其中一个`println`方法、写入换行符或字节 `('\n')`时都会刷新输出缓冲区
  - `PrintStream(OutputStream out, boolean autoFlush, String encoding)`：创建新的打印流
  - `PrintStream(String fileName)`：创建具有指定文件名称且不带自动行刷新的新打印流
  - `PrintStream(String fileName, String csn)`：创建具有指定文件名称和字符集且不带自动行刷新的新打印流

**案例代码**`**1**`**（**`**PrintStream**`**测试）：**

```java
import java.io.FileNotFoundException;
import java.io.PrintStream;

public class PrintStreamTest {
    public static void main(String[] args) throws FileNotFoundException {
        // 创建流对象
        PrintStream printStream = new PrintStream("PrintStreamTest.txt");
        // 写出数据
        printStream.println("hello");
        printStream.println(1);
        printStream.println(1.5);
        // 关闭资源
        printStream.close();
    }
}
```

**案例代码**`**2**`**（**`**autoFlush**`**测试）：**

```java
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;

public class PrintStreamAutoFlushTest {
    public static void main(String[] args) {
        FileOutputStream fileOutputStream = null;
        PrintStream printStream = null;

        try {
            fileOutputStream = new FileOutputStream("PrintStreamAutoFlushTest.txt");
            // 创建打印输出流 设置为自动刷新模式 (写入换行符或字节 '\n' 时都会刷新输出缓冲区)
            printStream = new PrintStream(fileOutputStream, true);
            // 把掉准输出流改为文件
            System.setOut(printStream);
            // 输出ASCII字符
            for (int i = 0; i <= 255; i++) {
                System.out.print(((char) i));
                // 50个数据一行
                if (i % 50 == 0) {
                    // 换行
                    System.out.println();
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            if (printStream != null) {
                printStream.close();
            }
        }

    }
}
```

**案例代码**`**3**`**（自定义一个日志工具）：**

```java
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.text.SimpleDateFormat;
import java.util.Date;

public class PrintStreamLoggerTest {
    public static void main(String[] args) {
        MyLogger.log("调用了System类的gc()方法...");
        MyLogger.log("调用了TeamView的addMember()方法");
        MyLogger.log("用户尝试进行登录，验证失败");
    }
}

/**
 * 自定义日志工具
 */
class MyLogger {
    /**
     * 日志记录方法
     */
    public static void log(String msg) {
        try {
            // 指向一个文件 追加
            PrintStream printStream = new PrintStream(new FileOutputStream("PrintStreamLoggerTest-logs.txt", true));
            // 改变输出方向
            System.setOut(printStream);
            // 当前时间
            Date date = new Date();
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("[yyyy-MM-dd HH:mm:ss SSS]");
            String formatDate = simpleDateFormat.format(date);
            // 输出
            System.out.println(formatDate + ": " + msg);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733390031016-ec7b5e2f-1ff8-4039-b3fa-cba9316828ca.png)

#### `Scanner`类

##### 构造器

- `Scanner(File source)`：构造`Scanner`，它生成的值是从**指定文件扫描**的
- `Scanner(File source, String charsetName)`：构造`Scanner`，它生成的值是从**指定文件扫描的，指定字符集设置**
- `Scanner(InputStream source)`：构造`Scanner`，它生成的值是从**指定的输入流扫描**的
- `Scanner(InputStream source, String charsetName)`：构造`Scanner`，它生成的值是**从指定的输入流扫描的，指定字符集设置**

##### 常用方法

- `boolean hasNextXxx()`：**<font style="color:#DF2A3F;">通过使用</font>**`**<font style="color:#DF2A3F;">nextXxx()</font>**`**<font style="color:#DF2A3F;">方法，此扫描器输入信息中的下一个标记可以解释为默认基数中的一个</font>**`**<font style="color:#DF2A3F;">Xxx</font>**`**<font style="color:#DF2A3F;">值，则返回</font>**`**<font style="color:#DF2A3F;">true</font>**`

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733390470938-d32760cf-6911-4d0e-94d2-f5ee04045a63.png)

- `Xxx nextXxx()`：**将输入信息的下一个标记扫描为一个**`**Xxx**`

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733390496481-88ff12d3-f154-43b8-bf4a-58ad62ca0ea7.png)

### `apache-common`包的使用

#### 介绍

`**<font style="color:#DF2A3F;">IO</font>**`**<font style="color:#DF2A3F;">技术开发中，代码量很大，而且代码的重复率较高，为此</font>**`**<font style="color:#DF2A3F;">Apache</font>**`**<font style="color:#DF2A3F;">软件基金会开发了</font>**`**<font style="color:#DF2A3F;">IO</font>**`**<font style="color:#DF2A3F;">技术的工具类</font>**`**<font style="color:#DF2A3F;">commonsIO</font>**`**<font style="color:#DF2A3F;">，大大简化了</font>**`**<font style="color:#DF2A3F;">IO</font>**`**<font style="color:#DF2A3F;">开发</font>**

#### 导包

- 导入`commons-io-2.5.jar`包之后，内部的`API`都可以使用

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1733216829574-4ed418f0-71a4-4f88-8c98-9316d70c4f38.png)

#### 使用样例

###### `IOUtils`类的使用

- `**IOUtils.copy(InputStream in,OutputStream out)**`**：**传递字节流实现文件复制
- `**IOUtils.closeQuietly(任意流对象)**`**：**悄悄的释放资源，自动处理`close()`方法抛出的异常

```java
public class CommonsIOTest {
    /**
     * IOUtils.copy(InputStream in,OutputStream out)
     */
    @Test
    public void copyTest() {
        try {
            IOUtils.copy(new FileInputStream("file-gbk.txt"), new FileOutputStream("copy-file-gbk.txt"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * IOUtils.closeQuietly(任意流对象)
     */
    @Test
    public void closeQuietlyTest() {
        FileWriter fileWriter = null;

        try {
            fileWriter = new FileWriter("copy-file-gbk.txt");
            fileWriter.write("test");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(fileWriter);
        }
    }
}
```

###### `FileUtils`类的使用

- `void copyDirectoryToDirectory(File src,File dest)`：整个目录的复制，**<font style="color:#DF2A3F;">自动进行递归遍历</font>**，`src`要复制的文件夹路径，`dest`要将文件夹粘贴到哪里去
- `void writeStringToFile(File file,String content)`：将内容`content`写入到`file`中
- `String readFileToString(File file)`：读取文件内容，并返回一个`String`
- `void copyFile(File srcFile,File destFile)`：文件复制
