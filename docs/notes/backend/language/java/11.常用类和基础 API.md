---
title: 11 常用类和基础 API
createTime: 2025/08/22 22:41:51
permalink: /language/java/weqlsenw/
---
## 不可变字符序列 `String`

### `String`的特性

1. `java.lang.String`类代表字符串，Java 程序中所有的字符串文字（例如`"hello"`）都可以看作是实现此类的实例

2. 字符串是常量，用双引号引起来表示，它们的值在创建之后不能更改

3. 字符串`String`类型本身是`final`声明的，意味着不能继承`String`

4. `String`对象的字符内容是存储在一个字符数组`value[]`中的，`"abc"`等效于`char[] data = {'a','b','c'}`（JDK9 之前）

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199171030-216c4f23-0ded-4144-bf6b-0e5c70b06e60.png)

```java
 // jdk8中的String源码：底层采用char数组存储内容
 public final class String
     implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[]; // String对象的字符内容是存储在此数组中

    /** Cache the hash code for the string */
    private int hash; // Default to 0
//  ...
}
```

- `private`意味着**外面无法直接获取字符数组，**`String`没有提供`value`的`get`和`set`方法

- `final`**意味着字符数组的引用不可改变**，而且`String`也没有提供方法来修改 value 数组某个元素值

- **因此字符串的字符数组内容也是不可变的，**即**`String`**代表着不可变的字符序列**，一旦对字符串进行修改，就会产生新对象**

- **JDK9 之后，底层使用**`byte[]`**数组**

```java
 // jdk9之后的String源码：底层采用byte数组存储内容
public final class String
     implements java.io.Serializable, Comparable<String>, CharSequence {
     @Stable
     private final byte[] value;
 }

 //官方说明：... that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.

 //细节：... The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.

```

- **Java 语言提供对**字符串串联符号"+"**以及将其他对象转换为字符串的特殊支持**`toString()`**方法**

### String的内存结构

**因为字符串对象设计为不可变，所以字符串由常量池来保存很多常量对象。** JDK6中，字符串常量池在方法区，JDK7开始，就移到堆空间。

内存结构分配举例：

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199190546-1561c04a-acf5-49b4-80d8-8f7aa5d37cd7.png)

### 练习1：拼接

```java
String s1 = "hello";
String s2 = "hello";
// 内存中只有一个"hello"对象被创建，同时被s1和s2共享。 true
System.out.println(s1 == s2);
```

对应内存结构为（以 JDK6 为例绘制）：

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199198407-847de0b6-f329-47ad-9324-670ed11124bc.png)

进一步：

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199203822-b291d64a-5c98-406c-804e-a435f18eb6ee.png)

```java
Person p1 = new Person();
p1.name = "Tom";

Person p2 = new Person();
p2.name = "Tom";

System.out.println(p1.name.equals(p2.name)); // true
System.out.println(p1.name == p2.name); // false
System.out.println(p1.name == "Tom"); // false
```

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199209634-b8ab24cd-d6f2-4ce5-b83a-5e98b8cc4f8d.png)

### 练习2：`new`

`String str1 = "abc"` 与 `String str2 = new String("abc")`的区别？

`// str1 == str2 false`

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199216067-21efaa67-9c02-4178-a772-c9dd4af13325.png)

`str2`**首先指向堆中的一个字符串对象，堆中字符串的**`value`**数组指向常量池常量对象的**`value`**数组**

- **字符串常量存储在字符串常量池，目的是共享**
- **字符串非常量对象存储在堆中**

练习：

```java
String s1 = "javaEE";
String s2 = "javaEE";
String s3 = new String("javaEE");
String s4 = new String("javaEE");

System.out.println(s1 == s2); // true
System.out.println(s1 == s3); // false
System.out.println(s1 == s4); // false
System.out.println(s3 == s4); // false
```

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199221220-24cb1edc-e9b3-4596-bc8a-b249a354ae14.png)

练习：

`String str2 = new String("hello");`在内存中创建了几个对象？  
**答案**：一个或两个

> - 字符串常量池中不存在 "hello"：会创建 2 个 字符串对象。一个在字符串常量池中，由 `ldc` 指令触发创建。一个在堆中，由 `new String()`创建，并使用常量池中的 "hello" 进行初始化。
> - 字符串常量池中已存在 "hello"：会创建 1 个 字符串对象。该对象在堆中，由`new String()`创建，并使用常量池中的 "hello" 进行初始化。

**参考 JavaGuide：**[**Java基础常见面试题总结(中)**](https://javaguide.cn/java/basis/java-basic-questions-02.html#string-s1-new-string-abc-%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1)

### 练习3：`intern()`

`intern()`是`String`类中的一个方法，它的作用是返回字符串的规范化表示形式。`intern()`方法会检查字符串常量池（String Pool），如果常量池中已经存在与当前字符串内容相同的字符串，则返回常量池中的引用；否则，将当前字符串添加到常量池中，并返回该引用。

- `String s1 = "a";`

    说明：在字符串常量池中创建了一个字面量为`"a"`的字符串。

- `s1 = s1 + "b";`

    说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+"b"（也就是"ab")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。

    **如果这样的操作放到循环中，会极大影响程序的性能。**

    **参考 JavaGuide：**[**Java基础常见面试题总结(中)**](https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%94%A8-%E8%BF%98%E6%98%AF-stringbuilder)

- `String s2 = "ab";`

    说明：直接在字符串常量池中创建一个字面量为"ab"的字符串。

- `String s3 = "a" + "b";`

    说明：s3指向字符串常量池中已经创建的"ab"的字符串。

- `String s4 = s1.intern();`

    说明：**堆空间的s1对象在调用intern()之后，会将常量池中已经存在的"ab"字符串赋值给s4。**

练习:

```java
String s1 = "hello"; // 指向常量池
String s2 = "world"; // 指向常量池
String s3 = "hello" + "world"; // 指向常量池
String s4 = s1 + "world"; // 指向堆
String s5 = s1 + s2; // 指向堆
String s6 = (s1 + s2).intern(); // 指向常量池

System.out.println(s3 == s4); // false
System.out.println(s3 == s5); // false
System.out.println(s4 == s5); // false
System.out.println(s3 == s6); // true
```

结论：

- **调用**`+`**除非两侧都是字面量，否则最终都会在堆中生成 String 对象，只是说底层可能指向常量池中相同的对象**

- **常量+常量：结果是常量池，且常量池中不会存在相同内容的常量**

- **常量与变量 或 变量与变量：结果在堆中**

- **拼接后调用intern方法：返回值在常量池中**

练习：

```java
@Test
public void test01(){
    String s1 = "hello";
    String s2 = "world";
    String s3 = "helloworld";

    // s4字符串内容也helloworld，s1是变量，"world"常量，变量 + 常量的结果在堆中
    String s4 = s1 + "world";
    // s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中
    String s5 = s1 + s2;
    // 常量+ 常量 结果在常量池中，因为编译期间就可以确定结果
    String s6 = "hello" + "world";

    System.out.println(s3 == s4); // false
    System.out.println(s3 == s5); // false
    System.out.println(s3 == s6); // true
}

@Test
public void test02(){
    final String s1 = "hello";
    final String s2 = "world";
    String s3 = "helloworld";

    // s4字符串内容也helloworld，s1是常量，"world"常量，常量+常量结果在常量池中
    String s4 = s1 + "world";
    // s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中
    String s5 = s1 + s2;
    // 常量+ 常量 结果在常量池中，因为编译期间就可以确定结果
    String s6 = "hello" + "world";

    System.out.println(s3 == s4); // true
    System.out.println(s3 == s5); // true
    System.out.println(s3 == s6); // true
}

@Test
public void test01(){
    String s1 = "hello";
    String s2 = "world";
    String s3 = "helloworld";

    //把拼接的结果放到常量池中
    String s4 = (s1 + "world").intern();
    String s5 = (s1 + s2).intern();

    System.out.println(s3 == s4); // true
    System.out.println(s3 == s5); // true
}
```

练习：下列程序运行的结果

```java
public class TestString {
    public static void main(String[] args) {
        String str = "hello";
        String str2 = "world";
        String str3 = "helloworld";

        String str4 = "hello".concat("world");
        String str5 = "hello"+"world";

        System.out.println(str3 == str4); // false
        System.out.println(str3 == str5); // true
    }
}
```

**concat方法拼接，哪怕是两个常量对象拼接，结果也是在堆。**

- `concat`是`String`类的一个方法，用于连接两个字符串。

- 调用`concat`方法时，会生成一个新的`String`对象。

练习：下列程序运行的结果

```java
public class StringTest {

    String str = new String("good");
    char[] ch = { 't', 'e', 's', 't' };

    public void change(String str, char ch[]) {
        str = "test ok";
        ch[0] = 'b';
    }
    public static void main(String[] args) {
        SeStringTest seStringTest = new SeStringTest();
        seStringTest.change(seStringTest.str, seStringTest.ch);
        // good and [b, e, s, t]
        System.out.println(seStringTest.str + " and " + Arrays.toString(seStringTest.ch));
    }
}
```

### String 的常用 API-1

#### 构造器

- `public String()`：初始化新创建的String对象，以使其表示空字符序列

- `String(String original)`：初始化一个新创建的String 对象，新创建字符串是该字符串的副本

- `public String(char[] value)`：通过当前参数中的字符数组来构造新的String

- `public String(char[] value,int offset, int count)`：通过字符数组的一部分来构造新的String

- `public String(byte[] bytes)`：通过使用平台的**默认字符集解码**当前参数中的字节数组来构造新的String

- `public String(byte[] bytes,String charsetName)`：通过**使用指定的字符集解码**当前参数中的字节数组来构造新的String

#### String 与其他结构间的转换

**字符串 **转** 基本数据类型、包装类：**

- `Integer`包装类的`public static int parseInt(String s)`：可以将由“数字”字符组成的字符串转换为整型

- `java.lang`包中的`Byte、Short、Long、Float、Double`类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。

**基本数据类型、包装类**转 **字符串：**

- `String`类的`public String valueOf(int n)`可将`int`型转换为字符串

- 相应的`valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)`可实现参数的相应类型到字符串的转换

**字符数组 **转** 字符串：**

- `String`类的构造器：`String(char[])`和`String(char[]，int offset，int length)` 分别用字符数组中的全部字符和部分字符创建字符串对象

**字符串 **转** 字符数组：**

- `public char[] toCharArray()`：将字符串中的全部字符存放在一个字符数组中

- `public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)`：提供了将指定索引范围内的字符串存放到数组中的方法

**字符串 **转** 字节数组：（编码）**

- `public byte[] getBytes()`：使用平台的**默认字符集**将此`String`编码为`byte`序列，并将结果存储到一个**新的**`byte`**数组**中

- `public byte[] getBytes(String charsetName)`：用**指定的字符集**将`String`编码到`byte`序列，并将结果存储到**新的**`byte`**数组**

**字节数组 **转** 字符串：（解码）**

- `String(byte[])`：通过使用平台的**默认字符集解码指定的**`byte`**数组**，构造一个新的`String`

- `String(byte[]，int offset，int length)`：用**指定的字节数组的一部分**，从数组起始位置`offset`开始取`length`个字节构造一个字符串对象

- `String(byte[], String charsetName)`或`new String(byte[], int, int,String charsetName)`：解码，按照**指定的字符集进行解码**

### String 的常用 API-2

#### 常用方法

- `boolean isEmpty()`：字符串**是否为空**

- `int length()`：返回字符串的**长度**

- `String concat(xx)`：**拼接**

- `boolean equals(Object obj)`：比较**字符串是否相等，区分大小写**

- `boolean equalsIgnoreCase(Object obj)`：比较**字符串是否相等，不区分大小写**

- `int compareTo(String other)`：**比较字符串大小**，区分大小写，按照`Unicode`编码值比较大小

- `int compareToIgnoreCase(String other)`：**比较字符串大小，不区分大小写**

- `String toLowerCase()`：将字符串中大写字母**转为小写**

- `String toUpperCase()`：将字符串中小写字母**转为大写**

- `String trim()`：**去掉字符串前后空白符**

- `public String intern()`：**结果在常量池中共享**

#### 查找

- `boolean contains(xx)`：是否**包含xx**

- `int indexOf(xx)`：**从前往后找当前字符串中xx，即如果有返回第一次出现的下标，没有返回-1**

- `int indexOf(String str, int fromIndex)`：**返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始**

- `int lastIndexOf(xx)`：**从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1**

- `int lastIndexOf(String str, int fromIndex)`：**返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。**

#### 字符串截取

- `String substring(int beginIndex)`：返回一个新的字符串，是此字符串从`beginIndex`开始**截取**到最后的一个子字符串

- `String substring(int beginIndex, int endIndex)`：返回一个新字符串，是此字符串从`beginIndex`开始**截取**到`endIndex`(不包含)的一个子字符串

#### 字符、字符数组相关

- `char charAt(index)`：返回`[index]`位置的字符

- `char[] toCharArray()`：将此字符串**转换为一个新的字符数组**返回

- `static String valueOf(char[] data)`：**返回指定数组中表示该字符序列的**`String`

- `static String valueOf(char[] data, int offset, int count)`：**返回指定数组中表示该字符序列的**`String`

- `static String copyValueOf(char[] data)`：返回指定数组中表示该字符序列的 `String`

- `static String copyValueOf(char[] data, int offset, int count)`：返回指定数组中表示该字符序列的 `String`

#### 开头与结尾

- `boolean startsWith(xx)`：测试此字符串**是否以指定的前缀开始**

- `boolean startsWith(String prefix, int toffset)`：测试此字符串**从指定索引开始的子字符串是否以指定前缀开始**

- `boolean endsWith(xx)`：测试此字符串**是否以指定的后缀结束**

##### 替换

- `String replace(char oldChar, char newChar)`：**返回一个新的字符串**，通过用`newChar`**替换**此字符串中出现的所有`oldChar`得到的，不支持正则

- `String replace(CharSequence target, CharSequence replacement)`：**用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串**

- `String replaceAll(String regex, String replacement)`：**用给定的**`replacement`**替换此字符串所有匹配给定的正则表达式的子字符串**

- `String replaceFirst(String regex, String replacement)`：用给定的`replacement`**替换此字符串匹配给定的正则表达式的第一个子字符串**

## 可变字符序列 `StringBuffer`、`StringBuilder`

**因为**`String`**对象是不可变对象，虽然可以共享常量对象，但是对于频繁字符串的修改和拼接操作，效率极低，空间消耗也比较高 。因此，JDK又在**`java.lang`**包提供了可变字符序列**`StringBuffer`**和**`StringBuilder`**类型。**

### `StringBuffer`与`StringBuilder`

- `java.lang.StringBuffer`**代表可变的字符序列**，JDK1.0中声明，**可以对字符串内容进行增删，此时不会产生新的对象**

```java
 // 情况1
 String s = new String("我喜欢学习");
 // 情况2
 StringBuffer buffer = new StringBuffer("我喜欢学习");
 buffer.append("数学");
```

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199238180-4e7ded0b-b2af-4d53-aa82-262242ce8118.png)

- **继承结构：**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199242110-e432252a-743c-4503-9eda-8815f9c4c764.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199246735-8830f91e-5299-4d22-8c53-0f55824110d2.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199254684-75a2ba9e-f979-4fef-b23e-c82d02f57e61.png)

- `StringBuilder`和`StringBuffer`非常类似，代表可变的字符序列，提供相关功能的方法也一样

- **区分**`String`**、**`StringBuffer`**、**`StringBuilder`

  - `String`：不可变的字符序列

  - `StringBuffer`：可变的字符序列，**线程安全**（方法由`synchronized`修饰），**效率低**

  - `StringBuilder`：可变的字符序列，`jdk1.5`引入，**线程不安全**，**效率高**

### `StringBuilder`、`StringBuffer`的API

`StringBuilder`、`StringBuffer`的API是完全一致的，并且很多方法与`String`相同

#### 常用API

- `StringBuffer append(xx)`：用于**进行字符串追加的方式拼接**

- `StringBuffer delete(int start, int end)`：**删除**`[start,end)`之间字符

- `StringBuffer deleteCharAt(int index)`：**删除**`[index]`位置字符

- `StringBuffer replace(int start, int end, String str)`：**替换**`[start,end)`范围的字符

- `void setCharAt(int index, char c)`：**替换**`[index]`位置字符

- `char charAt(int index)`：**查找**指定`index`位置上的字符

- `StringBuffer insert(int index, xx)`：**在**`[index]`**位置插入xx**

- `int length()`：返回存储的字符数据的**长度**

- `StringBuffer reverse()`：**反转**

- 当`append`和`insert`时，如果原来`value`数组长度不够，可扩容

- 如上`append、delete、deleteCharAt、replace、reverse`这些方法**支持方法链操作**。

原理：

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199264919-008b7017-6967-4099-a920-abbe2e12092c.png)

##### 其它API

- `int indexOf(String str)`：在当前字符序列中**查询**`str`**的第一次出现下标**
- `int indexOf(String str, int fromIndex)`：在当前字符序列`[fromIndex,length - 1]`**中查询**`str`**的第一次出现下标**
- `int lastIndexOf(String str)`：在当前字符序列中**查询**`str`**的最后一次出现下标**
- `int lastIndexOf(String str, int fromIndex)`：**在当前字符序列**`[fromIndex,最后]`**中查询str的最后一次出现下标**
- `String substring(int start)`：**截取**当前字符序列`[start,最后]`
- `String substring(int start, int end)`：**截取**当前字符序列`[start,end)`
- `String toString()`：**返回此序列中数据的字符串表示形式**
- `void setLength(int newLength)`：**设置当前字符序列长度为**`newLength`

```java
public class StringBuilderAndStringBufferTest {
    public static void test1() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("hello").append(true).append('a').append(12).append("weew12");
        System.out.println(stringBuilder.length());
        System.out.println(stringBuilder);
    }

    public static void test2() {
        StringBuilder s = new StringBuilder("hello world");
        System.out.println(s.charAt(5));
        s.insert(5, "java");
        s.insert(5, "weew12");
        System.out.println(s);
    }

    public static void test3() {
        StringBuilder s = new StringBuilder("hello world");
        s.delete(1, 3);
        s.deleteCharAt(4);
        System.out.println(s);
    }

    public static void test4() {
        StringBuilder s = new StringBuilder("hello world");
        s.reverse();
        System.out.println(s);
    }

    public static void test5() {
        StringBuilder s = new StringBuilder("hello world");
        s.setCharAt(2, 'a');
        System.out.println(s);
    }

    public static void test6() {
        StringBuilder s = new StringBuilder("hello world");
        System.out.println(s.length());
        s.setLength(30);
        // hello world
        System.out.println(s);
    }

    public static void main(String[] args) {
//        test1();
//        test2();
//        test3();
//        test4();
//        test5();
        test6();
    }
}
```

### 效率测试

```java
public class StringBuilderAndStringBufferEfficiencyTest {

    public static void main(String[] args) {
        long startTime = 0L;
        long endTime = 0L;

        String text = "";
        StringBuilder stringBuilder = new StringBuilder("");
        StringBuffer stringBuffer = new StringBuffer("");

        // StringBuilder
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 20000; i++) {
            stringBuilder.append(String.valueOf(i));
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuilder的执行时间：" + (endTime - startTime));

        // StringBuffer
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 20000; i++) {
            stringBuffer.append(String.valueOf(i));
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuffer的执行时间：" + (endTime - startTime));

        // String
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 20000; i++) {
            text = text + i;
        }
        endTime = System.currentTimeMillis();
        System.out.println("String的执行时间：" + (endTime - startTime));
    }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732276436808-080527b1-d9aa-49e8-bf07-d80e1c539515.png)

### 练习

笔试题：程序输出

```java
String str = null;
StringBuffer sb = new StringBuffer();
// 这里内部调用了其父类AbstractStringBuilder的append(),
// 其中对于str为null的处理调用了一个AppendNull()方法，直接添加的“null”
sb.append(str);
// 4
System.out.println(sb.length());
// null
System.out.println(sb);

StringBuffer sb1 = new StringBuffer(str);
// NullPointerException: Cannot invoke "String.length()" because "str" is null
// System.out.println(sb1);
```

`StringBuffer append()`

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732276707432-58a755b9-3017-4f39-9d4e-eb7621f22966.png)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732276720850-f776196f-e7df-4638-b1f4-94357840195d.png)

**调用的父类**`AbstractStringBuilder`**的**`append()`

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732276733984-51f17514-3c54-4116-a421-c60baee4ad44.png)

`appendNull()`**把**`null`**处理为**`“null”`**字符串**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732276744783-50dd9853-34a9-4ba1-a3d4-e0c395a2de0a.png)

## 日期时间API（JDK8之前）

### `java.lang.System`类的方法

- `System`类提供的`public static long currentTimeMillis()`：**返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差**

  - 此方法适于计算时间差

- **计算世界时间的主要标准**

  - `UTC(Coordinated Universal Time)`**通用协调时**

  - `GMT(Greenwich Mean Time)`**格林尼治平均时**

  - `CST(Central Standard Time)`

    - 在国际无线电通信场合，为了统一，使用一个统一的时间，称为通用协调时(**UTC**)。UTC与格林尼治平均时(**GMT**)一样，**都与英国伦敦的本地时相同**。这里，UTC与GMT含义完全相同

### `java.util.Date`

**表示特定的瞬间，精确到毫秒:**

- 构造器

  - `Date()`：无参构造器创建的对象可以**获取本地当前时间**

  - `Date(long 毫秒数)`**：把该毫秒值换算成日期时间对象**

- 常用方法

  - `getTime()`: **返回自**`1970年1月1日 00:00:00 GMT`**以来，此**`Date`**对象表示的毫秒数**

  - `toString()`: 把此`Date`对象转换为`String`：`dow mon dd hh:mm:ss zzz yyyy`其中：`dow`是**一周中的某一天**`(Sun, Mon, Tue, Wed, Thu, Fri, Sat)`，`zzz`是**时间标准**

  - 其它很多方法都过时了

举例：

```java
public class JavaUtilDateTest {
    public static void main(String[] args) {
        Date date = new Date();
//        Fri Nov 22 20:20:30 CST 2024
        System.out.println(date);

        long time = System.currentTimeMillis();
//        1732278030332
//        当前系统时间距离1970-1-1 0:0:0 0毫秒的时间差，毫秒为单位
        System.out.println(time);

        Date date1 = new Date();
        long time1 = date1.getTime();
//        1732278030332
        System.out.println(time1);

        long curTime = 1732278030332L;
        Date date2 = new Date(curTime);
//        Fri Nov 22 20:20:30 CST 2024
        System.out.println(date2);

        long time2 = Long.MAX_VALUE;
        Date date3 = new Date(time2);
//        Sun Aug 17 15:12:55 CST 292278994
        System.out.println(date3);
    }
}
```

### `java.text.SimpleDateFormat`

`java.text.SimpleDateFormat`**是一个不与语言环境有关的方式来格式化和解析日期的具体类**

- 可以进行格式化：**日期** **转** **文本**

- 可以进行解析：**文本** **转** **日期**

- 构造器

  - `SimpleDateFormat()`：**默认的模式和语言环境**创建对象

  - `public SimpleDateFormat(String pattern)`：**用参数**`pattern`**指定的格式创建一个对象**

- 格式化

  - `public String format(Date date)`：**格式化时间对象**`date`

- 解析

  - `public Date parse(String source)`：**从给定字符串的开始解析文本，生成一个日期**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199281174-baf11447-e775-4b05-855b-7c8ea7ad0689.png)

```java
public class SimpleDateFormatTest {
    public static void main(String[] args) {
        // 格式化
        Date date = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒 E Z");
        String format = simpleDateFormat.format(date);
//        2024年11月22日 20时31分04秒 926毫秒 周五 +0800
        System.out.println(format);

        // 解析
        String dateStr = "2024年11月22日 20时31分04秒 926毫秒 周五 +0800";
        try {
            Date parseRes = simpleDateFormat.parse(dateStr);
//            Fri Nov 22 20:31:04 CST 2024
            System.out.println(parseRes);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
}
```

### `java.util.Calendar`(日历)

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199287570-753b9b2e-2606-4ef3-8de9-95a513a04c42.png)

- `Date`**类的API大部分被废弃了，替换为**`Calendar`
- `Calendar`**类是一个抽象类**，主用于完成日期字段之间相互操作的功能
- 获取`Calendar`实例的方法
  - `Calendar.getInstance()`方法

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199293363-7281bf60-576d-4187-842d-c8c25d310e31.png)

- 调用它的子类`GregorianCalendar`（公历）的构造器

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199297380-ba18a3e5-41e0-4731-824c-dfbd97910a8f.png)

- **一个**`Calendar`**的实例是系统时间的抽象表示，可以修改或获取**`YEAR、MONTH、DAYOFWEEK、HOUROFDAY 、MINUTE、SECOND` 等日历字段对应的时间值
  - `public int get(int field)`：**返回给定日历字段的值**
  - `public void set(int field,int value)`：**将给定的日历字段设置为指定的值**
  - `public void add(int field,int amount)`：**为给定的日历字段添加或者减去指定的时间量**
  - `public final Date getTime()`：**将**`Calendar`**转成**`Date`**对象**
  - `public final void setTime(Date date)`：**使用指定的**`Date`**对象重置**`Calendar`**的时间**
- 常用字段

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199302602-9d977110-e782-45ae-af92-1f1b07a46b2a.png)

- 注意
  - **获取月份时：一月是0，二月是1，以此类推，12月是11**
  - **获取星期时：周日是1，周一是2 ， ... 周六是7**

示例代码：

```java
import org.junit.Test;

import java.util.Calendar;
import java.util.TimeZone;

public class TestCalendar {
    @Test
    public void test1(){
        Calendar c = Calendar.getInstance();
        System.out.println(c);

        int year = c.get(Calendar.YEAR);
        int month = c.get(Calendar.MONTH)+1;
        int day = c.get(Calendar.DATE);
        int hour = c.get(Calendar.HOUR_OF_DAY);
        int minute = c.get(Calendar.MINUTE);

        System.out.println(year + "-" + month + "-" + day + " " + hour + ":" + minute);
    }

    @Test
    public void test2(){
        TimeZone t = TimeZone.getTimeZone("America/Los_Angeles");
        Calendar c = Calendar.getInstance(t);
        int year = c.get(Calendar.YEAR);
        int month = c.get(Calendar.MONTH)+1;
        int day = c.get(Calendar.DATE);
        int hour = c.get(Calendar.HOUR_OF_DAY);
        int minute = c.get(Calendar.MINUTE);

        System.out.println(year + "-" + month + "-" + day + " " + hour + ":" + minute);
    }

    @Test
    public void test3(){
        Calendar calendar = Calendar.getInstance();
        // 从一个 Calendar 对象中获取 Date 对象
        Date date = calendar.getTime();

        // 使用给定的 Date 设置此 Calendar 的时间
        date = new Date(234234235235L);
        calendar.setTime(date);
        calendar.set(Calendar.DAY_OF_MONTH, 8);
        System.out.println("当前时间日设置为8后,时间是:" + calendar.getTime());

        calendar.add(Calendar.HOUR, 2);
        System.out.println("当前时间加2小时后,时间是:" + calendar.getTime());

        calendar.add(Calendar.MONTH, -2);
        System.out.println("当前日期减2个月后,时间是:" + calendar.getTime());
    }
}
```

## 新的日期时间API（JDK8之后）

`JDK 1.0`中包含了一个`java.util.Date`类，但是它的大多数方法已经在`JDK 1.1`引入`Calendar`类之后**被弃用了**。**而**`Calendar`**并不比**`Date`**好多少**。它们面临的问题：

- 可变性：像日期和时间这样的类应该是不可变的
- 偏移性：`Date`中的年份是从`1900`开始的，而月份都从`0`开始
- 格式化：**格式化只对**`Date`**有用，**`Calendar`**则不行**
- 此外，**它们也不是线程安全的**，**不能处理闰秒**等

**闰秒**：是指**为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时增加或减少1秒的调整**。由于地球自转的不均匀性和长期变慢性（主要由潮汐摩擦引起的），会使世界时（民用时）和原子时之间相差超过到±0.9秒时，就把协调世界时向前拨1秒（负闰秒，最后一分钟为59秒）或向后拨1秒（正闰秒，最后一分钟为61秒）， 闰秒一般加在公历年末或公历六月末。目前，全球已经进行了27次闰秒，均为正闰秒。

**对日期和时间的操作一直是Java程序员最痛苦的地方之一。**

**第三次引入的API是成功的，并且**`Java 8`**中引入的**`java.time`**API已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务**

`Java 8`以一个新的开始为Java 创建优秀的 API，新的日期时间API包含：

- `java.time`– 包含值对象的**基础包**
- `java.time.chrono`– 提供**对不同的日历系统的访问**
- `java.time.format`– **格式化和解析时间和日期**
- `java.time.temporal`– 包括底层框架和扩展特性
- `java.time.zone` – 包含**时区支持**的类

**说明**：新的`java.time`中包含了所有**时钟**`Clock`、**本地日期**`LocalDate`、**本地时间**`LocalTime`**、本地日期时间**`LocalDateTime`**、时区**`ZonedDateTime`、**持续时间**`Duration`的类。尽管有`68`个新的公开类型，但是**大多数开发者只会用到基础包和**`format`**包**，大概占总数的三分之一

### 本地日期时间：`LocalDate`、`LocalTime`、`LocalDateTime`

- `now() / now(ZoneId zone)`：静态方法，根据当前时间**创建**对象 / 指定时区对象
- `of(xx,xx,xx,xx,xx,xxx)`：静态方法，根据指定日期 / 时间**创建**对象
- `getDayOfMonth() / getDayOfYear()`：**获得月份天数**(1-31) / **获得年份天数**(1-366)
- `getDayOfWeek()`：**获得星期几**(返回一个 DayOfWeek 枚举值)
- `getMonth()`：**获得月份**, 返回一个 Month 枚举值
- `getMonthValue() / getYear()`：**获得月份**(1-12) / **获得年份**
- `getHours() / getMinute() / getSecond()`：**获得当前对象对应的小时、分钟、秒**
- `withDayOfMonth() / withDayOfYear() / withMonth() / withYear()`：将月份天数、年份天数、月份、年份**修改**为指定的值并返回新的对象
- `with(TemporalAdjuster t)`：**将当前日期时间设置为校对器指定的日期时间**
- `plusDays() / plusWeeks() / plusMonths()  / plusYears() / plusHours()`：向当前对象**添加**几天、几周、几个月、几年、几小时
- `minusMonths() / minusWeeks() / minusDays() / minusYears() / minusHours()`：从当前对象**减去**几月、几周、几天、几年、几小时
- `plus(TemporalAmount t)/minus(TemporalAmount t)`: **添加或减少一个**`Duration`**或**`Period`
- `isBefore() / isAfter()`：**比较两个**`LocalDate`
- `isLeapYear()`：判断**是否是闰年**（在`LocalDate`类中声明）
- `format(DateTimeFormatter t)`：**格式化本地日期、时间，返回一个字符串**
- `parse(Charsequence text)`：**将指定格式的字符串解析为日期、时间**

```java
import org.junit.Test;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;


public class TestLocalDateTime {

    @Test
    public void test01(){
        LocalDate now = LocalDate.now();
//        2024-11-22
        System.out.println(now);
    }

    @Test
    public void test02(){
        LocalTime now = LocalTime.now();
//        21:37:17.588601800
        System.out.println(now);
    }

    @Test
    public void test03(){
        LocalDateTime now = LocalDateTime.now();
//        2024-11-22T21:37:29.759247700
        System.out.println(now);
    }

    @Test
    public void test04(){
        LocalDate lai = LocalDate.of(2019, 5, 13);
//        2019-05-13
        System.out.println(lai);
    }

    @Test
    public void test05(){
        LocalDate lai = LocalDate.of(2019, 5, 13);
//        133
        System.out.println(lai.getDayOfYear());
    }

    @Test
    public void test06(){
        LocalDate lai = LocalDate.of(2019, 5, 13);
        LocalDate go = lai.plusDays(160);
//        2019-10-20
        System.out.println(go);
    }

    @Test
    public void test7(){
        LocalDate now = LocalDate.now();
        LocalDate before = now.minusDays(100);
//        2024-08-14
        System.out.println(before);
    }
}
```

#### 瞬时：`Instant`

- `Instant`：时间线上的一个**瞬时点**，这**可能被用来记录应用程序中的事件时间戳**
  - **时间戳**是指**格林威治时间**1970年01月01日00时00分00秒`(北京时间1970年01月01日08时00分00秒)`起至现在的总秒数
- `java.time.Instant`表示时间线上的一点，而不需要任何上下文信息，例如，时区。**概念上讲，它只是简单的表示自**`1970年1月1日0时0分0秒`**（UTC）开始的秒数**

**常用方法：**

- `now()`：静态方法，**返回默认**`UTC`**时区的**`Instant`**类的对象**
- `ofEpochMilli(long epochMilli)`：静态方法，**返回在**`1970-01-01 00:00:00`**基础上**加上指定毫秒数之后**的**`Instant`**类的对象**
- `atOffset(ZoneOffset offset)`：结合即时的偏移来创建一个`OffsetDateTime`
- `toEpochMilli()`：**返回**`1970-01-01 00:00:00`**到当前时间的毫秒数，即为**时间戳

中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与`UTC`的时差均为`+8`，也就是`UTC+8`

```java
instant.atOffset(ZoneOffset.ofHours(8));
```

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199316002-689f75fc-67a4-4264-9ded-9805df3bdd66.png)

**整个地球分为二十四时区，每个时区都有自己的本地时间**。北京时区是东八区，领先`UTC`八个小时，在电子邮件信头的`Date`域记为`+0800`。如果在电子邮件的信头中有这么一行：`Date: Fri, 08 Nov 2002 09:42:22 +0800`说明信件的发送地的地方时间是 `2002年11月8号，星期五，早上9点42分22秒`，这个地方的本地时领先`UTC`八个小时(`+0800`， 东八区时间)，电子邮件信头的`Date`域使用**二十四小时的时钟**，而不使用`AM`和`PM`来标记上下午。

### 日期时间格式化：`DateTimeFormatter`

该类提供了**三种格式化方法**：

- (了解)**预定义**的标准格式，如：`ISOLOCALDATETIME`、`ISOLOCALDATE`、`ISOLOCAL_TIME`
- (了解)**本地化**相关的格式，如：`ofLocalizedDate(FormatStyle.LONG)`

```java
 // 本地化相关的格式。如：ofLocalizedDateTime()
 // FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime

 // 本地化相关的格式。如：ofLocalizedDate()
 // FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate
```

- **自定义**的格式，如：`ofPattern("yyyy-MM-dd hh:mm:ss")`

```java
    LocalDateTime localDateTime = LocalDateTime.now();

    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");
    String format = dateTimeFormatter.format(localDateTime);
//        2024-11-22 10:00:50
    System.out.println(format);
```

**常用方法：**

- `ofPattern(String pattern)`：静态方法，**返回一个指定字符串格式的**`DateTimeFormatter`
- `format(TemporalAccessor t)`：**格式化一个日期、时间，返回字符串**
- `parse(CharSequence text)`：**将指定格式的字符序列解析为一个日期、时间**

举例：

```java
import org.junit.Test;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;

public class TestDatetimeFormatter {
    @Test
    public void test1(){
        // 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME
        DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        // 格式化:日期-->字符串
        LocalDateTime localDateTime = LocalDateTime.now();
        String str1 = formatter.format(localDateTime);
        System.out.println(localDateTime);
        System.out.println(str1);//2022-12-04T21:02:14.808

        // 解析：字符串 -->日期
        TemporalAccessor parse = formatter.parse("2022-12-04T21:02:14.808");
        LocalDateTime dateTime = LocalDateTime.from(parse);
        System.out.println(dateTime);
    }

    @Test
    public void test2(){
        LocalDateTime localDateTime = LocalDateTime.now();
        // 方式二：
        // 本地化相关的格式。如：ofLocalizedDateTime()
        // FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime
        DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);

        // 格式化
        String str2 = formatter1.format(localDateTime);
        System.out.println(str2);// 2022年12月4日 下午09时03分55秒

        // 本地化相关的格式。如：ofLocalizedDate()
        // FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate
        DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);
        // 格式化
        String str3 = formatter2.format(LocalDate.now());
        System.out.println(str3);// 2022年12月4日 星期日
    }

    @Test
    public void test3(){
        //方式三：自定义的方式（关注、重点）
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        //格式化
        String strDateTime = dateTimeFormatter.format(LocalDateTime.now());
        System.out.println(strDateTime); //2022/12/04 21:05:42
        //解析
        TemporalAccessor accessor = dateTimeFormatter.parse("2022/12/04 21:05:42");
        LocalDateTime localDateTime = LocalDateTime.from(accessor);
        System.out.println(localDateTime); //2022-12-04T21:05:42
    }
}
```

### 其它API

##### 1、指定时区日期时间：`ZondId`和`ZonedDateTime`

- `ZoneId`：该类中包含了所有的**时区信息**，一个时区的`ID`，如 `Europe/Paris`
- `ZonedDateTime`：一个在`ISO-8601`日历系统时区的日期时间，如 `2007-12-03T10:15:30+01:00 Europe/Paris`
  - 其中每个时区都对应着`ID`,都为“`{区域}/{城市}`”的格式，例如：`Asia/Shanghai`等
- 常见时区`ID`：`Asia/Shanghai、UTC、America/New_York`
- 可以通过`ZondId`获取所有可用的时区ID

```java
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Set;

public class TestZone {
    @Test
    public void test01() {
        //需要知道一些时区的id
        //Set<String>是一个集合，容器
        Set<String> availableZoneIds = ZoneId.getAvailableZoneIds();
        /*
            Asia/Aden
            America/Cuiaba
            Etc/GMT+9
            Etc/GMT+8
            Africa/Nairobi
            ...
        */
        for (String availableZoneId : availableZoneIds) {
            System.out.println(availableZoneId);
        }
    }

    @Test
    public void test02(){
        ZonedDateTime t1 = ZonedDateTime.now();
//        2024-11-22T22:20:02.202377100+08:00[Asia/Shanghai]
        System.out.println(t1);

        ZonedDateTime t2 = ZonedDateTime.now(ZoneId.of("America/New_York"));
//        2024-11-22T09:20:02.204374700-05:00[America/New_York]
        System.out.println(t2);
    }
}
```

##### 2、持续日期/时间：`Period`和`Duration`

- 持续时间：`Duration`，**用于计算两个“时间”间隔**
- 日期间隔：`Period`，用于**计算两个“日期”间隔**

```java
import org.junit.Test;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Period;

public class TestPeriodDuration {
    @Test
    public void test01(){
        LocalDate t1 = LocalDate.now();
        LocalDate t2 = LocalDate.of(2018, 12, 31);
        Period between = Period.between(t1, t2);

        System.out.println(between);
        System.out.println("相差的年数："+between.getYears());
        System.out.println("相差的月数："+between.getMonths());
        System.out.println("相差的天数："+between.getDays());
        System.out.println("相差的总数："+between.toTotalMonths());
    }

    @Test
    public void test02(){
        LocalDateTime t1 = LocalDateTime.now();
        LocalDateTime t2 = LocalDateTime.of(2017, 8, 29, 0, 0, 0, 0);
        Duration between = Duration.between(t1, t2);
        System.out.println(between);

        System.out.println("相差的总天数："+between.toDays());
        System.out.println("相差的总小时数："+between.toHours());
        System.out.println("相差的总分钟数："+between.toMinutes());
        System.out.println("相差的总秒数："+between.getSeconds());
        System.out.println("相差的总毫秒数："+between.toMillis());
        System.out.println("相差的总纳秒数："+between.toNanos());
        System.out.println("不够一秒的纳秒数："+between.getNano());
    }

    @Test
    public void test03(){
        //Duration:用于计算两个“时间”间隔，以秒和纳秒为基准
        LocalTime localTime = LocalTime.now();
        LocalTime localTime1 = LocalTime.of(15, 23, 32);
        //between():静态方法，返回Duration对象，表示两个时间的间隔
        Duration duration = Duration.between(localTime1, localTime);
        System.out.println(duration);
        System.out.println(duration.getSeconds());
        System.out.println(duration.getNano());

        LocalDateTime localDateTime = LocalDateTime.of(2016, 6, 12, 15, 23, 32);
        LocalDateTime localDateTime1 = LocalDateTime.of(2017, 6, 12, 15, 23, 32);
        Duration duration1 = Duration.between(localDateTime1, localDateTime);
        System.out.println(duration1.toDays());
    }

    @Test
    public void test4(){
        //Period:用于计算两个“日期”间隔，以年、月、日衡量
        LocalDate localDate = LocalDate.now();
        LocalDate localDate1 = LocalDate.of(2028, 3, 18);

        Period period = Period.between(localDate, localDate1);
        System.out.println(period);
        System.out.println(period.getYears());
        System.out.println(period.getMonths());
        System.out.println(period.getDays());

        Period period1 = period.withYears(2);
        System.out.println(period1);

    }
}
```

##### 3、`Clock`：使用时区提供对当前即时、日期和时间的访问的时钟

主要用途是提供一个可测试的时间源，以便在单元测试中模拟时间。

```java
import java.time.Clock;
import java.time.Instant;

public class ClockTest {
    public static void main(String[] args) {
        // 使用指定时区的时钟
        Clock utcClock = Clock.systemUTC();
        System.out.println("UTC Clock: " + utcClock);

        // 获取当前时间戳
        Instant utcInstant = utcClock.instant();
        System.out.println("UTC Instant: " + utcInstant);
    }
}

```

##### 4、`TemporalAdjuster` : 时间校正器

有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。`TemporalAdjuster`允许你以一种声明式的方式对日期时间进行复杂的调整，例如获取下一个星期五、获取本月的最后一天等。

###### 主要用途

- **日期时间调整**：通过 `TemporalAdjuster` 接口，你可以对日期时间对象进行各种复杂的调整，而不需要编写大量的逻辑代码。
- **可重用性**：`TemporalAdjuster` 接口提供了一系列预定义的调整器，也可以自定义调整器，提高代码的可重用性。

###### 预定义的 `TemporalAdjuster`

Java 提供了一些预定义的 `TemporalAdjuster`，例如：

- `TemporalAdjusters.firstDayOfMonth()`：获取当前月的第一天。
- `TemporalAdjusters.lastDayOfMonth()`：获取当前月的最后一天。
- `TemporalAdjusters.next(DayOfWeek.FRIDAY)`：获取下一个星期五。
- `TemporalAdjusters.previous(DayOfWeek.MONDAY)`：获取上一个星期一。

```java
@Test
public void test1(){
    // TemporalAdjuster:时间校正器
    // 获取当前日期的下一个周日是哪天？
    TemporalAdjuster temporalAdjuster = TemporalAdjusters.next(DayOfWeek.SUNDAY);
    LocalDateTime localDateTime = LocalDateTime.now().with(temporalAdjuster);
    System.out.println(localDateTime);
    // 获取下一个工作日是哪天？
    LocalDate localDate = LocalDate.now().with(new TemporalAdjuster() {
        @Override
        public Temporal adjustInto(Temporal temporal) {
            LocalDate date = (LocalDate) temporal;
            if (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) {
                return date.plusDays(3);
            } else if (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) {
                return date.plusDays(2);
            } else {
                return date.plusDays(1);
            }
        }
    });
    System.out.println("下一个工作日是：" + localDate);
}
```

### 与传统日期处理的转换

| 类                                                       | To 遗留类                             | From 遗留类                 |
| -------------------------------------------------------- | ------------------------------------- | --------------------------- |
| java.time.Instant与java.util.Date                        | Date.from(instant)                    | date.toInstant()            |
| java.time.Instant与java.sql.Timestamp                    | Timestamp.from(instant)               | timestamp.toInstant()       |
| java.time.ZonedDateTime与java.util.GregorianCalendar     | GregorianCalendar.from(zonedDateTime) | cal.toZonedDateTime()       |
| java.time.LocalDate与java.sql.Time                       | Date.valueOf(localDate)               | date.toLocalDate()          |
| java.time.LocalTime与java.sql.Time                       | Date.valueOf(localDate)               | date.toLocalTime()          |
| java.time.LocalDateTime与java.sql.Timestamp              | Timestamp.valueOf(localDateTime)      | timestamp.toLocalDateTime() |
| java.time.ZoneId与java.util.TimeZone                     | Timezone.getTimeZone(id)              | timeZone.toZoneId()         |
| java.time.format.DateTimeFormatter与java.text.DateFormat | formatter.toFormat()                  | 无                          |

## Java比较器

基本数据类型的数据（除boolean类型外）需要比较大小的话，之间使用比较运算符即可，**但是引用数据类型是不能直接使用比较运算符来比较大小的**。那么，如何解决这个问题呢？

- **在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题**。
- **Java实现对象排序的方式有两种**
  - **自然排序**：`java.lang.Comparable`
  - **定制排序**：`java.util.Comparator`

### 自然排序：`java.lang.Comparable`

- `Comparable`**接口强行对实现它的每个类的对象进行整体排序，这种排序被称为**类的自然排序
- **实现**`Comparable`**的类必须实现**`compareTo(Object obj)`**方法**，两个对象通过`compareTo(Object obj)`**方法的**返回值来比较大小。如果当前对象`this`**大于**形参对象`obj`**，则**返回正整数；如果当前对象`this`**小于**形参对象`obj`**，则**返回负整数；如果当前对象`this`**等于**形参对象`obj`**，则**返回 0

```java
package java.lang;

public interface Comparable<T> {
    public int compareTo(T o);
}

```

- **实现**`Comparable`**接口的对象列表（和数组）可以通过**`Collections.sort`**或**`Arrays.sort`**进行自动排序，实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器**
- **对于类**`C`**的每一个**`e1`**和**`e2`**来说，当且仅当**`e1.compareTo(e2) == 0`**与**`e1.equals(e2)`**具有相同的**`boolean`**值时，类**`C`的自然排序才叫做与`equals`一致。**建议（不是必需的）最好使自然排序与 `equals` 一致**
- `Comparable`的典型实现`(默认都是从小到大排列的)`：
  - `String`：按照字符串中字符的`Unicode`值进行比较
  - `Character`：按照字符的`Unicode`值来进行比较
  - `数值类型对应的包装类`以及`BigInteger`、`BigDecimal`：按照对应的数值大小进行比较
  - `Boolean`**：**`true`**对应的包装类实例大于**`false`**对应的包装类实例**
  - `Date`、`Time`等：**后面的日期时间比前面的日期时间大**

代码示例：

**学生类**

```java
class CtStudent implements Comparable {
    private int id;
    private String name;
    private int score;
    private int age;

    public CtStudent(int id, String name, int score, int age) {
        this.id = id;
        this.name = name;
        this.score = score;
        this.age = age;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "CtStudent{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", score=" + score +
                ", age=" + age +
                '}';
    }

    /**
     * 按照id排序
     */
    @Override
    public int compareTo(Object o) {
        if (o instanceof CtStudent student) {
            return this.id - student.id;
        }
        throw new ClassCastException("请确保类型匹配且不为null！");
    }
}

```

**手动实现排序**

```java
public class ComparableTest {
    public static void main(String[] args) {
        CtStudent[] students = new CtStudent[5];
        students[0] = new CtStudent(3, "张三", 90, 23);
        students[1] = new CtStudent(1, "赵一", 100, 22);
        students[2] = new CtStudent(5, "王五", 75, 25);
        students[3] = new CtStudent(4, "李四", 85, 24);
        students[4] = new CtStudent(2, "刘二", 86, 20);

//        单独比较
        System.out.println(students[0].compareTo(students[1]));
        System.out.println(students[1].compareTo(students[2]));
        System.out.println(students[2].compareTo(students[2]));

        System.out.println("所有学生：");
        for (CtStudent student : students) {
            System.out.println(student);
        }

//        手动排序
        System.out.println("按照学号排序：");
        for (int i = students.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (students[j].compareTo(students[i]) > 0) {
                    CtStudent tmp = students[j];
                    students[j] = students[i];
                    students[i] = tmp;
                }
            }
        }
        for (CtStudent student : students) {
            System.out.println(student);
        }
    }
}
```

`Arrays.sort()`**实现排序（内部使用`compareTo`比较大小）**

```java
import java.util.Arrays;

public class ComparableTest {
    public static void main(String[] args) {
        CtStudent[] students = new CtStudent[5];
        students[0] = new CtStudent(3, "张三", 90, 23);
        students[1] = new CtStudent(1, "赵一", 100, 22);
        students[2] = new CtStudent(5, "王五", 75, 25);
        students[3] = new CtStudent(4, "李四", 85, 24);
        students[4] = new CtStudent(2, "刘二", 86, 20);

        System.out.println("所有学生：");
        for (CtStudent student : students) {
            System.out.println(student);
        }

        System.out.println("按照学号排序：");
        Arrays.sort(students);
        for (CtStudent student : students) {
            System.out.println(student);
        }
    }
}
```

### 定制排序：`java.util.Comparator`

**思考**

- **当元素的类型没有实现**`java.lang.Comparable`**接口而又不方便修改代码（例如：一些第三方的类，你只有**`.class`**文件，没有源文件）**
- 如果一个类，实现了`Comparable`接口，也指定了两个对象的比较大小的规则，**但是此时此刻我**不想按照它预定义的方法比较大小，但是我**又不能随意修改**，因为会影响其他地方的使用，怎么办？
- `JDK`在设计类库之初，也考虑到这种情况，所以又增加了一个`java.util.Comparator`**接口**，**强行对多个对象进行整体排序的比较**
  - **重写**`compare(Object o1,Object o2)`**方法**，比较`o1`和`o2`的大小：如果方法**返回正整数**，则表示`o1`**大于**`o2`；如果**返回**`0`，表示**相等**；返回**负整数**，表示`o1`**小于**`o2`
  - **可以将**`Comparator`**传递给**`sort`**方法（如 **`Collections.sort`** 或 **`Arrays.sort`**），从而允许在排序顺序上实现精确控制**

```java
package java.util;

public interface Comparator{
    int compare(Object o1,Object o2);
}
```

举例：

**学生类**

```java
class CpStudent {
    private int id;
    private String name;
    private int score;
    private int age;

    public CpStudent(int id, String name, int score, int age) {
        this.id = id;
        this.name = name;
        this.score = score;
        this.age = age;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "CtStudent{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", score=" + score +
                ", age=" + age +
                '}';
    }
}
```

**实现比较器定制排序**

```java
import java.util.Comparator;

class CpComparatorByScoreAndId implements Comparator<CpStudent> {
    /**
     * 先按照score排序，再按照id排序
     */
    @Override
    public int compare(CpStudent o1, CpStudent o2) {
            int res = o1.getScore() - o2.getScore();
            return res != 0 ? res : o1.getId() - o2.getId();
    }
}

```

`Arrays.sort()`**实现排序（指定**`comparator`**比较大小）**

```java
public class ComparatorTest {
    public static void main(String[] args) {
        CpStudent[] students = new CpStudent[5];
        students[0] = new CpStudent(3, "张三", 90, 23);
        students[1] = new CpStudent(1, "赵一", 100, 22);
        students[2] = new CpStudent(5, "王五", 75, 25);
        students[3] = new CpStudent(4, "李四", 85, 24);
        students[4] = new CpStudent(2, "刘二", 86, 20);

        System.out.println("所有学生：");
        for (CpStudent student : students) {
            System.out.println(student);
        }

        // Arrays.sort()
        System.out.println("按照成绩和学号排序：");
        CpComparatorByScoreAndId cpComparatorByScoreAndId = new CpComparatorByScoreAndId();
        Arrays.sort(students, cpComparatorByScoreAndId);
        for (CpStudent student : students) {
            System.out.println(student);
        }
    }
}
```

## 系统相关类

### `java.lang.System`类

- `System`**类代表系统，系统级的很多属性和控制方法都放置在该类的内部**，位于`java.lang`包
- **该类的构造器是**`private`**的**，**无法创建该类的对象，其内部的成员变量和成员方法都是**`static`**的，所以也可以很方便的进行调用**
- `System`**类内部包含**`in`**、**`out`**和**`err`**三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)**
- 成员方法
  - `native long currentTimeMillis()`： **返回当前的计算机时间**，时间的表达格式为**当前计算机时间和**`GMT`**时间(格林威治时间)**`1970年1月1号0时0分0秒`**所差的毫秒数**
  - `void exit(int status)`：**退出程序**，`status`值**为**`0`**代表正常退出,**`非 0`**代表异常退出**
  - `void gc()`：**请求系统进行垃圾回收**，至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况
  - `static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`： **从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束**。常用于数组的插入和删除
  - `String getProperty(String key)`：**获得系统中属性名为key的属性对应的值**
  - **系统中常见的属性名以及属性的作用如下表所示**

![](https://cdn.nlark.com/yuque/0/2024/png/2447732/1732199338051-f7f4da50-412b-40d4-ab30-a8eb8a3fb766.png)

代码举例：

```java
import org.junit.Test;

public class SystemTest {

    @Test
    public void test1() {
        long time = System.currentTimeMillis();
        System.out.println("当前时间举例距离1970年1月1日凌晨：" + time + "ms");
        System.exit(0);
        // 不会执行
        System.out.println("over");
    }

    @Test
    public void  test2() {
        String javaVersion = System.getProperty("java.version");
        System.out.println(javaVersion);

        String javaHome = System.getProperty("java.home");
        System.out.println(javaHome);

        String osName = System.getProperty("os.name");
        System.out.println(osName);

        String osVersion = System.getProperty("os.version");
        System.out.println(osVersion);

        String userHome = System.getProperty("user.home");
        System.out.println(userHome);

        String userName = System.getProperty("user.name");
        System.out.println(userName);

        String userDir = System.getProperty("user.dir");
        System.out.println(userDir);
    }

    @Test
    public void test3() throws InterruptedException {
        for (int i = 0; i < 10; i++) {
            // 每次循环会指向新的对象 上次的对象没有变量引用成为垃圾对象
            GcDemoClass gcDemoClass = new GcDemoClass(i);
        }
        // 加上sleep让main晚点结束 看到垃圾回收后调用对象的finalize()的输出
        System.gc();
        Thread.sleep(5000);
    }
}

class GcDemoClass {
    private int value;

    public GcDemoClass(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "GcDemoClass{" +
                "value=" + value +
                '}';
    }

    /**
     * 重写finalize方法 看看gc的效果
     */
    @Override
    protected void finalize() throws Throwable {
        System.out.println(this + "GcDemoClass Obj finalize...");
    }
}
```

`System.arraycopy()`**方法测试**

```java
import org.junit.Test;
import java.util.Arrays;

public class SystemArrayCopyMethodTest {
    @Test
    public void test1() {
        int[] arr = {1, 2, 3, 4, 5};
        int[] arr2 = new int[10];
        System.arraycopy(arr, 0, arr2, 3, arr.length);
//        [1, 2, 3, 4, 5]
        System.out.println(Arrays.toString(arr));
//        [0, 0, 0, 1, 2, 3, 4, 5, 0, 0]
        System.out.println(Arrays.toString(arr2));
    }

    @Test
    public void test2() {
        int[] arr = {1, 2, 3, 4, 5};
        System.arraycopy(arr, 0, arr, 1, arr.length - 1);
//        [1, 1, 2, 3, 4]
        System.out.println(Arrays.toString(arr));
    }

    @Test
    public void test3() {
        int[] arr = {1, 2, 3, 4, 5};
        System.arraycopy(arr, 1, arr, 0, arr.length - 1);
//        [2, 3, 4, 5, 5]
        System.out.println(Arrays.toString(arr));
    }
}
```

### `java.lang.Runtime`类

**每个 Java 应用程序都有一个 Runtime 类实例**，使应用程序能够与其运行的环境相连接。

- `public static Runtime getRuntime()`： **返回与当前 Java 应用程序相关的运行时对象**，应用程序**不能创建自己的**`Runtime`**类实例**
- `public long totalMemory()`：**返回Java虚拟机中初始化时的内存总量**，此方法返回的值可能随时间的推移而变化，这取决于主机环境，默认为物理电脑内存的`1/64`
- `public long maxMemory()`：**返回Java虚拟机中最大程度能使用的内存总量**，默认为物理电脑内存的`1/4`
- `public long freeMemory()`：**返回Java虚拟机中的空闲内存量**，调用`gc`方法可能导致`freeMemory`返回值的增加

```java
public class RuntimeTest {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        long initMemory = runtime.totalMemory();
        long maxMemory = runtime.maxMemory();
        String str = "";
        for (int i = 0; i < 10000; i++) {
            str += i;
        }
        long freeMemory = runtime.freeMemory();
        // 物理内存1/64
        System.out.println("初始化时总内存：" + initMemory / 1024 / 1024 * 64 + "Mb");
        // 物理内存1/4
        System.out.println("最大能用总内存：" + maxMemory / 1024 / 1024 * 4 + "Mb");
        System.out.println("空闲内存：" + freeMemory / 1024 / 1024 + "Mb");
        System.out.println("已用内存：" + (initMemory - freeMemory) / 1024 / 1024 + "Mb");
    }
}
```

## 数学相关类

### `java.lang.Math`

`java.lang.Math`类包含用于**执行基本数学运算的方法**，如：初等指数、对数、平方根和三角函数。**类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单**。

- `public static double abs(double a)` ： **double 值的绝对值**。
- `public static double ceil(double a)`：**大于等于参数的最小的整数（向上取整）**

```java
double d1 = Math.ceil(3.3);  // d1的值为 4.0
double d2 = Math.ceil(-3.3); // d2的值为 -3.0
double d3 = Math.ceil(5.1);  // d3的值为 6.0
```

- `public static double floor(double a)` ：**小于等于参数最大的整数（向下取整）**

```java
double d1 = Math.floor(3.3);  // d1的值为3.0
double d2 = Math.floor(-3.3); // d2的值为-4.0
double d3 = Math.floor(5.1);  // d3的值为 5.0
```

- `public static long round(double a)`：**最接近参数的 long(相当于四舍五入方法)**

```java
long d1 = Math.round(5.5);  // d1的值为6
long d2 = Math.round(5.4);  // d2的值为5
long d3 = Math.round(-3.3); // d3的值为-3
long d4 = Math.round(-3.8); // d4的值为-4
```

- `public static double pow(double a,double b)`：`a`的`b`幂次方法
- `public static double sqrt(double a)`：`a`的平方根
- `public static double random()`：`[0,1)`**的随机值**
- `public static final double PI`：**圆周率**
- `public static double max(double x, double y)`：`x,y`**中的最大值**
- `public static double min(double x, double y)`：`x,y`**中的最小值**
- 其它：`acos,asin,atan,cos,sin,tan`**三角函数**

### `java.math`包

##### `BigInteger`

`Integer`类为`int`的包装类，存储的最大整型为`2^31-1`，`Long`类也是有限的，最大为`2^63-1`，**如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了**。

- `java.math`**包的**`BigInteger`**可以表示不可变的任意精度的整数**，`BigInteger`提供所有Java的基本整数操作符的对应方法，并提供`java.lang.Math`**的所有相关方法**。`BigInteger` 还提供以下运算：**模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作**。
- 构造器
  - `BigInteger(String val)`：**根据字符串构建**`BigInteger`**对象**
- 方法
  - `public BigInteger abs()`：此`BigInteger`的**绝对值**的`BigInteger`
  - `BigInteger add(BigInteger val)`：返回其值为`(this + val)`的`BigInteger`
  - `BigInteger subtract(BigInteger val)`：返回其值为`(this - val)`的`BigInteger`
  - `BigInteger multiply(BigInteger val)`：返回其值为`(this * val)`的`BigInteger`
  - `BigInteger divide(BigInteger val)`：返回其值为`(this / val)`的`BigInteger`，**整数相除只保留整数部分**
  - `BigInteger remainder(BigInteger val)`：返回其值为`(this % val)`的 `BigInteger`
  - `BigInteger[] divideAndRemainder(BigInteger val)`：返回包含`(this / val)`后跟 `(this % val)`的**两个**`BigInteger`**的数组**
  - `BigInteger pow(int exponent)`：返回其值为`(this^exponent)`的`BigInteger`

```java
import java.math.BigInteger;

public class BigIntegerTest {
    public static void main(String[] args) {
        BigInteger bigInteger1 = new BigInteger("12345678912345678912345678");
        BigInteger bigInteger2 = new BigInteger("78923456789123456789123456789");

        // 无法直接使用 + 号运算
        // System.out.println(bigInteger1 + bigInteger2);

        System.out.println("加：" + bigInteger1.add(bigInteger2));
        System.out.println("减：" + bigInteger1.subtract(bigInteger2));
        System.out.println("乘：" + bigInteger1.multiply(bigInteger2));
        System.out.println("除：" + bigInteger2.divide(bigInteger1));
        System.out.println("取余：" + bigInteger2.remainder(bigInteger1));
    }
}
```

##### `BigDecimal`

- 一般的`Float`类和`Double`类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到`java.math.BigDecimal`**类**
- `BigDecimal`类**支持不可变的、任意精度的有符号十进制定点数**
- 构造器
  - `public BigDecimal(double val)`
  - `public BigDecimal(String val)` **推荐**
- 常用方法
  - `public BigDecimal add(BigDecimal augend)`
  - `public BigDecimal subtract(BigDecimal subtrahend)`
  - `public BigDecimal multiply(BigDecimal multiplicand)`
  - `public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)`：`divisor`**除数**，`scale`**保留几位小数**，`roundingMode`**舍入模式**（`ROUNDUP` ：向上加1、`ROUNDDOWN` ：直接舍去、`ROUNDHALFUP` ：四舍五入）

代码案例：

```java
import java.math.BigDecimal;

public class BigDecimalTest {
    public static void main(String[] args) {
        BigDecimal bigDecimal1 = new BigDecimal("12435.351");
        BigDecimal bigDecimal2 = new BigDecimal("11");

//        1130.486
        System.out.println(bigDecimal1.divide(bigDecimal2, BigDecimal.ROUND_HALF_UP));
//        1130.486454545454545
        System.out.println(bigDecimal1.divide(bigDecimal2, 15, BigDecimal.ROUND_HALF_UP));
    }
}
```

### `java.util.Random`

**用于产生随机数**

- `boolean nextBoolean()`：取自随机数生成器序列的**均匀分布的 **`boolean`** 值**
- `void nextBytes(byte[] bytes)`：**生成随机字节并将其置于用户提供的 **`byte`** 数组中**
- `double nextDouble()`：取自随机数生成器序列、**在**`0.0`**和**`1.0`**之间均匀分布的 **`double`** 值**
- `float nextFloat()`：取自随机数生成器序列、**在**`0.0`**和**`1.0`**之间均匀分布的 float 值**
- `double nextGaussian()`：取自随机数生成器序列、**呈高斯（“正态”）分布的**`double`**值，其平均值是**`0.0`**，标准差是**`1.0`
- `int nextInt()`：随机数生成器的序列中**均匀分布的**`int`**值**
- `int nextInt(int n)`：取自随机数生成器序列、**在**`0`**（包括）和指定值（不包括）之间均匀分布的**`int`**值**
- `long nextLong()`：取自随机数生成器序列的**均匀分布的 **`long`** 值**

```java
import java.util.Random;

public class RandomTest {
    public static void main(String[] args) {
        Random random = new Random();

        System.out.println("随机整数：" + random.nextInt());
        System.out.println("随机小数：" + random.nextDouble());
        System.out.println("随机布尔值：" + random.nextBoolean());
    }
}
```
