---
title: 11 Spring MVC的核心类和注解
createTime: 2025/12/28 15:13:02
permalink: /framework/heima_ssm_book/bfgyudwl/
---
学习目标

+ 了解Spring MVC核心类的作用
+ 掌握@Controller注解的使用
+ 掌握@RequestMapping注解的使用
+ 掌握请求的映射方式  

自JDK5推出以来，注解已成为Java知识体系不可缺少的一部分。Spring MVC在Spring 2.5之后也新增了基于注解的Controller形式。基于注解的Controller简化了XML文件配置，极大地提高了开发效率。

## 11.1 DispatcherServlet

`DispatcherServlet`是Spring MVC的**核心类**，其全限定名是`org.springframework.web.servlet.DispatcherServlet`。

**DispatcherServlet是Spring MVC的流程控制中心，也称为Spring MVC的前端控制器，它可以拦截客户端的请求**。拦截客户端请求之后，DispatcherServlet会**根据具体规则将请求交给其他组件处理**。所有请求都要经过DispatcherServlet进行**转发**处理，这样就降低了Spring MVC组件之间的耦合性。

**DispatcherServlet本质上是一个Servlet**，可以在web.xml文件中完成DispatcherServlet的配置和映射。下面新建一个项目，在项目的web.xml文件中演示DispatcherServlet的配置和映射。

参考第10章Spring MVC入门程序，在IDEA中创建一个名称为ch11的Maven Web项目。

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>heima_ssm_book</artifactId>
        <groupId>io.weew12.github</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>ch11</artifactId>
    <packaging>war</packaging>

    <name>ch11</name>
    <url>http://maven.apache.org</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <spring.version>5.3.31</spring.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>javax.servlet.jsp-api</artifactId>
            <version>2.3.1</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.opoo.maven</groupId>
                <artifactId>tomcat9-maven-plugin</artifactId>
                <version>3.0.0</version>
                <configuration>
                    <port>8080</port>
                    <path>/ch11</path>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

```

maven 项目 tomcat 插件配置：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766826113225-cdf0d0cd-fabf-45a2-91a6-53c823b0528b.png)

项目创建完成之后，在项目web.xml文件中配置DispatcherServlet：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!-- 配置 Spring MVC 的前端控制器 -->
    <servlet>
        <servlet-name>DispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- 配置初始化参数，用于读取 Spring MVC 的配置文件 -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring-mvc.xml</param-value>
        </init-param>
        <!-- 应用加载时创建 -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>DispatcherServlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

在文件中，`<init-param>`元素用于指定DispatcherServlet初始化参数，参数名为`contextConfigLocation`，参数值为指定路径下的文件`spring-mvc.xml`。DispatcherServlet初始化时会读取`spring-mvc.xml`文件中的配置信息完成初始化。

**如果web.xml没有通过**`<init-param>`**元素指定DispatcherServlet初始化时要加载的文件，则应用程序会去WEB-INF文件夹下寻找并加载默认配置文件。默认配置文件的名称规则如下：**

```plain
[servlet-name]-servlet.xml
```

在上述名称规则中，`[servlet-name]`是指web.xml文件中`<servlet-name>`元素的值；`servlet.xml`是配置文件名的固定后缀。因此，如果文件中没有指定要加载的配置文件，应用程序会在WEB-INF文件夹下寻找并加载名称为`DispatcherServlet-servlet.xml`的配置文件。

在文件中，`<load-on-startup>`元素用于指定DispatcherServlet是否在启动时加载。

如果`<load-on-startup>`元素的值为**正整数或者0**，表示在项目启动时就加载并初始化这个Servlet，**值越小，Servlet的优先级越高，就越先被加载**；如果`<load-on-startup>`元素的**值为负数或者没有设置，则Servlet会在被请求时加载并初始化。**

## 11.2 `@Controller`注解

在Spring MVC的执行流程中，DispatcherServlet把用户请求转发给处理器类中的`Handler`（处理器），`Handler`对用户的请求进行处理。在Spring MVC框架中，传统的处理器类需要直接或间接地实现`Controller`接口，这种方式需要在Spring MVC配置文件中定义请求和Controller的映射关系。当后台需要处理的请求较多时，使用传统的处理器类会比较繁琐且灵活性低。为此，Spring MVC框架提供了`@Controller`注解。使用`@Controller`注解时，只需要将`@Controller`注解标注在普通Java类上，然后通过Spring的扫描机制找到标注了该注解的Java类，该Java类就成为了Spring MVC的处理器类。

基于`@Controller`注解的处理器类示例代码如下：

```java
import org.springframework.stereotype.Controller;

@Controller
public class FirstController {
    // 标注@Controller注解
}
```

**为了保证Spring MVC能够找到处理器类，需要在Spring MVC的配置文件中添加相应的扫描配置信息。**

首先在配置文件的声明中引入spring-context声明，用于支持配置文件中所使用的`<context:component-scan>`元素；然后使用`<context:component-scan>`元素指定被Spring扫描的类包。Spring MVC配置文件的类包扫描配置信息如文件所示：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd">
    <!-- 配置 Spring MVC 要扫描的包 -->
    <context:component-scan base-package="io.weew12.github.controller"/>
</beans>
```

`<context:component-scan>`元素的`base-package`属性指定了需要扫描的类包为`io.weew12.github.controller`。文件被加载时，Spring会自动扫描`io.weew12.github.controller`类包及其子包下的Java类。如果被扫描的Java类中带有`@Controller`、`@Service`等注解，则把这些类注册为Bean并存放在Spring中。

与传统的处理器类实现方式相比，使用`@Controller`注解的方式更加简单灵活。因此，在实际开发中通常使用`@Controller`注解来定义处理器类。

## 11.3 `@RequestMapping`注解

使用`@Controller`注解**可以将普通的类声明成Spring MVC的处理器类**，但是只使用`@Controller`注解的话，Spring MVC框架并不能确定当前Web请求由哪个`Handler`进行处理。为此，Spring MVC框架还提供了`@RequestMapping`注解。`@RequestMapping`注解**可以为Handler提供必要的映射信息，将请求的URL映射到具体的处理方法**。

### 11.3.1 @RequestMapping注解的使用

`@RequestMapping`注解用于**建立请求URL和Handler之间的映射关系**，该注解**可以标注在方法上和类上**。

#### 标注在方法上

当`@RequestMapping`注解标注在方法上时，该方法就成了一个可以处理客户端请求的`Handler`（处理器），它会在Spring MVC接收到对应的URL请求时被执行。Handler在浏览器中对应的**访问地址**由：**项目访问路径+处理方法的映射路径共同组成**。

下面通过一个案例演示`@RequestMapping`注解标注在方法上的使用。

在ch11项目的src/main/java目录下创建类包controller，并在类包下创建FirstController类。FirstController类中创建sayHello()方法，用于处理客户端请求：

```java
package io.weew12.github.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class FirstController {
    /**
     * 注解加载方法上
     */
    @RequestMapping(value = "/firstController")
    public void sayHello() {
        System.out.println("hello Spring MVC");
    }
}

```

spring-mvc.xml 配置：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:mvc="http://www.springframework.org/schema/mvc"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans     
  http://www.springframework.org/schema/beans/spring-beans.xsd
  http://www.springframework.org/schema/context 
  http://www.springframework.org/schema/context/spring-context.xsd
  http://www.springframework.org/schema/mvc
  http://www.springframework.org/schema/mvc/spring-mvc.xsd">
  <context:component-scan base-package="io.weew12.github.controller"/>
  <mvc:annotation-driven/>
</beans>
```

`@RequestMapping`注解的`value`属性指定了`sayHello()`方法的映射路径为`/firstController`。项目ch11启动后，在浏览器中访问地址[http://localhost:8080/ch11/firstController](http://localhost:8080/ch11/firstController)时，会执行文件中的`sayHello()`方法。启动项目，在浏览器中访问[http://localhost:8080/ch11/firstController](http://localhost:8080/ch11/firstController)，控制台输出信息如图所示。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766902549366-4dd5cadb-0714-4b56-b40c-6e656a98a20a.png)

从图所示的控制台输出信息可以看出，`sayHello()`方法被成功执行，说明`@RequestMapping`注解标注在方法上时，成功建立了请求URL和处理请求方法之间的关系。

#### 标注在类上

当`@RequestMapping`注解标注在类上时，`@RequestMapping`的`value`属性值**相当于本处理器类的命名空间**，即**访问该处理器类下的任意处理器都需要带上这个命名空间**。当`@RequestMapping`标注在类上时，其`value`属性值作为请求URL的**第一级访问目录**。当处理器类和处理器都使用`@RequestMapping`注解指定了对应的映射路径时，处理器在浏览器中的访问地址由**项目访问路径+处理器类的映射路径+处理器的映射路径共同组成**。

下面通过一个案例演示`@RequestMapping`注解标注在类上的使用。修改文件，在`FirstController`类上标注`@RequestMapping`注解：

```java
package io.weew12.github.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping(value = "/springMVC")
public class FirstController {
    /**
     * 注解加载方法上
     */
    @RequestMapping(value = "/firstController")
    public void sayHello() {
        System.out.println("hello Spring MVC");
    }
}

```

在文件中，`@RequestMapping`注解指定了`FirstController`类的映射路径"`/springMVC`"；`@RequestMapping`注解指定了`sayHello()`方法的映射路径为"`/firstController`"。项目ch11启动后，在浏览器中访问地址[http://localhost:8080/ch11/springMVC/firstController](http://localhost:8080/ch11/springMVC/firstController)时，`sayHello()`方法会被执行。启动项目，在浏览器中访问[http://localhost:8080/ch11/springMVC/firstController](http://localhost:8080/ch11/springMVC/firstController)，控制台输出信息如图所示。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766903305910-46d5ddd2-7605-4f2d-85e5-726555b3a275.png)

从图所示的控制台输出信息可以看出，`sayHello()`方法被成功执行，说明`@RequestMapping`注解标注在类上时，成功建立了请求URL和处理请求类之间的关系。

### 11.3.2 @RequestMapping注解的属性

在11.3.1节中，使用`@RequestMapping`注解的`value`属性映射请求的URL访问路径。除了`value`属性外，`@RequestMapping`注解还有其他6个属性。`@RequestMapping`注解的属性如表11-1所示。

**表11-1**`**@RequestMapping**`**注解的属性**

| 属性名 | 类型 | 描述 |
| --- | --- | --- |
| `name` | `String` | 可选属性，用于为映射地址**指定别名** |
| `value` | `String[]` | 可选属性，同时也是默认属性，用于**指定请求的URL** |
| `method` | `RequestMethod[]` | 可选属性，用于**指定该方法可以处理哪种类型的请求方式**，其请求方式包括`GET`、`POST`、`HEAD`、`OPTIONS`、`PUT`、`PATCH`、`DELETE`和`TRACE` |
| `params` | `String[]` | 可选属性，用于**指定客户端请求中参数的值必须包含哪些参数的值时，才可以通过其标注的方法处理** |
| `headers` | `String[]` | 可选属性，用于**指定客户端请求中必须包含哪些header的值时，才可以通过其标注的方法处理** |
| `consumes` | `String[]` | 可选属性，用于**指定处理请求的提交内容类型**（`Content-type`），如`application/json`、`text/html`等 |
| `produces` | `String[]` | 可选属性，用于**指定返回的内容类型**，仅当`request`请求头中的（`Accept`）类型中包含该指定类型时才返回 |

表11-1列举了`@RequestMapping`注解的属性，所有属性都是可选属性。除name属性外，其他属性都可以同时指定多个参数。下面结合示例学习`@RequestMapping`注解的常用属性。

#### value属性

value属性是`@RequestMapping`注解的默认属性。当value属性是`@RequestMapping`注解显式使用的唯一属性时，可以省略value的属性名。例如，下面两种映射路径标注的含义相同：

```java
@RequestMapping(value="/firstController")
@RequestMapping("/firstController")
```

使用value属性时，可以指定映射单个的请求URL，也可以将多个请求映射到一个方法上。在value属性中添加一个带有请求路径的列表，就可以将这个请求列表中的路径都映射到对应的方法上：

**文件11-5 AuthController.java**

```java
package io.weew12.github.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class AuthController {
    /**
     * 设定当前方法的访问映射地址列表
     */
    @RequestMapping(value = {"/addUser", "/deleteUser"})
    public void checkAuth() {
        System.out.println("增删操作校验");
    }
}

```

在文件中，将两个请求路径存放在英文大括号内，路径之间使用英文逗号进行分隔。此时，`checkAuth()`方法会处理映射请求路径"`/addUser`"和"`/deleteUser`"。

启动项目，在浏览器中访问地址[http://localhost:8080/ch11/addUser](http://localhost:8080/ch11/addUser)，控制台输出信息如图所示。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766903813630-09306971-63c2-48c0-8cf0-bf03b49e53f8.png)

在浏览器中访问地址[http://localhost:8080/chapter11/deleteUser](http://localhost:8080/chapter11/deleteUser)，控制台输出信息如图所示。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766903829052-0eff6820-e83d-4aeb-a0ad-0d97d36b6a7f.png)

从图输出的内容分析可知，访问不同的两个路径，但都成功执行了`checkAuth()`方法，由此说明实现了多个请求映射到一个方法上。

#### method属性

method属性可以**对处理器映射的URL请求方式进行限定**。**当请求的URL和处理器映射成功，但请求方式和method属性指定的属性值不匹配时，处理器并不能正常处理请求**。下面通过一个案例演示method属性限定HTTP请求的方式：

**文件11-6 MethodController.java**

```java
package io.weew12.github.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
@RequestMapping("/method")
public class MethodController {
    /**
     * 处理请求方式为GET的请求
     */
    @RequestMapping(method = RequestMethod.GET)
    public void get() {
        System.out.println("RequestMethod.GET");
    }

    /**
     * 处理请求方式为DELETE的请求
     */
    @RequestMapping(method = RequestMethod.DELETE)
    public void delete() {
        System.out.println("RequestMethod.DELETE");
    }

    /**
     * 处理请求方式为POST的请求
     */
    @RequestMapping(method = RequestMethod.POST)
    public void post() {
        System.out.println("RequestMethod.POST");
    }

    /**
     * 处理请求方式为PUT的请求
     */
    @RequestMapping(method = RequestMethod.PUT)
    public void put() {
        System.out.println("RequestMethod.PUT");
    }
}

```

启动项目后，在客户端依次以GET方式、DELETE方式、POST方式和PUT方式请求访问[http://localhost:8080/chapter11/method](http://localhost:8080/chapter11/method)时，程序会分别执行文件11-6中的get()方法、delete()方法、post()方法和put()方法。控制台输出信息如图11-5所示。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904175924-f13eafda-d762-4ae9-9f54-d9ce888092f5.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904187742-4e1ea27a-8fee-46cf-acd6-6e08b6ca84f0.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904208681-9e3f8240-1d67-48c6-a2da-3a4d52f550f3.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904203909-5813c3c9-0839-448d-ace2-e9481ec5de9c.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904225598-59417620-b8c7-431e-b2be-df19d70910c7.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904220468-edcc6dd9-9007-4dce-9fbc-09395e74405a.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904235041-808c63cd-1bf7-4fd1-a2a1-ee54327c8112.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904241849-e2af3674-84e5-48ae-9390-ff1b26e46380.png)

如果需要同时支持多个请求方式，则需要将请求方式列表存放在英文大括号中，以数组的形式给method属性赋值，并且多个请求方式之间用英文逗号分隔：

```java
@RequestMapping(
    value = "/test",
    method = {RequestMethod.GET, RequestMethod.POST}
)
public void getAndPost() {
    System.out.println("RequestMethod.GET + RequestMethod.POST");
}
```

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904393825-44a64409-5fd6-4123-af39-0e06e68b7473.png)

如果没有指定method属性的值，`@RequestMapping`注解会根据客户端的请求方式自动适应。

#### params属性

**params属性中定义的值可以将请求映射的定位范围缩小**。当客户端进行请求时，**如果请求参数的值等于params属性定义的值，则可以正常执行所映射到的方法，否则映射到的方法不执行**。params属性值的定义方式：

```java
package io.weew12.github.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class ParamsController {

    @RequestMapping(value = "/params", params = "id=1")
    public void findById(String id) {
        System.out.println("id=" + id);
    }
}

```

在文件中，`@RequestMapping`注解的params属性指定了findById()方法参数id的值为1。项目启动后，在浏览器中输入[http://localhost:8080/ch11/params?id=1](http://localhost:8080/ch11/params?id=1)，控制台输出信息如图所示。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904615437-dab2cd71-ff0b-4991-bb4d-9d8730d9b20c.png)

从图所示的控制台输出信息可以看出，findById()方法正常执行了，说明浏览器客户端请求参数中携带的名称为id且值为1的参数，符合`@RequestMapping`注解params属性的设定。**如客户端请求访问findById()方法未携带名称为id的参数，或所携带参数id的值不等于1，则findById()方法将不执行。**

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904560493-915e254e-c1b8-4acc-a562-714142fd559d.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904574959-a2015442-d6e4-4cad-9f3f-b5a19b5237c9.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904653077-5fc42828-1061-4ff9-89ff-9ff77c681cea.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1766904646849-7a85e0cd-25ce-47c2-9f59-4d59c7d4614c.png)

### 11.3.3 请求映射方式

基于注解风格的Spring MVC通过`@RequestMapping`注解指定请求映射的URL路径。URL路径映射常用的方式有基于请求方式的URL路径映射、基于Ant风格的URL路径映射和基于REST风格的URL路径映射3种。

#### 基于请求方式的URL路径映射

11.3.2节中已经学习了可以使用`@RequestMapping`注解的`method`属性来限定当前方法匹配哪种类型的请求方式。除了可以使用`@RequestMapping`注解来限定客户端的请求方式外，从Spring 4.3版本开始，还可以使用组合注解完成客户端请求方式的限定。组合注解简化了常用的HTTP请求方式的映射，并且更好地表达了被注解方法的语义。Spring MVC组合注解如下所示：

+ `@GetMapping`：匹配`GET`方式的请求。
+ `@PostMapping`：匹配`POST`方式的请求。
+ `@PutMapping`：匹配`PUT`方式的请求。
+ `@DeleteMapping`：匹配`DELETE`方式的请求。
+ `@PatchMapping`：匹配`PATCH`方式的请求。

下面以`@GetMapping`为例讲解组合注解的用法，`@GetMapping`是`@RequestMapping(method = RequestMethod.GET)`的缩写，使用组合注解替代`@RequestMapping`注解可以省略method属性，从而简化代码：

```java
@GetMapping(value="/firstController")
public void sayHello() {
    // 方法体
}
```

在上述示例代码中，使用了`@GetMapping`注解处理GET请求，效果与使用`@RequestMapping`的method属性处理GET请求方式相同。

#### 基于Ant风格的URL路径映射

Spring MVC支持Ant风格的URL路径映射，所谓**Ant风格其实就是一种通配符风格**，可以**在处理器映射路径中使用通配符对访问的URL路径进行关联**。Ant风格的通配符有以下3种：

+ `?`：匹配**任何单字符**。
+ `*`：匹配`0`或者任意数量的**字符**。
+ `**`：匹配`0`或者多级**目录**。

基于Ant风格的URL路径映射中，Ant风格通配符的路径匹配如表11-2所示。

**表11-2 Ant风格通配符的路径匹配**

| 通配符 | URL路径示例 | 匹配说明 |
| --- | --- | --- |
| `?` | `/ant1?` | 匹配项目根路径下`/ant1[anyone]`路径，其中`[anyone]`可以是任意单字符，即`/ant1`后有且只有1个字符，例如：`/ant12`、`/ant1a`可以被`/ant1?`匹配 |
| `*` | `/ant2/*.do` | 匹配项目根路径下`/ant2/[any].do`路径，其中`[any]`可以是任意数量的字符，例如：`/ant2/findAll.do`、`/ant2/.do`可以被`/ant2/*.do`匹配 |
| `*` | `/*/ant3` | 匹配项目根路径下`/[onemore]/ant3`路径，其中`[onemore]`可以是数量多于0个的任意字符，例如：`/a/ant3`、`/findAl/ant3`可以被`/*/ant3`匹配，但是字符数量不能为0，并且目录层数必须一致，例如：`//ant3`、`/findAl/a/ant3`不能被`/*/ant3`匹配 |
| `**` | `/**/ant4` | 匹配项目根路径下`/[anypath]/ant4`路径，其中`[anypath]`可以是0或者多层的目录，例如：`/ant4`、`/a/ant4`、`/a/b/ant4`可以被`/**/ant4`匹配 |
| `**` | `/ant5/**` | 匹配项目根路径下`/ant5/[anypath]`路径，其中`[anypath]`可以是0或者多层的目录，例如：`/ant5`、`/ant5/a`、`/ant5/a/b`可以被`/ant5/**`匹配 |

当映射路径中同时使用多个通配符时，可能会发生通配符冲突的情况。**当多个通配符冲突时，路径会遵守最长匹配原则（has more characters）去匹配通配符，如果一个请求路径同时满足两个或多个Ant风格的映射路径匹配规则，那么请求路径最终会匹配满足规则字符最多的路径**。例如，`/ant/a/path`同时满足`/**/path`和`/ant/*/path`匹配规则，但`/ant/a/path`最终会匹配`/ant/*/path`路径。

#### 基于RESTful风格的URL路径映射

除了支持Ant风格的URL路径映射外，Spring MVC还支持RESTful风格的URL路径映射。

REST（Representational State Transfer）是一种网络资源的访问风格，规范了网络资源的访问方式。REST所访问的网络资源可以是一段文本、一张图片、一首歌曲、一种服务，总之是一个具体的存在。每个网络资源都有一个URI（Uniform Resource Identifier，统一资源标识符）指向它，要获取这个资源，访问它的URI就可以，因此URI即为每一个资源的独一无二的标识符。

**RESTful按照REST风格访问网络资源，简单来说，RESTful就是把请求参数变成请求路径的一种风格**。

例如，传统风格访问的URL格式如下：

```plain
http://.../findUserById?id=1
```

而采用RESTful风格后，其访问的URL格式如下：

```plain
http://.../user/id/1
```

从上述两个请求中可以看出，RESTful风格中的URL将请求参数id=1变成了请求路径的一部分，并且将传统风格URL中的findUserById变成了user。需要注意的是，**RESTful风格中的URL不使用动词形式的路径**，例如，findUserById表示查询用户，是一个动词，而user表示用户，为名词。

RESTful风格在HTTP请求中通过`GET`、`POST`、`PUT`和`DELETE`这4个动词对应4种基本请求操作，具体如下所示：

+ `GET`：用于**获取**资源。
+ `POST`：用于**新建**资源。
+ `PUT`：用于**更新**资源。
+ `DELETE`：用于**删除**资源。

RESTful风格4种请求的约定方式如表11-3所示。

**表11-3 RESTful风格4种请求的约定方式**

| URL路径 | 请求方式 | 说明 |
| --- | --- | --- |
| [http://localhost:8080/ch11/user/1](http://localhost:8080/ch11/user/1) | HTTP `GET` | 获得参数1进行查询user操作 |
| [http://localhost:8080/ch11/user/1](http://localhost:8080/ch11/user/1) | HTTP `DELETE` | 获得参数1进行删除user操作 |
| [http://localhost:8080/ch11/user/1](http://localhost:8080/ch11/user/1) | HTTP `PUT` | 获得参数1进行更新user操作 |
| [http://localhost:8080/ch11/user](http://localhost:8080/ch11/user) | HTTP `POST` | 新增user操作 |

表11-3列出RESTful风格4种请求的约定方式，**约定不是规范，约定是可以打破的，所以称为RESTful风格，而不是RESTful规范**。使用RESTful风格的优势在于路径的书写比较简便，并且通过地址无法得知做的是何种操作，可以隐藏资源的访问行为。如何获取表11-3中URL路径的参数，将会在第12章进行详细讲解，本章只对映射方式进行讲解。

## 11.4 本章小结

本章主要对Spring MVC的核心类及相关注解的使用进行了讲解。首先介绍了`DispatcherServlet`核心类的作用和配置；然后介绍了`@Controller`注解的使用；最后讲解了`@RequestMapping`注解的相关知识，包括其属性和请求映射方式。通过学习本章的内容，能够了解Spring MVC核心类DispatcherServlet的作用，并掌握`@Controller`注解和`@RequestMapping`注解的使用。

### 【思考题】

1. **请简述@Controller注解的使用步骤。**

**引入依赖**：首先，确保你的项目中已经包含了Spring框架的相关依赖。对于Maven项目来说，这通常意味着在`pom.xml`文件中添加了spring-webmvc或相关模块的依赖。

**创建控制器类**：接下来，在你的Java源代码中创建一个新的类。这个类将作为处理HTTP请求的控制器。例如，你可以命名为`MyController`。

**添加@Controller注解**：在新创建的控制器类上方添加`@Controller`注解。这样就告诉Spring这是一个控制器类，其方法可以用来处理Web请求。

```java
@Controller
public class MyController {
    // 控制器的方法定义
}
```

**定义处理器方法**：在控制器类内定义具体的方法来处理特定类型的请求（如GET、POST等）。这些方法需要被映射到具体的URL路径上，通常通过使用`@RequestMapping`或其他更具体的注解（如`@GetMapping`, `@PostMapping`）来实现。

```java
@Controller
public class MyController {
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello, World!";
    }
}
```

**配置视图解析器**（可选）：如果你的应用程序需要返回视图而非简单的文本响应，则可能还需要配置一个视图解析器，比如Thymeleaf或者JSP。这样，当控制器方法返回字符串时，该字符串会被解析为对应的视图名。

2. **请列举@RequestMapping注解的属性（至少3个）。**

**value 或 path**：指定请求映射到的URL模式。这是最常用的属性之一，用于确定哪个URL应该由带有此注解的方法来处理。

```java
@RequestMapping(value = "/users", method = RequestMethod.GET)
public List<User> getUsers() { ... }
```

**method**：限制匹配的HTTP请求类型。例如，你可以指定只允许GET请求访问某个方法。

```java
@RequestMapping(value = "/saveUser", method = RequestMethod.POST)
public void saveUser(@RequestBody User user) { ... }
```

**params**：根据请求参数的存在与否来决定是否匹配。如果指定了参数列表，则只有当请求中包含所有列出的参数时才会调用该方法。

```java
@RequestMapping(value = "/search", params = {"q"})
public String search(@RequestParam("q") String query) { ... }
```

**headers**：类似于`params`属性，但基于HTTP头信息进行过滤。可用于根据请求头的内容来决定路由。

```java
@RequestMapping(value = "/info", headers = "Accept=application/json")
public ResponseEntity<String> info() { ... }
```
