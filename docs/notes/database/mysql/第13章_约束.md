---
title: 第13章_约束
createTime: 2025/09/05 17:41:14
permalink: /mysql/utbdi7eh/
---

## 1. 约束(constraint)概述

### 1.1 为什么需要约束

数据完整性（`Data Integrity`）是指数据的精确性（`Accuracy`）和可靠性（`Reliability`）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的

为了保证数据的完整性，**SQL规范**以约束的方式对 **表数据进行额外的条件限制** 。从以下四个方面考虑:

+ **实体完整性（**`Entity Integrity`**）**：例如，同一个表中，不能存在两条完全相同无法区分的记录
+ **域完整性（**`Domain Integrity`**）**：例如：年龄范围`0~120`，性别范围“男/女”
+ **引用完整性（**`Referential Integrity`**）**：例如：员工所在部门，在部门表中要能找到这个部门
+ **用户自定义完整性（**`User-defined Integrity`**）**：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的 `5` 倍

### 1.2 什么是约束

约束是表级的强制规定

可以在 **创建表时规定约束（通过 **`CREATE TABLE`** 语句）** ，或者在 **表创建之后通过 **`ALTER TABLE`** 语句规定约束**

### 1.3 约束的分类

+ **根据约束数据列的限制**， 约束可分为:
  + **单列约束** ：每个约束只约束一列
  + **多列约束** ：每个约束可约束多列数据
+ **根据约束的作用范围** ，约束可分为:
  + **列级约束** ：只能作用在一个列上，跟在列的定义后面
  + **表级约束** ：可以作用在多个列上，不与列一起，而是单独定义

|  | 位置 | 支持的约束类型 | 是否可以起约束名 |
| --- | --- | --- | --- |
| 列级约束： | 列的后面 | 语法都支持，但外键没有效果 | 不可以 |
| 表级约束： | 所有列的下面 | 默认和非空不支持，其他支持 | 可以（主键没有效果） |

+ **根据约束起的作用** ，约束可分为:
  + `NOT NULL` 非空约束，规定某个字段不能为空
  + `UNIQUE` 唯一约束 ， 规定某个字段在整个表中是唯一的
  + `PRIMARY KEY` 主键(非空且唯一)约束
  + `FOREIGN KEY` 外键约束
  + `CHECK` 检查约束
  + `DEFAULT` 默认值约束

> 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果
>

+ 查看某个表已有的约束

```sql
-- information_schema 数据库名（系统库）
-- table_constraints 表名称（专门存储各个表的约束）

SELECT
    *
FROM
    information_schema.table_constraints
WHERE
    table_name = '表名称';
```

```shell
mysql> SELECT
    ->     *
    -> from
    ->     information_schema.TABLE_CONSTRAINTS
    -> WHERE
    ->     table_name = 'jeecg_order_main';
+--------------------+-------------------+-----------------+-------------------+------------------+-----------------+----------+
| CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA      | TABLE_NAME       | CONSTRAINT_TYPE | ENFORCED |
+--------------------+-------------------+-----------------+-------------------+------------------+-----------------+----------+
| def                | jeecg-boot        | PRIMARY         | jeecg-boot        | jeecg_order_main | PRIMARY KEY     | YES      |
| def                | medical-ai-studio | PRIMARY         | medical-ai-studio | jeecg_order_main | PRIMARY KEY     | YES      |
+--------------------+-------------------+-----------------+-------------------+------------------+-----------------+----------+
2 rows in set (0.00 sec)
```

## 2. 非空约束

### 2.1 作用

限定某个字段/某列的值不允许为空

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1757065155102-51254fd2-2b99-4f45-97aa-498ed5134871.png)

### 2.2 关键字

`NOT NULL`

### 2.3 特点

+ 默认，所有的类型的值都可以是`NULL`，包括`INT`、`FLOAT`等数据类型
+ 非空约束只能出现在表对象的列上，**只能某个列单独限定非空，不能组合非空**
+ 一个表可以有很多列都分别限定了非空
+ **空字符串**`''`**不等于**`NULL`**， **`0`** 也不等于**`NULL`

### 2.4 添加非空约束

（ 1 ）建表时

```sql
CREATE TABLE 表名称 (
    字段名 数据类型,
    字段名 数据类型 NOT NULL,
    字段名 数据类型 NOT NULL
)
```

举例:

```sql
CREATE TABLE student(
    sid int,
    sname varchar(20) not null,
    tel char(11),
    cardid char(18) not null
);
```

```sql
insert into
    student
values
    (1, '张三', '13710011002', '110222198912032545');
```

```shell
mysql> insert into
    ->     student
    -> values
    ->     (2, '李四', '13710011002', null);
ERROR 1048 (23000): Column 'cardid' cannot be null
```

```sql
insert into
    student
values
    (2, '李四', null, '110222198912032546');
```

```shell
mysql> insert into
    ->     student
    -> values
    ->     (3, null, null, '110222198912032547');
ERROR 1048 (23000): Column 'sname' cannot be null
```

（ 2 ）建表后

```sql
ALTER TABLE
    表名称
MODIFY
    字段名 数据类型 NOT NULL;
```

举例:

```sql
CREATE TABLE emp(
    id INT(10) NOT NULL,
    NAME VARCHAR(20) NOT NULL,
    sex CHAR NULL
);
```

```sql
ALTER TABLE
    emp
MODIFY
    sex VARCHAR(30) NOT NULL;
```

```sql
ALTER TABLE
    student
MODIFY
    sname VARCHAR (20) NOT NULL;
```

### 2.5 删除非空约束

```sql
ALTER TABLE
    表名称
MODIFY
    字段名 数据类型 NULL;

-- 去掉not null，相当于修改某个非注解字段，该字段允许为空

-- 或

ALTER TABLE
    表名称
MODIFY
    字段名 数据类型;
-- 去掉not null，相当于修改某个非注解字段，该字段允许为空
```

举例:

```sql
ALTER TABLE
    emp
MODIFY
    sex VARCHAR(30) NULL;
```

```sql
ALTER TABLE
    emp
MODIFY
    NAME VARCHAR(15) DEFAULT 'abc' NULL;
```

## 3. 唯一性约束

### 3.1 作用

用来限制某个字段/某列的值不能重复

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1757065155185-2364d1e7-8c6f-4c43-a5c7-afcc8ce03cd8.png)

### 3.2 关键字

`UNIQUE`

### 3.3 特点

+ 同一个表可以有多个唯一约束
+ **唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一**
+ 唯一性约束允许列值为空
+ 在创建唯一约束的时候，**如果不给唯一约束命名，就默认和列名相同**
+ **MySQL会给唯一约束的列上默认创建一个唯一索引**

### 3.4 添加唯一约束

（ 1 ）建表时

```sql
CREATE TABLE 表名称 (
    字段名 数据类型,
    字段名 数据类型 UNIQUE,     -- 和 UNIQUE KEY用法完全一致
    字段名 数据类型 UNIQUE KEY,
    字段名 数据类型
);

CREATE TABLE 表名称 (
    字段名 数据类型,
    字段名 数据类型,
    字段名 数据类型,
    [ CONSTRAINT 约束名 ] UNIQUE 字段名
);
```

举例:

```sql
create table student(
    sid int,
    sname varchar(20),
    tel char(11) unique,
    cardid char(18) unique key
);
```

```sql
CREATE TABLE t_course(
    cid INT UNIQUE,
    cname VARCHAR(100) UNIQUE,
    description VARCHAR(200)
);
```

```sql
CREATE TABLE USER(
    id INT NOT NULL,
    NAME VARCHAR(25),
    PASSWORD VARCHAR(16),
    -- 使用表级约束语法
    CONSTRAINT uk_name_pwd UNIQUE KEY(NAME, PASSWORD)
);

-- 或

CREATE TABLE USER(
    id INT NOT NULL,
    NAME VARCHAR(25),
    PASSWORD VARCHAR(16),
    -- 使用表级约束语法
    CONSTRAINT uk_name_pwd UNIQUE(NAME, PASSWORD)
);
```

> 表示用户名和密码组合不能重复
>

```sql
insert into
    student
values
    (1, '张三', '13710011002', '101223199012015623');
```

```sql
insert into
    student
values
    (2, '李四', '13710011003', '101223199012015624');
```

```shell
mysql> select * from student;
+------+-------+-------------+--------------------+
| sid  | sname | tel         | cardid             |
+------+-------+-------------+--------------------+
|    1 | 张三  | 13710011002 | 101223199012015623 |
|    2 | 李四  | 13710011003 | 101223199012015624 |
+------+-------+-------------+--------------------+
2 rows in set (0.00 sec)
```

```shell
mysql> insert into
    ->     student
    -> values
    ->     (3, '王五', '13710011004', '101223199012015624');
ERROR 1062 (23000): Duplicate entry '101223199012015624' for key 'cardid'
```

```shell
mysql> insert into
    ->     student
    -> values
    ->     (3, '王五', '13710011003', '101223199012015625');
ERROR 1062 (23000): Duplicate entry '13710011003' for key 'tel'
```

（ 2 ）建表后指定唯一键约束

```sql
--  字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的
-- 方式 1
ALTER TABLE
    表名称
ADD
    UNIQUE KEY (字段列表);

-- 方式 2
ALTER TABLE
    表名称
MODIFY
    字段名 字段类型 UNIQUE;
```

举例:

```sql
ALTER TABLE
    USER
ADD
    UNIQUE(NAME, PASSWORD);
```

```sql
ALTER TABLE
    USER
ADD
    CONSTRAINT uk_name_pwd UNIQUE(NAME, PASSWORD);
```

```sql
ALTER TABLE
    USER
MODIFY
    NAME VARCHAR(20) UNIQUE;
```

举例:

```sql
create table student(
    sid int primary key,
    sname varchar(20),
    tel char(11),
    cardid char(18)
);
```

```sql
alter table
    student
add
    unique key(tel);
```

```sql
alter table
    student
add
    unique key(cardid);
```

### 3.5 关于复合唯一约束

```sql
create table 表名称(
    字段名 数据类型,
    字段名 数据类型,
    字段名 数据类型,
    unique key(字段列表) -- 字段列表中写的是多个字段名，多个字段名用逗号分隔，表示是复合唯一，即多个字段的组合是唯一的
);
```

```sql
##学生表
create table student(
    sid int,
    #学号
    sname varchar(20),
    #姓名
    tel char(11) unique key,
    #电话
    cardid char(18) unique key #身份证号
);
```

```sql
##课程表
create table course(
    cid int,
    #课程编号
    cname varchar(20) #课程名称
);
```

```sql
##选课表
create table student_course(
    id int,
    sid int,
    cid int,
    score int,
    unique key(sid, cid) #复合唯一
);
```

```sql
insert into
    student
values
    (1, '张三', '13710011002', '101223199012015623');

insert into
    student
values
    (2, '李四', '13710011003', '101223199012015624');

insert into
    course
values
    (1001, 'Java'),
    (1002, 'MySQL');
```

```shell
mysql> select * from student;
+------+-------+-------------+--------------------+
| sid  | sname | tel         | cardid             |
+------+-------+-------------+--------------------+
|    1 | 张三  | 13710011002 | 101223199012015623 |
|    2 | 李四  | 13710011003 | 101223199012015624 |
+------+-------+-------------+--------------------+
2 rows in set (0.00 sec)
```

```shell
mysql> select * from course;
+------+-------+
| cid  | cname |
+------+-------+
| 1001 | Java  |
| 1002 | MySQL |
+------+-------+
2 rows in set (0.00 sec)
```

```sql
insert into
    student_course
values
    (1, 1, 1001, 89),
    (2, 1, 1002, 90),
    (3, 2, 1001, 88),
    (4, 2, 1002, 56);
```

```shell
mysql> select * from student_course;
+------+------+------+-------+
| id   | sid  | cid  | score |
+------+------+------+-------+
|    1 |    1 | 1001 |    89 |
|    2 |    1 | 1002 |    90 |
|    3 |    2 | 1001 |    88 |
|    4 |    2 | 1002 |    56 |
+------+------+------+-------+
4 rows in set (0.00 sec)
```

```shell
mysql> insert into
    ->     student_course
    -> values
    ->     (5, 1, 1001, 88);
ERROR 1062 (23000): Duplicate entry '1-1001' for key 'sid'
```

### 3.5 删除唯一约束

+ 添加唯一性约束的列上也会自动创建唯一索引
+ **删除唯一约束只能通过删除唯一索引的方式删除**
+ 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样
+ **如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名**

```sql
SELECT
    *
FROM
    information_schema.table_constraints
WHERE
    table_name = '表名';

-- 查看都有哪些约束
```

```sql
ALTER TABLE
    USER DROP INDEX uk_name_pwd;
```

> 注意：可以通过 `show index from`**表名称**; 查看表的索引
>

## 4. PRIMARY KEY 约束

### 4.1 作用

用来唯一标识表中的一行记录

### 4.2 关键字

`primary key`

### 4.3 特点

+ 主键约束相当于 **唯一约束+非空约束的组合** ，主键约束列不允许重复，也不允许出现空值

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1757065155285-a65138ea-b0b8-4ae7-ac5f-e1256c77069c.png)

+ **一个表最多只能有一个主键约束**，建立主键约束可以在列级别创建，也可以在表级别上创建
+ 主键约束对应着表中的一列或者多列（**复合主键**）
+ 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复
+ **MySQL的主键名总是**`PRIMARY` ，**就算自己命名了主键约束名也没用**
+ 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的 **主键索引** （能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了
+ **需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性**

### 4.4 添加主键约束

（ 1 ）建表时指定主键约束

```sql
CREATE TABLE 表名称 (
    字段名 数据类型 PRIMARY KEY,
    -- 列级模式
    字段名 数据类型,
    字段名 数据类型
);

CREATE TABLE 表名称 (
    字段名 数据类型,
    字段名 数据类型,
    字段名 数据类型,
    [ CONSTRAINT 约束名 ] PRIMARY KEY (字段名, ...) -- 表级模式
);
```

举例:

```sql
CREATE TABLE temp (
 id INT PRIMARY KEY,
 NAME VARCHAR ( 20 ));
```

```shell
mysql> desc temp;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(11)     | NO   | PRI | NULL    |       |
| NAME  | varchar(20) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

```sql
insert into
    temp
values
    (1, '张三');

insert into
    temp
values
    (2, '李四');
```

```shell
mysql> select * from temp;
+----+------+
| id | NAME |
+----+------+
|  1 | 张三 |
|  2 | 李四 |
+----+------+
2 rows in set (0.00 sec)
```

```shell
mysql> insert into
    ->     temp
    -> values
    ->     (1, '张三');
ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'
```

```shell
mysql> insert into
    ->     temp
    -> values
    ->     (1, '王五');
ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'
```

```sql
insert into
    temp
values
    (3, '张三');
```

```shell
mysql> select * from temp;
+----+------+
| id | NAME |
+----+------+
|  1 | 张三 |
|  2 | 李四 |
|  3 | 张三 |
+----+------+
3 rows in set (0.00 sec)
```

```sql
insert into
    temp
values
    (4, null);
```

```shell
mysql> insert into
    ->     temp
    -> values
    ->     (null, '李琦');
ERROR 1048 (23000): Column 'id' cannot be null
```

```shell
mysql> select * from temp;
+----+------+
| id | NAME |
+----+------+
|  1 | 张三 |
|  2 | 李四 |
|  3 | 张三 |
|  4 | NULL |
+----+------+
4 rows in set (0.00 sec)
```

```shell
-- 演示一个表建立两个主键约束
mysql> create table temp(
    ->     id int primary key,
    ->     name varchar(20) primary key
    -> );
ERROR 1068 (42000): Multiple primary key defined
```

再举例:

+ 列级约束

```sql
CREATE TABLE emp4(
    id INT PRIMARY KEY AUTO_INCREMENT, -- 列级别
    NAME VARCHAR(20)
);
```

+ 表级约束

```sql
CREATE TABLE emp5(
    id INT NOT NULL AUTO_INCREMENT,
    NAME VARCHAR(20),
    pwd VARCHAR(15),
    CONSTRAINT emp5_id_pk PRIMARY KEY(id) -- 表级别
);
```

（ 2 ）建表后增加主键约束

```sql
ALTER TABLE
    表名称
ADD
    PRIMARY KEY(字段列表);

-- 字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键
```

```sql
ALTER TABLE
    student
ADD
    PRIMARY KEY (sid);
```

```sql
ALTER TABLE
    emp5
ADD
    PRIMARY KEY(NAME, pwd);
```

### 4.5 关于复合主键

```sql
CREATE TABLE 表名称 (
    字段名 数据类型,
    字段名 数据类型,
    字段名 数据类型,
    PRIMARY KEY (字段名 1, 字段名 2) -- 表示字段 1 和字段 2 的组合是唯一的，也可以有更多个字段
);
```

```sql
##学生表
create table student(
    sid int primary key,
    #学号
    sname varchar(20) #学生姓名
);
```

```sql
##课程表
create table course(
    cid int primary key,
    #课程编号
    cname varchar(20) #课程名称
);
```

```sql
##选课表
create table student_course(
    sid int,
    cid int,
    score int,
    primary key(sid, cid) #复合主键
);
```

```sql
insert into
    student
values
    (1, '张三'),
    (2, '李四');
```

```sql
insert into
    course
values
    (1001, 'Java'),
    (1002, 'MySQL');
```

```shell
mysql> select * from student;
+-----+-------+
| sid | sname |
+-----+-------+
|   1 | 张三  |
|   2 | 李四  |
+-----+-------+
2 rows in set (0.00 sec)
```

```shell
mysql> select * from course;
+------+-------+
| cid  | cname |
+------+-------+
| 1001 | Java  |
| 1002 | MySQL |
+------+-------+
2 rows in set (0.00 sec)
```

```sql
insert into
    student_course
values
    (1, 1001, 89),
    (1, 1002, 90),
    (2, 1001, 88),
    (2, 1002, 56);
```

```shell
mysql> select * from student_course;
+-----+------+-------+
| sid | cid  | score |
+-----+------+-------+
|   1 | 1001 |    89 |
|   1 | 1002 |    90 |
|   2 | 1001 |    88 |
|   2 | 1002 |    56 |
+-----+------+-------+
4 rows in set (0.00 sec)
```

```shell
mysql> insert into
    ->     student_course
    -> values
    ->     (1, 1001, 100);
ERROR 1062 (23000): Duplicate entry '1-1001' for key 'PRIMARY'
```

```shell
mysql> desc student_course;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| sid   | int(11) | NO   | PRI | NULL    |       |
| cid   | int(11) | NO   | PRI | NULL    |       |
| score | int(11) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

+ 再举例:

```sql
CREATE TABLE emp6(
    id INT NOT NULL,
    NAME VARCHAR(20),
    pwd VARCHAR(15),
    CONSTRAINT emp7_pk PRIMARY KEY(NAME, pwd)
);
```

### 4.6 删除主键约束

```sql
ALTER TABLE
    表名称 DROP PRIMARY KEY;
```

举例:

```sql
ALTER TABLE
    student DROP PRIMARY KEY;
```

```sql
ALTER TABLE
    emp5 DROP PRIMARY KEY;
```

> 说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，**删除主键约束后，非空还存在**
>

## 5. 自增列：AUTO_INCREMENT

### 5.1 作用

某个字段的值自增

### 5.2 关键字

`auto_increment`

### 5.3 特点和要求

+ （ 1 ）一个表**最多只能有一个自增长列**
+ （ 2 ）当需要产生唯一标识符或顺序值时，可设置自增长
+ （ 3 ）**自增长列约束的列必须是键列（主键列，唯一键列）**
+ （ 4 ）**自增约束的列的数据类型必须是整数类型**
+ （ 5 ）**如果自增列指定了 **`0`** 和 **`null`**，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值**

错误演示:

```shell
mysql> CREATE TABLE employee (
    ->     eid INT auto_increment,
    ->     ename VARCHAR (20)
    -> );
ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
```

```shell
mysql> create table employee(
    ->     eid int primary key,
    ->     ename varchar(20) unique key auto_increment
    -> );
ERROR 1063 (42000): Incorrect column specifier for column 'ename'
-- 列不是整数类型
```

### 5.4 如何指定自增约束

（ 1 ）建表时

```sql
CREATE TABLE 表名称 (
    字段名 数据类型 PRIMARY KEY auto_increment, -- 主键列
    字段名 数据类型 UNIQUE KEY NOT NULL,
    字段名 数据类型 UNIQUE KEY,
    字段名 数据类型 NOT NULL DEFAULT 默认值,
);
```

```sql
CREATE TABLE 表名称 (
    字段名 数据类型 DEFAULT 默认值,
    字段名 数据类型 UNIQUE KEY auto_increment, -- 唯一键列
    字段名 数据类型 NOT NULL DEFAULT 默认值,
    PRIMARY KEY (字段名)
);
```

```sql
CREATE TABLE employee (
    eid INT PRIMARY KEY auto_increment,
    ename VARCHAR (20)
);
```

```shell
mysql> desc employee;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| eid   | int(11)     | NO   | PRI | NULL    | auto_increment |
| ename | varchar(20) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)
```

（ 2 ）建表后

```sql
ALTER TABLE
    表名称
MODIFY
    字段名 数据类型 auto_increment;
```

例如:

```sql
CREATE TABLE employee (
 eid INT PRIMARY KEY,
 ename VARCHAR ( 20 ));
```

```sql
alter table
    employee
modify
    eid int auto_increment;
```

```shell
mysql> desc employee;
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| eid   | int(11)     | NO   | PRI | NULL    | auto_increment |
| ename | varchar(20) | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)
```

### 5.5 如何删除自增约束

```sql
-- alter table 表名称 modify 字段名 数据类型 auto_increment; -- 给这个字段增加自增约束

ALTER TABLE
    表名称
MODIFY
    字段名 数据类型;
-- 去掉auto_increment相当于删除
```

```sql
alter table
    employee
modify
    eid int;
```

```shell
mysql> desc employee;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| eid   | int(11)     | NO   | PRI | NULL    |       |
| ename | varchar(20) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

### 5.6 MySQL 8.0 新特性—自增变量的持久化

在MySQL 8.0之前，自增主键`AUTO_INCREMENT`的值如果大于`max(primary key)+1`，在MySQL重启后，会重置`AUTO_INCREMENT=max(primary key)+1`，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。

下面通过案例来对比不同的版本中自增变量是否持久化。

在`MySQL 5.7`版本中，测试步骤如下：

创建的数据表中包含自增主键的id字段，语句如下:

```sql
CREATE TABLE test1 (id INT PRIMARY KEY AUTO_INCREMENT);
```

插入 4 个空值，执行如下:

```sql
INSERT INTO
    test1
VALUES
    (0),
    (0),
    (0),
    (0);
```

补充：  
对于 MySQL 的自增列（`AUTO_INCREMENT`），**你插入时指定的值（如 **`0`**, **`NULL`** 或不指定）更像是一个“信号”**，告诉 MySQL：“请忽略这个值，并自动为这个字段生成下一个递增值”。引擎会根据其内部维护的自增计数器来分配值，而不是直接使用你提供的值。

| 你插入的值 | MySQL 的实际行为 (针对自增列) | 结果示例 (假设当前自增值为 5) |
| --- | --- | --- |
| **不指定该字段** | 自动分配下一个自增值 | 插入 `6` |
| **插入 `NULL`** | 自动分配下一个自增值 | 插入 `6` |
| **插入 `0`** | **默认情况下**，自动分配下一个自增值 | 插入 `6` |
| **插入一个具体的数值** (如 `100`) | **尊重你提供的值**，并会将自增计数器调整为 `最大值(当前计数器值, 你提供的值) + 1` | 插入 `100`，且后续自增值从 `101` 开始 |

⚠️ 关于插入 `0` 的特别说明：  
默认情况下，在 MySQL 中为自增列插入 `0` 会触发自动分配下一个值。但你可以通过修改 SQL 模式来改变这一行为：

```sql
-- 设置 SQL 模式，使 0 不被视为自增信号的触发器
SET SESSION sql_mode = 'NO_AUTO_VALUE_ON_ZERO';
```

设置此模式后，插入 `0` 就会真正地向字段插入数值 `0`。而 `NULL` 仍然会触发自动分配机制。

查询数据表`test1`中的数据，结果如下:

```shell
mysql> SELECT * FROM test1;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
+----+
4 rows in set (0.00 sec)
```

删除`id`为 `4` 的记录，语句如下:

```sql
DELETE FROM
    test1
WHERE
    id = 4;
```

再次插入一个空值，语句如下:

```sql
INSERT INTO
    test1
VALUES
    (0);
```

查询此时数据表`test1`中的数据，结果如下:

```shell
mysql> SELECT * FROM test1;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
|  5 |
+----+
4 rows in set (0.00 sec)
```

从结果可以看出，虽然删除了`id`为 `4` 的记录，但是再次插入空值时，并没有重用被删除的 `4` ，而是分配了`5` 。 删除`id`为 `5` 的记录，结果如下:

```sql
DELETE FROM
    test1
where
    id = 5;
```

重启数据库 ，重新插入一个空值。

```sql
INSERT INTO
    test1
values
    (0);
```

再次查询数据表`test1`中的数据，结果如下：

```shell
mysql> SELECT * FROM test1;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
+----+
4 rows in set (0.00 sec)
```

从结果可以看出，新插入的 `0` 值分配的是 `4` ，按照重启前的操作逻辑，此处应该分配 `6` 。出现上述结果的主要原因是**自增主键没有持久化**。 在`MySQL 5.7`系统中，对于自增主键的分配规则，是由`InnoDB`数据字典内部一个**计数器**来决定的，而该计数器**只在内存中维护**，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。

在MySQL 8.0 版本中，上述测试步骤：

```sql
-- 1
CREATE TABLE test1 (id INT PRIMARY KEY AUTO_INCREMENT);

-- 2
INSERT INTO
    test1
VALUES
    (0),
    (0),
    (0),
    (0);

-- 3
-- mysql> SELECT * FROM test1;
-- +----+
-- | id |
-- +----+
-- |  1 |
-- |  2 |
-- |  3 |
-- |  4 |
-- +----+
-- 4 rows in set (0.00 sec)

-- 4
DELETE FROM
    test1
WHERE
    id = 4;
    
-- 5
INSERT INTO
    test1
VALUES
    (0);
    
-- 6
-- mysql> SELECT * FROM test1;
-- +----+
-- | id |
-- +----+
-- |  1 |
-- |  2 |
-- |  3 |
-- |  5 |
-- +----+
-- 4 rows in set (0.00 sec)

-- 7 重启数据库

-- 8 
INSERT INTO
    test1
values
    (0);

-- 9
-- mysql> SELECT * FROM test1;
-- +----+
-- | id |
-- +----+
-- |  1 |
-- |  2 |
-- |  3 |
-- |  5 |
-- |  6 |
-- +----+
-- 5 rows in set (0.00 sec)
```

从结果可以看出，自增变量已经持久化了

**MySQL 8.0 将自增主键的计数器持久化到重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，**`InnoDB`**会根据重做日志中的信息来初始化计数器的内存值。**

## 6. FOREIGN KEY 约束

### 6.1 作用

限定某个表的某个字段的**引用完整性**

比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1757065155363-8acf068a-42cf-4799-80c1-3b1e1753686c.png)

### 6.2 关键字

`FOREIGN KEY`

### 6.3 主表和从表 / 父表和子表

**主表**（父表）：被引用的表，被参考的表

**从表**（子表）：引用别人的表，参考别人的表

例如：员工表的员工所在部门这个字段的值要参考部门表：**部门表是主表**，**员工表是从表**

例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，**学生表和课程表是主表**，**选课表是从表**

### 6.4 特点

（ 1 ）从表的外键列，必须引用/参考主表的主键或唯一约束的列

为什么？因为被依赖/被参考的值必须是唯一的

（ 2 ）在创建外键约束时，如果不给外键约束命名， **默认名不是列名，而是自动产生一个外键名** （例如 `student_ibfk_1`），也可以指定外键约束名

（ 3 ）创建(`CREATE`)表时就指定外键约束的话，先创建主表，再创建从表

（ 4 ）删表时，**先删从表（或先删除外键约束），再删除主表**

（ 5 ）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据

（ 6 ）在“从表”中指定外键约束，并且**一个表可以建立多个外键约束**

（ 7 ）**从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致**。如果类型不一样，创建子表时，就会出现错误“`ERROR 1005 (HY000): Can't create table'database.tablename'(errno: 150)`”

例如：都是表示部门编号，都是`int`类型

（ 8 ） **当创建外键约束时，系统默认会在所在的列上建立对应的普通索引 。但是索引名是外键的约束名。（根据外键查询效率很高）**

（ 9 ）**删除外键约束后，必须手动删除对应的索引**

### 6.5 添加外键约束

（ 1 ）建表时

```sql
CREATE TABLE 主表名称 (
 字段 1 数据类型 PRIMARY KEY,
 字段 2 数据类型 );

CREATE TABLE 从表名称 (
    字段 1 数据类型 PRIMARY KEY,
    字段 2 数据类型,
    [ CONSTRAINT <外键约束名称>] FOREIGN KEY (从表的某个字段) REFERENCES 主表名 (被参考字段)
);

--  (从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样
--  (从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样

-- FOREIGN KEY: 在表级指定子表中的列
-- REFERENCES: 标示在父表中的列
```

```sql
create table dept(
    #主表
    did int primary key,
    #部门编号
    dname varchar(50) #部门名称
);

create table emp(
    #从表
    eid int primary key,
    #员工编号
    ename varchar(5),
    #员工姓名
    deptid int,
    #员工所在的部门
    foreign key (deptid) references dept(did) #在从表中指定外键约束
    # emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号
);

# 说明

（ 1 ）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。
（ 2 ）删除表时，先删除从表emp，再删除主表dept
```

（ 2 ）建表后  
一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义

格式：

```sql
ALTER TABLE
    从表名
ADD
    [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx] [on delete xx];
```

举例:

```sql
ALTER TABLE
    emp
ADD
    [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);
```

举例:

```sql
create table dept(
    did int primary key,
    #部门编号
    dname varchar(50) #部门名称
);

create table emp(
    eid int primary key,
    #员工编号
    ename varchar(5),
    #员工姓名
    deptid int #员工所在的部门
);
--  这两个表创建时，没有指定外键的话，那么创建顺序是随意
```

```sql
alter table
    emp
add
    foreign key (deptid) references dept(did);
```

### 6.6 演示问题

（ 1 ）失败：不是键列

```sql
create table dept(
    did int,
    #部门编号
    dname varchar(50) #部门名称
);
```

```shell
mysql> create table emp(
    ->     eid int primary key,
    ->     #员工编号
    ->     ename varchar(5),
    ->     #员工姓名
    ->     deptid int,
    ->     #员工所在的部门
    ->     foreign key (deptid) references dept(did)
    -> );
ERROR 1822 (HY000): Failed to add the foreign key constraint. Missing index for constraint 'emp_ibfk_1' in the referenced table 'dept'

-- did不是键列
```

（ 2 ）失败：数据类型不一致

```sql
create table dept(
    did int primary key,
    #部门编号
    dname varchar(50) #部门名称
);
```

```shell
mysql> create table emp(
    ->     eid int primary key,
    ->     #员工编号
    ->     ename varchar(5),
    ->     #员工姓名
    ->     deptid char,
    ->     #员工所在的部门
    ->     foreign key (deptid) references dept(did)
    -> );
ERROR 3780 (HY000): Referencing column 'deptid' and referenced column 'did' in foreign key constraint 'emp_ibfk_1' are incompatible.

-- 原因是从表的deptid字段和主表的did字段的数据类型不一致，并且要它俩的逻辑意义一致
```

（ 3 ）成功，两个表字段名一样

```sql
create table dept(
    did int primary key,
    #部门编号
    dname varchar(50) #部门名称
);

create table emp(
    eid int primary key,
    #员工编号
    ename varchar(5),
    #员工姓名
    did int,
    #员工所在的部门
    foreign key (did) references dept(did) # emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号
    # 是否重名没问题，因为两个did在不同的表中
);
```

（ 4 ）添加、删除、修改问题

```sql
create table dept(
    did int primary key,
    #部门编号
    dname varchar(50) #部门名称
);

create table emp(
    eid int primary key,
    #员工编号
    ename varchar(5),
    #员工姓名
    deptid int,
    #员工所在的部门
    foreign key (deptid) references dept(did) 
    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号
);
```

```sql
insert into
    dept
values
(1001, '教学部');

insert into
    dept
values
(1003, '财务部');

insert into
    emp
values
(1, '张三', 1001);

#添加从表记录成功，在添加这条记录时，要求部门表有 1001 部门
```

```shell
mysql> insert into
    ->     emp
    -> values
    -> (2, '李四', 1005);
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))
-- 部门不存在
```

```shell
mysql> select * from dept;
+------+--------+
| did  | dname  |
+------+--------+
| 1001 | 教学部 |
| 1003 | 财务部 |
+------+--------+
2 rows in set (0.00 sec)
```

```shell
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   1 | 张三  |   1001 |
+-----+-------+--------+
1 row in set (0.00 sec)
```

```shell
mysql> update
    ->     emp
    -> set
    ->     deptid = 1002
    -> where
    ->     eid = 1;
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))
-- 修改从表失败 部门不存在
```

```shell
mysql> update
    ->     dept
    -> set
    ->     did = 1002
    -> where
    ->     did = 1001;
ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))
-- 修改主表失败 在 MySQL 中，如果主表的某个字段（通常是主键或唯一键）被从表通过外键约束引用，那么默认情况下，数据库会严格限制你对主表该字段值的修改或删除，以此维护数据的引用完整性。
```

```sql
update
    dept
set
    did = 1002
where
    did = 1003;

-- 修改主表成功 因为部门表的 1003 部门没有被emp表引用 ， 所以可以修改
```

```shell
mysql> delete from
    ->     dept
    -> where
    ->     did = 1001;
ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))

-- 删除主表失败 在 MySQL 中，如果主表的某个字段（通常是主键或唯一键）被从表通过外键约束引用，那么默认情况下，数据库会严格限制你对主表该字段值的修改或删除，以此维护数据的引用完整性。
```

总结：约束关系是针对双方的

+ 添加了外键约束后，主表的**修改和删除**数据受约束
+ 添加了外键约束后，从表的**添加和修改**数据受约束
+ **在从表上建立外键，要求主表必须存在**
+ **删除主表时，要求从表先删除，或将从表中外键引用该主表的关系先删除**

### 6.7 约束等级

+ `Cascade`**方式**：在父表上`update/delete`记录时，同步`update/delete`掉子表的匹配记录
+ `Set null`**方式**：在父表上`update/delete`记录时，将子表上匹配记录的列设为`null`，但是要注意子表的外键列不能为`not null`
+ `No action`**方式**：如果子表中有匹配的记录，则不允许对父表对应候选键进行`update/delete`操作
+ `Restrict`**方式**：同`no action`， 都是立即检查外键约束
+ `Set default`**方式**（在可视化工具`SQLyog`中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但`Innodb`不能识别

**如果没有指定等级，就相当于**`Restrict`**方式**

对于外键约束，最好是采用: `ON UPDATE CASCADE` `ON DELETE RESTRICT` 的方式

（ 1 ）演示 1 ：`on update cascade` `on delete set null`

```sql
create table dept(
    did int primary key,
    #部门编号
    dname varchar(50) #部门名称
);

create table emp(
    eid int primary key,
    #员工编号
    ename varchar(5),
    #员工姓名
    deptid int,
    #员工所在的部门
    foreign key (deptid) references dept(did) on update cascade on delete set null 
    #把修改操作设置为级联修改等级，把删除操作设置为set null等级
);

insert into
    dept
values
    (1001, '教学部');

insert into
    dept
values
    (1002, '财务部');

insert into
    dept
values
    (1003, '咨询部');

insert into
    emp
values
    (1, '张三', 1001);

-- 在添加这条记录时，要求部门表有 1001 部门
insert into
    emp
values
    (2, '李四', 1001);

insert into
    emp
values
    (3, '王五', 1002);
```

```shell
mysql>  select * from dept;
+------+--------+
| did  | dname  |
+------+--------+
| 1001 | 教学部 |
| 1002 | 财务部 |
| 1003 | 咨询部 |
+------+--------+
3 rows in set (0.00 sec)

```

```shell
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   1 | 张三  |   1001 |
|   2 | 李四  |   1001 |
|   3 | 王五  |   1002 |
+-----+-------+--------+
3 rows in set (0.00 sec)
```

```shell
-- 修改主表成功，从表也跟着修改，修改了主表被引用的字段 1002 为 1004 ，从表的引用字段就跟着修改为 1004 了
mysql> update
    ->     dept
    -> set
    ->     did = 1004
    -> where
    ->     did = 1002;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from dept;
+------+--------+
| did  | dname  |
+------+--------+
| 1001 | 教学部 |
| 1003 | 咨询部 |
| 1004 | 财务部 |
+------+--------+
3 rows in set (0.00 sec)
    
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   1 | 张三  |   1001 |
|   2 | 李四  |   1001 |
|   3 | 王五  |   1004 |
+-----+-------+--------+
3 rows in set (0.00 sec)
```

```shell
-- 删除主表的记录成功，从表对应的字段的值被修改为null
mysql> delete from
    ->     dept
    -> where
    ->     did = 1001;
Query OK, 1 row affected (0.00 sec)

mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   1 | 张三  |   NULL |
|   2 | 李四  |   NULL |
|   3 | 王五  |   1004 |
+-----+-------+--------+
3 rows in set (0.00 sec)
```

（ 2 ）演示 2 ：`on update set null` `on delete cascade`

```sql
create table dept(
    did int primary key,
    #部门编号
    dname varchar(50) #部门名称
);

create table emp(
    eid int primary key,
    #员工编号
    ename varchar(5),
    #员工姓名
    deptid int,
    #员工所在的部门
    foreign key (deptid) references dept(did) on update set null on delete cascade 
    #把修改操作设置为set null等级，把删除操作设置为级联删除等级
);
```

```sql
insert into
    dept
values
    (1001, '教学部');

insert into
    dept
values
    (1002, '财务部');

insert into
    dept
values
    (1003, '咨询部');

insert into
    emp
values
    (1, '张三', 1001);

-- 在添加这条记录时，要求部门表有 1001 部门
insert into
    emp
values
    (2, '李四', 1001);

insert into
    emp
values
    (3, '王五', 1002);
```

```shell
mysql> select * from dept;
+------+--------+
| did  | dname  |
+------+--------+
| 1001 | 教学部 |
| 1002 | 财务部 |
| 1003 | 咨询部 |
+------+--------+
3 rows in set (0.00 sec)
```

```shell
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   1 | 张三  |   1001 |
|   2 | 李四  |   1001 |
|   3 | 王五  |   1002 |
+-----+-------+--------+
3 rows in set (0.00 sec)```

```shell
-- 修改主表，从表对应的字段设置为null
mysql> update
    ->     dept
    -> set
    ->     did = 1004
    -> where
    ->     did = 1002;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from dept;
+------+--------+
| did  | dname  |
+------+--------+
| 1001 | 教学部 |
| 1003 | 咨询部 |
| 1004 | 财务部 |
+------+--------+
3 rows in set (0.00 sec)

mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   1 | 张三  |   1001 |
|   2 | 李四  |   1001 |
|   3 | 王五  |   NULL |
+-----+-------+--------+
3 rows in set (0.00 sec)
```

```shell
-- 删除主表的记录成功，主表的 1001 行被删除了，从表相应的记录也被删除了
mysql> delete from
    ->     dept
    -> where
    ->     did = 1001;
Query OK, 1 row affected (0.00 sec)

mysql> select * from dept;
+------+--------+
| did  | dname  |
+------+--------+
| 1003 | 咨询部 |
| 1004 | 财务部 |
+------+--------+
2 rows in set (0.00 sec)

mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   3 | 王五  |   NULL |
+-----+-------+--------+
1 row in set (0.00 sec)
```

（ 3 ）演示：`on update cascade` `on delete cascade`

```sql
create table dept(
    did int primary key,
    #部门编号
    dname varchar(50) #部门名称
);

create table emp(
    eid int primary key,
    #员工编号
    ename varchar(5),
    #员工姓名
    deptid int,
    #员工所在的部门
    foreign key (deptid) references dept(did) on update cascade on delete cascade 
    #把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级
);
```

```sql
insert into
    dept
values
    (1001, '教学部');

insert into
    dept
values
    (1002, '财务部');

insert into
    dept
values
    (1003, '咨询部');

insert into
    emp
values
    (1, '张三', 1001);

#在添加这条记录时，要求部门表有 1001 部门
insert into
    emp
values
    (2, '李四', 1001);

insert into
    emp
values
    (3, '王五', 1002);
```

```shell
mysql> select * from dept;
+------+--------+
| did  | dname  |
+------+--------+
| 1001 | 教学部 |
| 1002 | 财务部 |
| 1003 | 咨询部 |
+------+--------+
3 rows in set (0.00 sec)
```

```shell
mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   1 | 张三  |   1001 |
|   2 | 李四  |   1001 |
|   3 | 王五  |   1002 |
+-----+-------+--------+
3 rows in set (0.00 sec)
```

```shell
-- 修改主表，从表对应的字段自动修改
mysql> update
    ->     dept
    -> set
    ->     did = 1004
    -> where
    ->     did = 1002;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from dept;
+------+--------+
| did  | dname  |
+------+--------+
| 1001 | 教学部 |
| 1003 | 咨询部 |
| 1004 | 财务部 |
+------+--------+
3 rows in set (0.00 sec)

mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   1 | 张三  |   1001 |
|   2 | 李四  |   1001 |
|   3 | 王五  |   1004 |
+-----+-------+--------+
3 rows in set (0.00 sec)
```

```shell
-- 删除主表的记录成功，主表的 1001 行被删除了，从表相应的记录也被删除了
mysql> delete from
    ->     dept
    -> where
    ->     did = 1001;
Query OK, 1 row affected (0.00 sec)

mysql> select * from dept;
+------+--------+
| did  | dname  |
+------+--------+
| 1003 | 咨询部 |
| 1004 | 财务部 |
+------+--------+
2 rows in set (0.00 sec)

mysql> select * from emp;
+-----+-------+--------+
| eid | ename | deptid |
+-----+-------+--------+
|   3 | 王五  |   1004 |
+-----+-------+--------+
1 row in set (0.00 sec)
```

### 6.8 删除外键约束

流程如下：

```sql
-- ( 1 )第一步先查看约束名和删除外键约束

-- 查看某个表的约束名
SELECT
    *
FROM
    information_schema.table_constraints
WHERE
    table_name = '表名称';

-- 删除外键约束
ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;
```

```sql
--（ 2 ）第二步查看索引名和删除索引。（注意，只能手动删除）

-- 查看某个表的索引名
SHOW INDEX
FROM
    表名称;

-- 删除索引
ALTER TABLE
    从表名 DROP INDEX 索引名;
```

举例:

```sql
SELECT
    *
FROM
    information_schema.table_constraints
WHERE
    table_name = 'emp';
```

```shell
mysql> SELECT
    ->     *
    -> FROM
    ->     information_schema.table_constraints
    -> WHERE
    ->     table_name = 'emp';
+--------------------+-------------------+-----------------+--------------+------------+-----------------+----------+
| CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA | TABLE_NAME | CONSTRAINT_TYPE | ENFORCED |
+--------------------+-------------------+-----------------+--------------+------------+-----------------+----------+
| def                | atguigudb         | PRIMARY         | atguigudb    | emp        | PRIMARY KEY     | YES      |
| def                | atguigudb         | emp_ibfk_1      | atguigudb    | emp        | FOREIGN KEY     | YES      |
+--------------------+-------------------+-----------------+--------------+------------+-----------------+----------+
```

```sql
alter table
    emp drop foreign key emp_ibfk_1;
```

```shell
mysql> SELECT
    ->     *
    -> FROM
    ->     information_schema.table_constraints
    -> WHERE
    ->     table_name = 'emp';
+--------------------+-------------------+-----------------+--------------+------------+-----------------+----------+
| CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA | TABLE_NAME | CONSTRAINT_TYPE | ENFORCED |
+--------------------+-------------------+-----------------+--------------+------------+-----------------+----------+
| def                | atguigudb         | PRIMARY         | atguigudb    | emp        | PRIMARY KEY     | YES      |
+--------------------+-------------------+-----------------+--------------+------------+-----------------+----------+
1 row in set (0.00 sec)
```

```sql
show index
from
    emp;
```

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1757065155433-0a2e2885-a747-4bde-bdcb-e94a63b8acf4.png)

```sql
alter table
    emp drop index deptid;
```

```sql
show index
from
    emp;
```

![](https://cdn.nlark.com/yuque/0/2025/png/2447732/1757065155505-1ff49c19-9c01-4c5e-ba35-a4ca9bd3db8e.png)

### 6.9 开发场景

**问题 1 ：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？**

答：不是的

**问题 2 ：建和不建外键约束有什么区别？**

答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。  
例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到

不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的**引用完整性**，只能依靠**程序员的自觉**，或者是在Java**程序中进行限定**。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门

**问题 3 ：那么建和不建外键约束和查询有没有关系？**

答：没有

> 在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会**因为外键约束的系统开销而变得非常慢**。所以， MySQL 允许你不使用系统自带的外键约束，**在应用层面完成**检查数据一致性的逻辑。**也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性**
>

### 6.10 阿里开发规范

【**强制**】不得使用外键与级联，一切外键概念必须在应用层解决

说明：（概念解释）学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的`student_id` 更新，即为级联更新。外键与级联更新**适用于单机低并发**，**不适合分布式、高并发集群**；级联更新是强阻塞，存在数据库**更新风暴**的风险；**外键影响数据库的插入速度**。

## 7. CHECK 约束

### 7.1 作用

检查某个字段的值是否符合xx要求，一般指的是值的范围

### 7.2 关键字

`CHECK`

### 7.3 说明：MySQL 5.7 不支持

`MySQL5.7`**可以使用**`check`**约束，但**`check`**约束对数据验证没有任何作用。添加数据时，没有任何错误或警告**

但是 **MySQL 8.0中可以使用**`check`**约束了**

`MySQL5.7`中：

```sql
create table employee(
    eid int primary key,
    ename varchar(5),
    gender char check('男' or '女')
);
```

```sql
insert into
    employee
values
    (1, '张三', '妖');
```

```shell
-- check未生效
mysql> select * from employee;
+-----+-------+--------+
| eid | ename | gender |
+-----+-------+--------+
|   1 | 张三  | 妖     |
+-----+-------+--------+
1 row in set (0.00 sec)
```

再举例(MySQL 8.0中):

```shell
mysql> CREATE TABLE temp(
    ->     id INT AUTO_INCREMENT,
    ->     NAME VARCHAR(20),
    ->     age INT CHECK(age > 20),
    ->     PRIMARY KEY(id)
    -> );
Query OK, 0 rows affected (0.01 sec)
```

再举例:

```sql
age tinyint check(age > 20) 
-- 或
 sex char(2) check(sex in('男', '女'))
```

再举例:

```sql
CHECK(
    height >= 0
    AND height < 3
)
```

## 8. DEFAULT约束

### 8.1 作用

给某个 字段/某列 **指定默认值**，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值

### 8.2 关键字

`DEFAULT`

### 8.3 如何给字段加默认值

（ 1 ）建表时

```sql
create table 表名称(
    字段名 数据类型 primary key,
    字段名 数据类型 unique key not null,
    字段名 数据类型 unique key,
    字段名 数据类型 not null default 默认值,
);
```

```sql
create table 表名称(
    字段名 数据类型 default 默认值,
    字段名 数据类型 not null default 默认值,
    字段名 数据类型 not null default 默认值,
    primary key(字段名),
    unique key(字段名)
);

-- 说明：默认值约束一般不在唯一键和主键列上加
```

```sql
create table employee(
    eid int primary key,
    ename varchar(20) not null,
    gender char default '男',
    tel char(11) not null default '' -- 默认是空字符串
);
```

```shell
mysql> desc employee;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| eid    | int         | NO   | PRI | NULL    |       |
| ename  | varchar(20) | NO   |     | NULL    |       |
| gender | char(1)     | YES  |     | 男      |       |
| tel    | char(11)    | NO   |     |         |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

```sql
insert into
    employee
values
    (1, '汪飞', '男', '13700102535');
```

```shell
mysql> select * from employee;
+-----+-------+--------+-------------+
| eid | ename | gender | tel         |
+-----+-------+--------+-------------+
|   1 | 汪飞  | 男     | 13700102535 |
+-----+-------+--------+-------------+
1 row in set (0.00 sec)
```

```sql
insert into
    employee(eid, ename)
values
    (2, '天琪');
```

```shell
mysql> select * from employee;
+-----+-------+--------+-------------+
| eid | ename | gender | tel         |
+-----+-------+--------+-------------+
|   1 | 汪飞  | 男     | 13700102535 |
|   2 | 天琪  | 男     |             |
+-----+-------+--------+-------------+
2 rows in set (0.00 sec)
```

```sql
insert into
    employee(eid, ename)
values
(3, '二虎');

-- ERROR 1062 (23000): Duplicate entry '' for key 'tel' 
-- 如果tel有唯一性约束的话会报错，如果tel没有唯一性约束，可以添加成功 
```

再举例:

```sql
CREATE TABLE myemp(
    id INT AUTO_INCREMENT PRIMARY KEY,
    NAME VARCHAR(15),
    salary DOUBLE(10, 2) DEFAULT 2000
);
```

（ 2 ）建表后

```sql
alter table 表名称 modify 字段名 数据类型 default 默认值;

-- 如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了

-- 同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了

alter table
    表名称
modify
    字段名 数据类型 default 默认值 not null;
```

```sql
create table employee(
    eid int primary key,
    ename varchar(20),
    gender char,
    tel char(11) not null
);
```

```shell
mysql> desc employee;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| eid    | int         | NO   | PRI | NULL    |       |
| ename  | varchar(20) | YES  |     | NULL    |       |
| gender | char(1)     | YES  |     | NULL    |       |
| tel    | char(11)    | NO   |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

```sql
-- 给gender字段增加默认值约束
alter table
    employee
modify
    gender char default '男';

-- 给tel字段增加默认值约束
alter table
    employee
modify
    tel char(11) default '';
```

```shell
mysql> desc employee;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| eid    | int         | NO   | PRI | NULL    |       |
| ename  | varchar(20) | YES  |     | NULL    |       |
| gender | char(1)     | YES  |     | 男      |       |
| tel    | char(11)    | YES  |     |         |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
-- 可以看到 tel的非空约束被删除了
```

```sql
alter table
    employee
modify
    tel char(11) default '' not null;
-- 给tel字段增加默认值约束，并保留非空约束
```

```shell
mysql> desc employee;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| eid    | int         | NO   | PRI | NULL    |       |
| ename  | varchar(20) | YES  |     | NULL    |       |
| gender | char(1)     | YES  |     | 男      |       |
| tel    | char(11)    | NO   |     |         |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

### 8.4 如何删除默认值约束

```sql
-- 删除默认值约束，也不保留非空约束
alter table
    表名称
modify
    字段名 数据类型;

-- 删除默认值约束，保留非空约束
alter table
    表名称
modify
    字段名 数据类型 not null;
```

```sql
-- 删除gender字段默认值约束，如果有非空约束，也一并删除
alter table
    employee
modify
    gender char;

-- 删除tel字段默认值约束，保留非空约束
alter table
    employee
modify
    tel char(11) not null;
```

```shell
mysql> desc employee;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| eid    | int         | NO   | PRI | NULL    |       |
| ename  | varchar(20) | YES  |     | NULL    |       |
| gender | char(1)     | YES  |     | NULL    |       |
| tel    | char(11)    | NO   |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

## 9. 面试

**面试 1 、为什么建表时，加 **`not null default ''`** 或**`default 0`

答：不想让表中出现`null`值

面试 2 、为什么不想要 `null` 的值

答:

+ （ 1 ）不好比较。`null`是一种特殊值，比较时只能用专门的 `is null` 和 `is not null`来比较。碰到运算符，通常返回`null`
+ （ 2 ）效率不高。影响提高索引效果。因此，我们往往在建表时 `not null default ''` 或 `default 0`

**面试 3 、带**`AUTO_INCREMENT`**约束的字段值是从 **`1`** 开始的吗？**

答: 在MySQL中，默认`AUTO_INCREMENT`的初始值是 `1` ，每新增一条记录，字段值自动加 `1` 。设置自增属性（`AUTO_INCREMENT`）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为 `5` ，则以后插入的记录的`id`值就会从 `6` 开始往上增加。添加主键约束时，往往需要设置字段自动增加属性

**面试 4 、并不是每个表都可以任意选择存储引擎？**

外键约束（`FOREIGN KEY`）不能跨引擎使用。  
**MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。**
